        -:    0:Source:/home/mdeschu/cfe-660-ut/cfe/fsw/cfe-core/src/fs/cfe_fs_decompress.c
        -:    0:Programs:3
        -:    1:/*
        -:    2:** $Id: cfe_fs_decompress.c 1.14 2014/04/14 15:21:52GMT-05:00 lwalling Exp  $
        -:    3:**
        -:    4:**   File: CFE_FS_decompress.c
        -:    5:**
        -:    6:**      Copyright (c) 2004-2012, United States government as represented by the 
        -:    7:**      administrator of the National Aeronautics Space Administration.  
        -:    8:**      All rights reserved. This software(cFE) was created at NASA's Goddard 
        -:    9:**      Space Flight Center pursuant to government contracts.
        -:   10:**
        -:   11:**      This is governed by the NASA Open Source Agreement and may be used, 
        -:   12:**      distributed and modified only pursuant to the terms of that agreement.
        -:   13:**
        -:   14:**   Author:   A. Cudmore,    NASA/GSFC Code 582
        -:   15:**             Ported from JWST, which was ported from Swift/BAT, 
        -:   16:**             which was ported from the GNU zip sources.
        -:   17:**
        -:   18:**   Purpose: cFE Port of the gzunzip software ported from Triana->Swift->JWST 
        -:   19:**
        -:   20:*/
        -:   21:
        -:   22:/* Original Credit:
        -:   23: *
        -:   24: * inflate.c -- Not copyrighted 1992 by Mark Adler version c10p1, 10 January
        -:   25: * 1993
        -:   26: *
        -:   27: * You can do whatever you like with this source file, though I would prefer
        -:   28: * that if you modify it and redistribute it that you include comments to
        -:   29: * that effect with your name and the date.  Thank you. [The history has been
        -:   30: * moved to the file ChangeLog.]
        -:   31: */
        -:   32:
        -:   33:/*
        -:   34:** Includes
        -:   35:*/
        -:   36:#include "cfe_fs_decompress.h"
        -:   37:
        -:   38:/*
        -:   39:** Global data -- Note: The following Global Data should be removed. The CFE_FS_Decompress API is not 
        -:   40:**                re-entrant! In order to make sure that two apps will not corrupt the data
        -:   41:**                the API is guarded with a Mutex. This will have serious implications on 
        -:   42:**                real time performance if an application blocks while another is in the API.
        -:   43:**               
        -:   44:*/
        -:   45:CFE_FS_Decompress_State_t CFE_FS_Decompress_State_NR;
        -:   46:
        -:   47:static uint32     trace[ 3 ];
        -:   48:
        -:   49:/*
        -:   50:** Code
        -:   51:*/
        -:   52:
        -:   53:/* Main API entry point to decompress a file -
        -:   54: * Uses a global state buffer but protects the global by a mutex, so it may block if
        -:   55: * more than one thread tries to do this at any given time.
        -:   56: */
        3:   57:int32 CFE_FS_Decompress( const char * srcFileName, const char * dstFileName )
        -:   58:{
        -:   59:
        -:   60:   int32 rc;
        -:   61:
        -:   62:   /*
        -:   63:   ** Lock the API with the FS Mutex
        -:   64:   */
        3:   65:   CFE_FS_LockSharedData(__func__);
        -:   66:
        3:   67:   rc = CFE_FS_Decompress_Reentrant(&CFE_FS_Decompress_State_NR, srcFileName, dstFileName );
        -:   68:
        -:   69:   /*
        -:   70:   ** Unlock FS Shared data mutex
        -:   71:   */
        3:   72:   CFE_FS_UnlockSharedData(__func__);
        -:   73:
        3:   74:   return rc;
        -:   75:}
        -:   76:
        -:   77:
        6:   78:int32 CFE_FS_Decompress_Reentrant(CFE_FS_Decompress_State_t *State, const char * srcFileName, const char * dstFileName )
        -:   79:{
        -:   80:
        -:   81:   int32 guzerror;
        -:   82:
        6:   83:   State->Error = CFE_SUCCESS; /*Initialize this variable.  */
        -:   84:
        -:   85:   /*
        -:   86:   ** initialize max number of Huffman tables allocated to zero 
        -:   87:   */
        6:   88:   State->max_hufts = 0;
        -:   89:
        -:   90:   /*  
        -:   91:   ** Open input file 
        -:   92:   */
        6:   93:   State->srcFile_fd = OS_open( srcFileName, OS_READ_ONLY, 0 );
        -:   94:
        -:   95:   /*
        -:   96:   ** if input file could not be opened, return cFE error code 
        -:   97:   */
        6:   98:   if ( State->srcFile_fd < 0 )
        -:   99:   {
        2:  100:      CFE_ES_WriteToSysLog("CFE_FS_Decompress: Cannot open source file: %s\n",
        -:  101:                            srcFileName);
        2:  102:      return (CFE_FS_GZIP_OPEN_INPUT);
        -:  103:   }
        -:  104:
        -:  105:   /*
        -:  106:   ** open output file 
        -:  107:   */
        4:  108:   State->dstFile_fd = OS_creat( dstFileName, OS_WRITE_ONLY);
        -:  109:
        -:  110:   /*
        -:  111:   ** if output file could not be opened, return cFE error code
        -:  112:   */ 
        4:  113:   if ( State->dstFile_fd < 0 )
        -:  114:   {
        1:  115:      CFE_ES_WriteToSysLog("CFE_FS_Decompress: Cannot open destination file: %s\n",
        -:  116:                            dstFileName);
        -:  117:
        -:  118:      /* close the source file before bailing out */
        1:  119:      OS_close( State->srcFile_fd );
        -:  120:
        1:  121:      return (CFE_FS_GZIP_OPEN_OUTPUT);
        -:  122:   }
        -:  123:
        3:  124:   memset( State->hufTable,  0, MAX_HUF_TABLES * sizeof(HufTable) );
        3:  125:   memset( State->window, 0, WSIZE_X2 );
        3:  126:   memset( trace,     0, 3 * sizeof(uint32) ); 
        -:  127:		
        -:  128:   /* 
        -:  129:   ** uncompress the file 
        -:  130:   */
        3:  131:   guzerror = FS_gz_unzip_Reentrant(State);
        -:  132:
        -:  133:   /* 
        -:  134:   ** close input and output files 
        -:  135:   */
        3:  136:   OS_close( State->dstFile_fd );
        3:  137:   OS_close( State->srcFile_fd );
        -:  138:
        -:  139:   /* 
        -:  140:   ** delete output file after error
        -:  141:   */
        3:  142:   if (guzerror != CFE_SUCCESS)
        -:  143:   {
        1:  144:      OS_remove(dstFileName);
        -:  145:   }
        -:  146:
        -:  147:
        -:  148:   /* 
        -:  149:   ** return cFE error code
        -:  150:   */
        3:  151:   return(guzerror);
        -:  152:}
        -:  153:
        -:  154:
        3:  155:void FS_gz_clear_bufs_Reentrant( CFE_FS_Decompress_State_t *State )
        -:  156:{
        3:  157:	State->outcnt = 0;
        3:  158:	State->insize = 0;
        3:  159:	State->inptr  = 0;
        -:  160:
        3:  161:	State->bytes_in  = 0L;
        3:  162:	State->bytes_out = 0L;
        3:  163:}
        -:  164:
        -:  165:
        3:  166:int32 FS_gz_eat_header_Reentrant( CFE_FS_Decompress_State_t *State )
        -:  167:{
        -:  168:	uint8   flags;                  /* compression flags */
        -:  169:	int8    magic[2];               /* magic header      */
        -:  170:	int8    thisByte;				     /* temporary holder for current byte in a string read */
        -:  171:	uint32  stamp;                  /* time stamp        */
        -:  172:	boolean keep_going;
        -:  173:
        -:  174:	/*  read input buffer (check for read error) */
        3:  175:	magic[0] = (int8)NEXTBYTE();
        3:  176:	if( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  177:
        3:  178:	magic[1] = (int8)NEXTBYTE();
        3:  179:	if ( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  180:
        5:  181:	if ( memcmp( magic, GZIP_MAGIC, 2 ) == 0 || memcmp( magic, OLD_GZIP_MAGIC, 2 ) == 0 ) 
        -:  182:   {
        -:  183:		
        2:  184:		NEXTBYTE();
        2:  185:		if ( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  186:		
        2:  187:		flags = NEXTBYTE();
        2:  188:		if ( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  189:		
        2:  190:		stamp  = (uint32)NEXTBYTE();
        2:  191:		if( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        2:  192:		stamp |= (uint32)NEXTBYTE() <<  8;
        2:  193:		if( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        2:  194:		stamp |= (uint32)NEXTBYTE() << 16;
        2:  195:		if( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        2:  196:		stamp |= (uint32)NEXTBYTE() << 24;
        2:  197:		if( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  198:		
        2:  199:		NEXTBYTE();		/* Ignore extra flags for the moment */
        2:  200:		if( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        2:  201:		NEXTBYTE();		/* Ignore OS type for the moment */ 
        2:  202:		if( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  203:		
        2:  204:		if ( (flags & CONTINUATION) != 0 ) {
    #####:  205:			NEXTBYTE();
    #####:  206:			if( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
    #####:  207:			NEXTBYTE();
    #####:  208:			if( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  209:		}
        -:  210:		
        2:  211:		if ( (flags & EXTRA_FIELD) != 0 ) {
        -:  212:			uint32 len;
    #####:  213:			len  = NEXTBYTE();
    #####:  214:			if( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
    #####:  215:			len |= NEXTBYTE() << 8;
    #####:  216:			if( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
    #####:  217:			while (len--) {
    #####:  218:				NEXTBYTE();
    #####:  219:				if( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  220:			}
        -:  221:		}
        -:  222:		
        -:  223:		/* Get original file name if it was truncated */
        2:  224:		if ( (flags & ORIG_NAME) != 0 ) {
        2:  225:			keep_going = TRUE;
       16:  226:			while ( keep_going ) {
        -:  227:
        -:  228:				/* Get the next byte */
       12:  229:				thisByte = NEXTBYTE();
        -:  230:
        -:  231:				/* Header failure when end of file is reached or a read failure occurs */
       12:  232:				if ((thisByte == EOF) || (State->Error != CFE_SUCCESS)) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  233:
        -:  234:				/* End of string was found */
       12:  235:				if (thisByte == 0) keep_going = FALSE;
        -:  236:			}
        -:  237:		}
        -:  238:		
        -:  239:		/*  Discard file comment if any  */
        2:  240:		if ( (flags & COMMENT) != 0 ) {
    #####:  241:			keep_going = TRUE;
    #####:  242:			while ( keep_going ) {
        -:  243:
        -:  244:				/* Get the next byte */
    #####:  245:				thisByte = NEXTBYTE();
        -:  246:
        -:  247:				/* Header failure when end of file is reached or a read failure occurs */
    #####:  248:				if ((thisByte == EOF) || (State->Error != CFE_SUCCESS)) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  249:
        -:  250:				/* End of string was found */
    #####:  251:				if (thisByte == 0) keep_going = FALSE;
        -:  252:			}
        -:  253:		}
        -:  254:	}
        -:  255:	else
        -:  256:	{
        1:  257:		State->Error = CFE_FS_GZIP_NON_ZIP_FILE;
        -:  258:	}
        -:  259:
        3:  260:	return State->Error;
        -:  261:}
        -:  262:
        -:  263:/*
        -:  264:** Fill the input buffer. This is called only when the buffer is empty. 
        -:  265:*/
        6:  266:int16 FS_gz_fill_inbuf_Reentrant( CFE_FS_Decompress_State_t *State )
        -:  267:{
        -:  268:	int32 len;
        -:  269:
        -:  270:	/*  Read as much as possible */
        6:  271:	State->insize = 0;
        -:  272:
        -:  273:	do 
        -:  274:   {
        8:  275:		len = OS_read( State->srcFile_fd, (int8*)State->inbuf + State->insize, INBUFSIZ - State->insize );
        -:  276:		
        8:  277:		if ( len == 0 || len == EOF || len == OS_FS_ERROR ) break;
        -:  278:		
        7:  279:		State->insize += len;
        -:  280:		
        7:  281:	} while ( State->insize < INBUFSIZ );
        -:  282:
        -:  283:
        6:  284:	if ( State->insize == 0 ) return EOF;
        -:  285:
        5:  286:	if ( len == OS_FS_ERROR ) 
        -:  287:   {
    #####:  288:		State->Error = CFE_FS_GZIP_READ_ERROR;
    #####:  289:		return EOF;
        -:  290:	}
        -:  291:
        5:  292:	State->bytes_in += (uint32)State->insize;
        5:  293:	State->inptr = 1;
        -:  294:
        5:  295:	return State->inbuf[0];
        -:  296:}
        -:  297:
        -:  298:
        -:  299:/*  Write the output window window[0..State->outcnt-1] and update crc and */
        -:  300:/*   State->bytes_out. (Used for the decompressed data only.) */
        -:  301:/*  merged original State->flush_window & State->write_buf together - glw */
        -:  302:/* fix for infinite loop when file store is full -dds */
        9:  303:void FS_gz_flush_window_Reentrant( CFE_FS_Decompress_State_t *State )
        -:  304:{
        -:  305:
        -:  306:	int32  n;
        -:  307:	uint32  cnt;
        -:  308:	uint8   *gz_window_position;
        -:  309:
        9:  310:	if ( State->outcnt == 0 ) return;
        -:  311:
        9:  312:	FS_gz_updcrc( State->window, State->outcnt );
        -:  313:
        9:  314:	cnt = State->outcnt;
        9:  315:	gz_window_position = State->window;
        -:  316:
       37:  317:	while ( State->Error != CFE_FS_GZIP_WRITE_ERROR  &&
       18:  318:		    ( n = OS_write(State->dstFile_fd, (int8 *)gz_window_position, cnt) ) != cnt )
        -:  319:	{ 
        1:  320:		if ( n <= 0 ) State->Error = CFE_FS_GZIP_WRITE_ERROR;
        -:  321:		
        1:  322:		cnt -= n;
        1:  323:		gz_window_position += n;
        -:  324:	}
        -:  325:
        9:  326:	State->bytes_out += (uint32)State->outcnt;
        -:  327:
        9:  328:	State->outcnt = 0;
        -:  329:}
        -:  330:
        -:  331:
        -:  332:/*  Given a list of code lengths and a maximum table size, make a set of */
        -:  333:/*  tables to decode that set of codes.  Return zero on success, one if the */
        -:  334:/*  given code set is incomplete (the tables are still built in this case), */
        -:  335:/*  two if the input is invalid (all zero length codes or an oversubscribed */
        -:  336:/*  set of lengths), and three if not enough memory. */
        -:  337:
        -:  338:/*  INPUT:  */
        -:  339:/*	uint32    *b;      */             /* code lengths in bits (all assumed <= BMAX) */
        -:  340:/*	uint32     n;      */             /* number of codes (assumed <= N_MAX)         */
        -:  341:/*	uint32     s;       */            /* number of simple-valued codes (0..s-1)     */
        -:  342:/*	uint16    *d;       */            /* list of base values for non-simple codes   */
        -:  343:/*	uint16    *e;       */            /* list of extra bits for non-simple codes    */
        -:  344:/*	int32     *m;       */            /* maximum lookup bits, returns actual        */
        -:  345:
       38:  346:int32 FS_gz_huft_build_Reentrant( CFE_FS_Decompress_State_t *State, uint32 * b, uint32 n, uint32 s, uint16 * d, uint16 * e, int32 * m )
        -:  347:{
        -:  348:
        -:  349:	uint32  a;              /* counter for codes of length k        */
        -:  350:	uint32  c[BMAX + 1];    /* bit length count table               */
        -:  351:	uint32  f;              /* i repeats in table every f entries   */
        -:  352:	int32   g;              /* maximum code length                  */
        -:  353:	int32   h;              /* table level                          */
        -:  354:	register uint32 i;      /* counter, current code                */
        -:  355:	register uint32 j;      /* counter                              */
        -:  356:	register int32  k;      /* number of bits in current code       */
        -:  357:	int32  l;               /* bits per table (returned in m)       */
        -:  358:	uint32 lu;              /* l unsigned                           */
        -:  359:	register uint32 *p;     /* pointer into c[], b[], or v[]        */
        -:  360:	register HufTable *q;   /* points to current table              */
        -:  361:	HufTable r;             /* table entry for structure assignment */
        -:  362:	HufTable *u[BMAX];      /* table stack                          */
        -:  363:	uint32 v[N_MAX];        /* values in order of bit length        */
        -:  364:	register int32 w;       /* bits before this table == (l * h)    */
        -:  365:	uint32 x[BMAX + 1];     /* bit offsets, then code stack         */
        -:  366:	uint32 *xp;             /* pointer into x                       */
        -:  367:	int32 y;                /* number of dummy codes added          */
        -:  368:	uint32 z;               /* number of entries in current table   */
        -:  369:
        -:  370:	uint32 huft_index_q;
       38:  371:	uint32 huft_index_t = 0;
       38:  372:	boolean   not_first_table = FALSE;
       38:  373:	huft_index_t = 0;
        -:  374:
        -:  375:	/*  Generate counts for each bit length  */
       38:  376:	memset( (c), 0, sizeof(c) );
       38:  377:	r.b=0;
       38:  378:	r.e=0;
       38:  379:	r.v.n=0;
       38:  380:	r.v.t=0;
       38:  381:	p = b;
       38:  382:	i = n;
        -:  383:	do 
        -:  384:   {
     4300:  385:		c[*p]++;
     4300:  386:		p++;
     4300:  387:	} while (--i);
        -:  388:	
       38:  389:   if (c[0] == n) 
        -:  390:   {			/* null input--all zero length codes */
    #####:  391:		*m = 0;
    #####:  392:		return CFE_SUCCESS;
        -:  393:	}
        -:  394:
        -:  395:
        -:  396:	/*  Find minimum and maximum length, bound *m by those */
       38:  397:	l = *m;
       38:  398:	for ( j = 1; j <= BMAX; j++ ) if ( c[j] ) break;
       38:  399:	k = j;
       38:  400:	lu = (uint32)l;				   		               /* minimum code length */
       38:  401:	if ( lu < j ) { l = j; lu = (uint32)l; }
       38:  402:	for ( i = BMAX; i; i-- ) if (c[i]) break;
       38:  403:	g = i;						                       /* maximum code length */
       38:  404:	if ( lu > i ) { l = i; lu = (uint32)l; }
       38:  405:	*m = l;
        -:  406:
        -:  407:
        -:  408:	/*  Adjust last length count to fill out codes, if needed */
      260:  409:	for ( y = 1 << j; j < i; j++, y <<= 1 )
      222:  410:	if ( ( y -= c[j] ) < 0 )  return CFE_FS_GZIP_BAD_CODE_BLOCK;    /* bad input: more codes than bits */
       38:  411:	if ( (y -= c[i] ) < 0 )  return CFE_FS_GZIP_BAD_CODE_BLOCK;
       38:  412:	c[i] += y;
        -:  413:
        -:  414:
        -:  415:	/*  Generate starting offsets into the value table for each length */
       38:  416:	x[1] = j = 0;
       38:  417:	p = c + 1;
       38:  418:	xp = x + 2;
      378:  419:	while (--i) {					/* note that i == g from above */
      302:  420:		j += *p++;
      302:  421:		*xp++ = j;
        -:  422:	}
        -:  423:
        -:  424:
        -:  425:	/*  Make a table of values in order of bit lengths */
       38:  426:	p = b;
       38:  427:	i = 0;
        -:  428:	do {
     4300:  429:		if ( (j = *p++) != 0 ) v[x[j]++] = i;
     4300:  430:	} while ( ++i < n );
        -:  431:
        -:  432:
        -:  433:	/*  Generate the Huffman codes and for each, make the table entries  */
       38:  434:	x[0] = i = 0;				  /* first Huffman code is zero   */
       38:  435:	p = v;						  /* grab values in bit order     */
       38:  436:	h = -1;						  /* no tables yet--level -1      */
       38:  437:	w = -l;						  /* bits decoded == (l * h)      */
       38:  438:	u[0] = (HufTable *)NULL;      /* just to keep compilers happy */
       38:  439:	q = (HufTable *)NULL;         /* ditto */
       38:  440:	z = 0;                        /* ditto */
        -:  441:
        -:  442:
        -:  443:	/*  go through the bit lengths (k already is bits in shortest code) */
      298:  444:	for (; k <= g; k++) {
      260:  445:		a = c[k];
     4594:  446:		while (a--) {
        -:  447:			
        -:  448:			/*      here i is the Huffman code of length k bits for value *p */
        -:  449:			/*      make tables up to required level */
     8842:  450:	        while (k > w + l) {
      694:  451:				h++;
      694:  452:				w += l;			/* previous table always l bits */
        -:  453:				
        -:  454:				/*        compute minimum size table less than or equal to l bits */
      694:  455:				z = g - w;
      694:  456:				z = ( z > lu ? l : z );                        /* upper limit on table size */
      694:  457:				j = k - w;
      694:  458:				f = 1<<j;
      694:  459:				if ( f > a + 1 )  {                            /* try a k-w bit table */
        -:  460:					
        -:  461:					/*          too few codes for k-w bit table  */
       59:  462:					f -= a + 1;                         /* deduct codes from patterns left */
       59:  463:					xp = c + k;
      240:  464:					while ( ++j < z )  {                /* try smaller tables up to z bits */
      126:  465:						f <<= 1;
      126:  466:						if ( f <= *++xp ) break;	        /* enough codes to use up j bits   */
      122:  467:						f -= *xp;                         /* else deduct codes from patterns */
        -:  468:					}
        -:  469:					
        -:  470:				}
      694:  471:				z = 1 << j;                           /* table entries for j-bit table   */
        -:  472:				
        -:  473:				/*        if space remains in the Huffman table memory array, "allocate" and link in new table */
      694:  474:				if ( State->hufts + (z + 1) > MAX_HUF_TABLES ) return CFE_FS_GZIP_NO_MEMORY;
        -:  475:				
      694:  476:				q = &State->hufTable[State->hufts];
      694:  477:				huft_index_q = State->hufts;
      694:  478:				State->hufts += z + 1;
      694:  479:				if ( State->hufts > State->max_hufts ) State->max_hufts = State->hufts;
        -:  480:				
      694:  481:				if ( not_first_table ) State->hufTable[huft_index_t].v.t = huft_index_q + 1;
       38:  482:				else                   not_first_table = TRUE;
        -:  483:				
      694:  484:				huft_index_t = huft_index_q;
      694:  485:				State->hufTable[huft_index_t].v.t = 0xffff;               /* stand-in for NULL */
        -:  486:				
      694:  487:				u[h] = ++q;		                        /* table starts after link */
      694:  488:				huft_index_q++;
        -:  489:				
        -:  490:				/*        connect to last table, if there is one */
      694:  491:				if ( h ) {
      656:  492:					x[h] = i;                /* save pattern for backing up    */
      656:  493:					r.b = (uint8)l;     	  /* bits to dump before this table */
      656:  494:					r.e = (uint8)(16 + j);	  /* bits in this table             */
        -:  495:					/*             r.t = q;  */               /* pointer to this table          */
      656:  496:					r.v.t = huft_index_q;    /* pointer to this table          */
      656:  497:					j = i >> (w - l);        /* (get around Turbo C bug)       */
      656:  498:					u[h - 1][j] = r;         /* connect to last table          */ 
        -:  499:				}
        -:  500:				
        -:  501:	        }
        -:  502:			
        -:  503:			/*      set up table entry in r */
     4074:  504:	        r.b = (uint8)(k - w);
     4074:  505:	        if (p >= v + n) {
        2:  506:				r.e = 99;                             /* out of values--invalid code     */
     4072:  507:	        } else if ( *p < s ) {
     3417:  508:				r.e = (uint8)( *p < 256 ? 16 : 15 );	/* 256 is end-of-block code        */
     3417:  509:				r.v.n = *p;          	                /* simple code is just the value   */
     3417:  510:				p++;                                  /* one compiler does not like *p++ */
        -:  511:	        } else {
      655:  512:				r.e = (uint8)( e[*p - s] );           /* non-simple--look up in lists */
      655:  513:				r.v.n = d[*p++ - s];
        -:  514:	        }
        -:  515:			
        -:  516:			/*      fill code-like entries with r */
     4074:  517:	        f = 1 << (k - w);
     4074:  518:			j = i >> w;
        -:  519:
     4074:  520:			if( (q == (HufTable *)NULL) && (j < z) )
        -:  521:			{
    #####:  522:				return CFE_FS_GZIP_BAD_CODE_BLOCK;
        -:  523:			}
        -:  524:			else
        -:  525:			{
     4074:  526:	        	for ( j = i >> w; j < z; j += f ) q[j] = r;
        -:  527:			}
        -:  528:			
        -:  529:			/*      backwards increment the k-bit code i */
     4074:  530:	        for ( j = 1 << (k - 1); i & j; j >>= 1 ) i ^= j;
     4074:  531:	        i ^= j;
        -:  532:			
        -:  533:			/*      backup over finished tables */
     8804:  534:	        while (( h >= 0 ) && ( ( i & ((1 << w) - 1) ) != x[h] )) {
      656:  535:				h--;                                       /* don't need to update q */
      656:  536:				w -= l;
        -:  537:	        }
        -:  538:			
        -:  539:		}
        -:  540:		
        -:  541:	}
        -:  542:
        -:  543:	/*  Return true (1) if we were given an incomplete table  */
       38:  544:	if((y != 0 && g != 1))
        -:  545:	{
        1:  546:		return CFE_FS_GZIP_BAD_DATA;
        -:  547:	}
        -:  548:
       37:  549:	return CFE_SUCCESS;
        -:  550:
        -:  551:}
        -:  552:
        -:  553:
        -:  554:
        2:  555:int32 FS_gz_inflate_Reentrant( CFE_FS_Decompress_State_t *State )
        -:  556:{
        -:  557:
        -:  558:	int32           e;        /* last block flag */
        -:  559:	int32   r;        /* result code     */
        -:  560:
        -:  561:	/*  initialize window, bit buffer */
        2:  562:	State->outcnt = 0;
        2:  563:	State->bk     = 0;
        2:  564:	State->bb     = 0;
        -:  565:
        -:  566:	/*  decompress until the last block */
        -:  567:	do {
       12:  568:		r = FS_gz_inflate_block_Reentrant( State, &e);
       12:  569:		if ( r != CFE_SUCCESS ) return r;
       12:  570:	} while (!e);
        -:  571:
        -:  572:	/*  Undo too much lookahead. The next read will be byte aligned so we can */
        -:  573:	/*  discard unused bits in the last meaningful byte. */
        4:  574:	while ( State->bk >= 8 ) {
    #####:  575:		State->bk -= 8;
    #####:  576:		State->inptr--;
        -:  577:	}
        -:  578:
        -:  579:	/*  flush out sliding window */
        2:  580:	FS_gz_flush_window_Reentrant(State);
        -:  581:
        -:  582:	/*  return success */
        2:  583:	return CFE_SUCCESS;
        -:  584:
        -:  585:}
        -:  586:
        -:  587:
        -:  588:/*  
        -:  589:** decompress an inflated block 
        -:  590:*/
       12:  591:int32 FS_gz_inflate_block_Reentrant( CFE_FS_Decompress_State_t *State, int32 * e )
        -:  592:{
        -:  593:
        -:  594:	uint32  t;          /* block type */
        -:  595:	uint32  b;          /* bit buffer */
        -:  596:	uint32  k;          /* number of bits in bit buffer */
        -:  597:
        -:  598:	int32 res;
        -:  599:
        -:  600:	/*  make local bit buffer */
       12:  601:	b = State->bb;
       12:  602:	k = State->bk;
        -:  603:
        -:  604:	/*  read in last block bit */
       12:  605:	NEEDBITS(1)
       12:  606:	*e = (int32)b & 1;
       12:  607:	DUMPBITS(1)
        -:  608:
        -:  609:
        -:  610:	/*  read in block type */
       12:  611:	NEEDBITS(2)
       12:  612:	t = (uint32)b & 3;
       12:  613:	DUMPBITS(2)
        -:  614:
        -:  615:
        -:  616:	/*  restore the global bit buffer */
       12:  617:	State->bb = b;
       12:  618:	State->bk = k;
        -:  619:
        -:  620:
        -:  621:	/*  inflate that block type */
       12:  622:	if      ( t == 0 ) { res = FS_gz_inflate_stored_Reentrant(State);  trace[0]++; }
       12:  623:	else if ( t == 1 ) { res = FS_gz_inflate_fixed_Reentrant(State);   trace[1]++; }
       12:  624:	else if ( t == 2 ) { res = FS_gz_inflate_dynamic_Reentrant(State); trace[2]++; }
        -:  625:
    #####:  626:	else               res = CFE_FS_GZIP_BAD_CODE_BLOCK;    
        -:  627:
       12:  628:	return res;
        -:  629:
        -:  630:}
        -:  631:
        -:  632:/* Inflate (decompress) the codes in a deflated (compressed) block.  */
        -:  633:/* Return an error code or zero if it all goes ok. */
       13:  634:int32 FS_gz_inflate_codes_Reentrant( CFE_FS_Decompress_State_t *State, HufTable * tl, HufTable * td, int32 bl, int32 bd )
        -:  635:{
        -:  636:
        -:  637:	static uint16 mask_bits[] = {
        -:  638:		0x0000,
        -:  639:			0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
        -:  640:			0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
        -:  641:	};
        -:  642:
        -:  643:
        -:  644:	uint32      e;          /* table entry flag/number of extra bits  */
        -:  645:	uint32      n, d;       /* length and index for copy              */
        -:  646:	uint32      w;          /* current window position                */
        -:  647:	HufTable   *t;          /* pointer to table entry                 */
        -:  648:	uint32      ml, md;     /* masks for bl and bd bits               */
        -:  649:	uint32      b;          /* bit buffer                             */
        -:  650:	uint32      k;          /* number of bits in bit buffer           */
        -:  651:
        -:  652:	uint32 index;
        -:  653:
        -:  654:	/*  make local copies of globals  */
       13:  655:	b = State->bb;					/* initialize bit buffer */
       13:  656:	k = State->bk;
       13:  657:	w = State->outcnt;				/* initialize window position */
        -:  658:
        -:  659:	/*  inflate the coded data */
       13:  660:	ml = mask_bits[bl];			/* precompute masks for speed */
       13:  661:	md = mask_bits[bd];
        -:  662:
        -:  663:	for (;;) 
        -:  664:   {					/* do until end of block */
        -:  665:		
    48269:  666:		NEEDBITS((uint32)bl);
    48269:  667:      t = tl + ((uint32)b & ml);
    48269:  668:		e = t->e;
    48269:  669:		if ( e > 16 ) 
        -:  670:      {
        -:  671:	        do 
        -:  672:           {
     4158:  673:              if (e == 99) return CFE_FS_GZIP_BAD_DATA;
     4158:  674:              DUMPBITS(t->b);
     4158:  675:              e -= 16;
     4158:  676:				  NEEDBITS(e);
     4158:  677:              index = t->v.t + ( (uint32)b & mask_bits[e] );
     4158:  678:				  if ( index >= 0  &&  index < State->hufts )
     4158:  679:                 t = &( State->hufTable[index] );
        -:  680:				  else  
    #####:  681:                 return CFE_FS_GZIP_INDEX_ERROR;
     4158:  682:				  e = t->e;
     4158:  683:	        } while ( e > 16 );
        -:  684:		}
        -:  685:		
    48269:  686:		DUMPBITS(t->b);
        -:  687:			
    48269:  688:      if ( e == 16 ) 
        -:  689:      {                 /* then it's a literal */
        -:  690:				
        -:  691:         /* gz_window[w++] = (uint8)(t->n); */
    28406:  692:         State->window[w++] = (uint8)(t->v.n);
    28406:  693:         if ( w == WSIZE ) 
        -:  694:         {
    #####:  695:            State->outcnt = w;
    #####:  696:            FS_gz_flush_window_Reentrant(State);
    #####:  697:            w = 0;
        -:  698:         }
        -:  699:				
        -:  700:      } 
        -:  701:      else 
        -:  702:      {                        /* it's an EOB or a length */
        -:  703:				
        -:  704:         /*  exit if end of block  */
    19863:  705:         if ( e == 15 ) break;
        -:  706:				
        -:  707:         /*  get length of block to copy */
    19850:  708:         NEEDBITS(e);
    19850:  709:         n = t->v.n + ( (uint32)b & mask_bits[e] );
    19850:  710:         DUMPBITS(e);
        -:  711:				
        -:  712:         /*  decode distance of block to copy  */
    19850:  713:         NEEDBITS((uint32)bd);
    19850:  714:         t = td + ((uint32)b & md);
    19850:  715:         e = t->e;
    19850:  716:         if ( e > 16 ) 
        -:  717:         {
        -:  718:            do 
        -:  719:            {
      674:  720:               if (e == 99) return CFE_FS_GZIP_BAD_DATA;
      674:  721:               DUMPBITS(t->b);
      674:  722:               e -= 16;
      674:  723:               NEEDBITS(e);
      674:  724:               index = t->v.t + ( (uint32)b & mask_bits[e] );
      674:  725:               if ( index >= 0  &&  index < State->hufts )
      674:  726:                  t = &( State->hufTable[index] );
        -:  727:               else  
    #####:  728:                  return CFE_FS_GZIP_INDEX_ERROR;
      674:  729:               e = t->e;
      674:  730:            } while ( e > 16 );
        -:  731:         }
    19850:  732:         DUMPBITS(t->b);
        -:  733:					
    19850:  734:         NEEDBITS(e);
    19850:  735:         d = w - t->v.n - ((uint32)b & mask_bits[e]);
    19850:  736:         DUMPBITS(e);
        -:  737:					
        -:  738:         /* do the copy */
        -:  739:         do 
        -:  740:         {
        -:  741:						
    19870:  742:            d &= WSIZE - 1;
    19870:  743:            e = WSIZE - ( d > w ? d : w);
    19870:  744:            e = ( e > n ? n : e );
    19870:  745:            n -= e;
        -:  746:						
    19870:  747:            if ( w - d >= e ) 
        -:  748:            { /* (this test assumes unsigned comparison) */
        -:  749:							
    19708:  750:               memcpy( State->window + w, State->window + d, e );
    19708:  751:               w += e;
    19708:  752:               d += e;
        -:  753:							
        -:  754:            } 
        -:  755:            else 
        -:  756:            { /* do it slow to avoid memcpy() overlap */
        -:  757:							
        -:  758:               do 
        -:  759:               {
    16248:  760:                  State->window[w++] = State->window[d++];
    16248:  761:               } while (--e);
        -:  762:							
        -:  763:            }
        -:  764:						
    19870:  765:            if ( w == WSIZE ) 
        -:  766:            {
        6:  767:               State->outcnt = w;
        6:  768:               FS_gz_flush_window_Reentrant(State);
        6:  769:               w = 0;
        -:  770:            }
        -:  771:						
    19870:  772:         } while (n);
        -:  773:					
        -:  774:      }
        -:  775:			
    48256:  776:   }
        -:  777:
        -:  778:	/*  restore the globals from the locals */
       13:  779:	State->outcnt = w;				/* restore global window pointer */
       13:  780:	State->bb = b;					/* restore global bit buffer */
       13:  781:	State->bk = k;
        -:  782:
       13:  783:	return CFE_SUCCESS;
        -:  784:}
        -:  785:
        -:  786:/*
        -:  787:** removed gz_huft_free, no longer needed - glw 
        -:  788:** -- decompress an inflated type 2 (dynamic Huffman codes) block. 
        -:  789:*/
       12:  790:int32 FS_gz_inflate_dynamic_Reentrant( CFE_FS_Decompress_State_t *State )
        -:  791:{
        -:  792:
        -:  793:	static int32 lbits = 9;      /* bits in base literal/length lookup table */
        -:  794:	static int32 dbits = 6;      /* bits in base distance lookup table */
        -:  795:
        -:  796:	/*  Order of the bit length code lengths */
        -:  797:	static uint32 border[] = {
        -:  798:		16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
        -:  799:	};
        -:  800:
        -:  801:	/*  Copy lengths for literal codes 257..285 */
        -:  802:	static uint16 cplens[] = {
        -:  803:		3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        -:  804:			35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
        -:  805:	};
        -:  806:
        -:  807:	/*  Extra bits for literal codes 257..285    ( 99==invalid ) */
        -:  808:	static uint16 cplext[] = {
        -:  809:		0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        -:  810:			3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99
        -:  811:	};
        -:  812: 
        -:  813:	/*  Copy offsets for distance codes 0..29 */
        -:  814:	static uint16 cpdist[] = {
        -:  815:		1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        -:  816:			257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        -:  817:			8193, 12289, 16385, 24577
        -:  818:	};
        -:  819:
        -:  820:	/*  Extra bits for distance codes */
        -:  821:	static uint16 cpdext[] = {
        -:  822:		0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
        -:  823:			7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13
        -:  824:	};
        -:  825:
        -:  826:	static uint16 mask_bits[] = {
        -:  827:		0x0000,
        -:  828:			0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
        -:  829:			0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
        -:  830:	};
        -:  831:
        -:  832:
        -:  833:	int32      i;               /* temporary variables                      */
        -:  834:	uint32     j;
        -:  835:	uint32     l;               /* last length                              */
        -:  836:	uint32     m;               /* mask for bit lengths table               */
        -:  837:	uint32     n;               /* number of lengths to get                 */
        -:  838:	HufTable  *tl;              /* literal/length code table                */
        -:  839:	HufTable  *td;              /* distance code table                      */
        -:  840:	int32      bl;              /* lookup bits for tl                       */
        -:  841:	int32      bd;              /* lookup bits for td                       */
        -:  842:	uint32     nb;              /* number of bit length codes               */
        -:  843:	uint32     nl;              /* number of literal/length codes           */
        -:  844:	uint32     nd;              /* number of distance codes                 */
        -:  845:	uint32     ll[286 + 30];    /* literal/length and distance code lengths */
        -:  846:
        -:  847:	uint32     b;               /* bit buffer                   */
        -:  848:	uint32     k;               /* number of bits in bit buffer */
        -:  849:
        -:  850:	int32 error_code;
        -:  851:
        -:  852:	/*  make local bit buffer */
       12:  853:	b = State->bb;
       12:  854:	k = State->bk;
        -:  855:
        -:  856:	/*  read in table lengths */ 
       12:  857:	NEEDBITS(5);
       12:  858:	nl = 257 + ((uint32)b & 0x1f);	/* number of literal/length codes */
       12:  859:	DUMPBITS(5);
        -:  860:
       12:  861:	NEEDBITS(5);
       12:  862:	nd = 1 + ((uint32) b & 0x1f);	/* number of distance codes */
       12:  863:	DUMPBITS(5);
        -:  864:
       12:  865:	NEEDBITS(4);
       12:  866:	nb = 4 + ((uint32) b & 0xf);	/* number of bit length codes */
       12:  867:	DUMPBITS(4);
        -:  868:
       12:  869:	if (nl > 286 || nd > 30)  return CFE_FS_GZIP_BAD_DATA;				/* bad lengths */
        -:  870:
        -:  871:	/*  read in bit-length-code lengths */
      182:  872:	for (j = 0; j < nb; j++) {
      170:  873:		NEEDBITS(3);
      170:  874:			ll[border[j]] = (uint32)b & 7;
      170:  875:		DUMPBITS(3);
        -:  876:	}
       12:  877:	for (; j < 19; j++) ll[border[j]] = 0;
        -:  878:
        -:  879:	/*  build decoding table for trees--single level, 7 bit lookup  */
       12:  880:	bl = 7;
       12:  881:	State->hufts = 0;             /* initialize Huff Table memory */
       12:  882:	tl = &State->hufTable[1];        /* set known position given alloc removed - glw */
       12:  883:	error_code = FS_gz_huft_build_Reentrant(State, ll, 19, 19, (uint16 *)NULL, (uint16 *)NULL, &bl );
       12:  884:	if ( error_code != CFE_SUCCESS )  return error_code; 
        -:  885:
        -:  886:	/*  read in literal and distance code lengths */
       12:  887:	n = nl + nd;
       12:  888:	m = mask_bits[bl];
       12:  889:	i = l = 0;
     3388:  890:	while ( (uint32)i < n ) 
        -:  891:   {
     3364:  892:		NEEDBITS((uint32)bl);
     3364:  893:      td = tl + ((uint32)b & m);
     3364:  894:		j = td->b;
     3364:  895:		DUMPBITS(j);
     3364:  896:      j = td->v.n;
     3364:  897:		if ( j < 16 ) 
        -:  898:      {            /* length of code in bits (0..15) */
     3234:  899:         ll[i++] = l = j;         /* save last length in l */
        -:  900:		} 
      130:  901:      else if ( j == 16 ) 
        -:  902:      {    /* repeat last length 3 to 6 times */
      118:  903:         NEEDBITS(2);
      118:  904:         j = 3 + ( (uint32)b & 3 );
      118:  905:         DUMPBITS(2);
      118:  906:         if ( (uint32)i + j > n ) return CFE_FS_GZIP_BAD_DATA;
      118:  907:         while (j--) ll[i++] = l;
        -:  908:		} 
       12:  909:      else if (j == 17) 
        -:  910:      {    /* 3 to 10 zero length codes */
       12:  911:         NEEDBITS(3);
       12:  912:         j = 3 + ( (uint32)b & 7 );
       12:  913:         DUMPBITS(3);
       12:  914:         if ( (uint32)i + j > n ) return CFE_FS_GZIP_BAD_DATA;
       12:  915:         while (j--) ll[i++] = 0;
       12:  916:         l = 0;
        -:  917:		} 
        -:  918:      else 
        -:  919:      {                 /* j == 18: 11 to 138 zero length codes */
    #####:  920:         NEEDBITS(7);
    #####:  921:         j = 11 + ( (uint32)b & 0x7f );
    #####:  922:         DUMPBITS(7);
    #####:  923:         if ( (uint32)i + j > n ) return CFE_FS_GZIP_BAD_DATA;
    #####:  924:         while (j--) ll[i++] = 0;
    #####:  925:         l = 0;
        -:  926:		}
        -:  927:	}
        -:  928:
        -:  929:	/*  restore the global bit buffer  */
       12:  930:	State->bb = b;
       12:  931:	State->bk = k;
        -:  932:
        -:  933:	/*  build the decoding tables for literal/length and distance codes */
       12:  934:	bl = lbits;
       12:  935:	State->hufts = 0;                 /* initialize Huff Table memory */
       12:  936:	tl = &State->hufTable[1];            /* set known position given alloc removed - glw */
       12:  937:	error_code = FS_gz_huft_build_Reentrant(State, ll, nl, 257, cplens, cplext, &bl );
       12:  938:	if ( error_code != CFE_SUCCESS ) return error_code;
        -:  939:
       12:  940:	bd = dbits;
       12:  941:	td = &State->hufTable[State->hufts+1];   /* set known position given alloc removed - glw */
       12:  942:	error_code = FS_gz_huft_build_Reentrant(State, ll + nl, nd, 0, cpdist, cpdext, &bd );
       12:  943:	if ( error_code != CFE_SUCCESS ) return error_code;
        -:  944:
        -:  945:	/*  decompress until an end-of-block code */
       12:  946:	error_code = FS_gz_inflate_codes_Reentrant(State, tl, td, bl, bd );
        -:  947:   
       12:  948:	return error_code;
        -:  949:}
        -:  950:
        -:  951:
        -:  952:/* Decompress an inflated type 1 (fixed Huffman codes) block.   */
        -:  953:/*  We should either replace this with a custom decoder,  */
        -:  954:/*  or at least precompute the Huffman tables. */
        -:  955:
        -:  956:/* removed gz_huft_free, no longer needed - glw */
        1:  957:int32 FS_gz_inflate_fixed_Reentrant( CFE_FS_Decompress_State_t *State )
        -:  958:{
        -:  959:	/*  Copy lengths for literal codes 257..285 */
        -:  960:	static uint16 cplens[] = {
        -:  961:		3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        -:  962:			35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
        -:  963:	};
        -:  964:
        -:  965:	/*  Extra bits for literal codes 257..285    ( 99==invalid ) */
        -:  966:	static uint16 cplext[] = {
        -:  967:		0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        -:  968:			3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99
        -:  969:	};
        -:  970:
        -:  971:	/*  Copy offsets for distance codes 0..29 */
        -:  972:	static uint16 cpdist[] = {
        -:  973:		1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        -:  974:			257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        -:  975:			8193, 12289, 16385, 24577
        -:  976:	};
        -:  977:
        -:  978:	/*  Extra bits for distance codes */
        -:  979:	static uint16 cpdext[] = {
        -:  980:		0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
        -:  981:			7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13
        -:  982:	};
        -:  983:
        -:  984:	int32     i;            /* temporary variable            */
        -:  985:	HufTable *tl;           /* literal/length code table     */
        -:  986:	HufTable *td;           /* distance code table           */
        -:  987:	int32     bl;           /* lookup bits for tl            */
        -:  988:	int32     bd;           /* lookup bits for td            */
        -:  989:	uint32    l[288];       /* length list for gz_huft_build */
        -:  990:
        -:  991:	int32 error_code;
        -:  992:
        -:  993:	/*  set up literal table */
        1:  994:	for (i = 0; i < 144; i++) l[i] = 8;
        1:  995:	for (; i < 256; i++)      l[i] = 9;
        1:  996:	for (; i < 280; i++)      l[i] = 7;
        1:  997:	for (; i < 288; i++)      l[i] = 8;       /* make a complete, but wrong code set */
        -:  998:
        1:  999:	bl = 7;
        1: 1000:	State->hufts = 0;              /* initialize huff table "allocation" position  */
        1: 1001:	tl = &State->hufTable[1];         /* set known position given alloc removed - glw */
        1: 1002:	error_code = FS_gz_huft_build_Reentrant(State, l, 288, 257, cplens, cplext, &bl );
        -: 1003:
        1: 1004:	if ( error_code != CFE_SUCCESS ) return error_code;
        -: 1005:
        -: 1006:	/*  set up distance table */
        1: 1007:	for ( i = 0; i < 30; i++ ) l[i] = 5;      /* make an incomplete code set */
        1: 1008:	bd = 5;
        1: 1009:	td = &State->hufTable[State->hufts+1];               /* set known position given alloc removed - glw */
        1: 1010:	error_code = FS_gz_huft_build_Reentrant(State, l, 30, 0, cpdist, cpdext, &bd );
        -: 1011:
        1: 1012:	if ( error_code != CFE_SUCCESS && error_code != CFE_FS_GZIP_BAD_DATA ) return error_code;
        -: 1013:	/*  --- seems odd that BAD DATA is let through, but original did so --- */
        -: 1014:	/*  decompress until an end-of-block code  */
        1: 1015:	error_code = FS_gz_inflate_codes_Reentrant(State, tl, td, bl, bd );
        -: 1016:
        1: 1017:	return error_code;
        -: 1018:
        -: 1019:}
        -: 1020:
        -: 1021:/* 
        -: 1022:** "decompress" an inflated type 0 (stored) block. 
        -: 1023:*/
        1: 1024:int32 FS_gz_inflate_stored_Reentrant( CFE_FS_Decompress_State_t *State )
        -: 1025:{
        -: 1026:
        -: 1027:	uint32          n;     /* number of bytes in block */
        -: 1028:	uint32          w;     /* current window position */
        -: 1029:	register uint32 b;     /* bit buffer */
        -: 1030:	register uint16 k;     /* number of bits in bit buffer */
        -: 1031:
        -: 1032:
        -: 1033:	/*  make local copies of globals */
        1: 1034:	b = State->bb;             /* initialize bit buffer */
        1: 1035:	k = State->bk;
        1: 1036:	w = State->outcnt;         /* initialize window position */
        -: 1037:
        -: 1038:
        -: 1039:	/*  go to byte boundary */
        1: 1040:	n = k & 7;
        1: 1041:	DUMPBITS(n);
        -: 1042:
        -: 1043:	/*  get the length and its complement */
        1: 1044:	NEEDBITS(16);
    #####: 1045:	n = ( (uint32)b & 0xffff );
    #####: 1046:	DUMPBITS(16);
        -: 1047:
    #####: 1048:	NEEDBITS(16);
    #####: 1049:	if ( n != (uint32)( (~b) & 0xffff) )  return CFE_FS_GZIP_BAD_DATA;    /* error in compressed data */
    #####: 1050:	DUMPBITS(16);
        -: 1051:
        -: 1052:
        -: 1053:	/*  read and output the compressed data */
    #####: 1054:	while (n--) 
        -: 1055:   {
    #####: 1056:		NEEDBITS(8);
    #####: 1057:      State->window[w++] = (uint8)b;
    #####: 1058:		if ( w == WSIZE ) 
        -: 1059:      {
    #####: 1060:	        State->outcnt = w;
    #####: 1061:	        FS_gz_flush_window_Reentrant(State);
    #####: 1062:	        w = 0;
        -: 1063:		}
    #####: 1064:		DUMPBITS(8);
        -: 1065:	}
        -: 1066:
        -: 1067:	/*  restore the globals from the locals */
    #####: 1068:	State->outcnt = w;					/* restore global window pointer */
    #####: 1069:	State->bb     = b;					/* restore global bit buffer */
    #####: 1070:	State->bk     = k;
        -: 1071:
    #####: 1072:	return CFE_SUCCESS;
        -: 1073:
        -: 1074:}
        -: 1075:
        -: 1076:
        -: 1077:/* > merged original gunzip & unzip into a single routine */
        -: 1078:/* > replaced Read & Write indirection */
        -: 1079:
        3: 1080:int32 FS_gz_unzip_Reentrant( CFE_FS_Decompress_State_t *State )
        -: 1081:{
        -: 1082:	/*  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- */
        -: 1083:	/*  Unzip in to out.  This routine works on both gzip files. */
        -: 1084:
        -: 1085:	/*  IN assertions: the buffer State->inbuf contains already the beginning of the */
        -: 1086:	/*   compressed data, from offsets State->inptr to State->insize-1 included. The magic */
        -: 1087:	/*   header has already been checked. The output buffer is cleared. */
        -: 1088:
        -: 1089:	int32          guzerror;
        3: 1090:	uint32         orig_crc = 0;        /* original crc */
        3: 1091:	uint32         orig_len = 0;        /* original uncompressed length */
        -: 1092:	int32          n;
        -: 1093:	uint8          buf[EXTHDR];         /* extended local header */
        -: 1094:	int32          res;
        -: 1095:
        3: 1096:	FS_gz_clear_bufs_Reentrant(State);
        -: 1097:
        -: 1098:	/*  Snarf up the header for the zip file, check for read error */
        3: 1099:	guzerror = FS_gz_eat_header_Reentrant(State);
        -: 1100:
        3: 1101:	if( guzerror != CFE_SUCCESS ) return guzerror;
        -: 1102:
        2: 1103:	FS_gz_updcrc(NULL, 0);	                /* initialize crc */
        -: 1104:
        2: 1105:	res = FS_gz_inflate_Reentrant(State);
        -: 1106:
        2: 1107:	if ( res != CFE_SUCCESS ) return res;
        -: 1108:
        -: 1109:	/*  Get the crc and original length */
        -: 1110:	/*    crc32  (see algorithm.doc) uncompressed input size modulo 2^32 */
       18: 1111:	for ( n = 0; n < 8; n++ ) 
        -: 1112:   {
       16: 1113:		buf[n] = NEXTBYTE();      
       16: 1114:		if ( State->Error != CFE_SUCCESS ) return State->Error;
        -: 1115:	}
        2: 1116:	orig_crc = LG(buf);
        2: 1117:	orig_len = LG(buf + 4);
        -: 1118:
        -: 1119:	/*  Validate decompression */
        2: 1120:	if ( orig_crc != FS_gz_updcrc( State->outbuf, 0 ) ) return CFE_FS_GZIP_CRC_ERROR;
        2: 1121:	if ( orig_len != (uint32)State->bytes_out )      return CFE_FS_GZIP_LENGTH_ERROR;
        -: 1122:
        2: 1123:	return CFE_SUCCESS;
        -: 1124:
        -: 1125:}
        -: 1126:
        -: 1127:
        -: 1128:/*  Run a set of bytes through the crc shift register.  If s is a NULL */
        -: 1129:/*   pointer, then initialize the crc shift register contents instead. */ 
        -: 1130:/*   Return the current crc in either case. */
        -: 1131:
        -: 1132:/*  input: */
        -: 1133:/*	  s  pointer to bytes to pump through */
        -: 1134:/*	  n	 number of bytes in s[] */
       13: 1135:uint32 FS_gz_updcrc( uint8 * s, uint32 n )
        -: 1136:{
        -: 1137:	static uint32 crc_32_tab[] = {
        -: 1138:			0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
        -: 1139:			0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
        -: 1140:			0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
        -: 1141:			0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
        -: 1142:			0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
        -: 1143:			0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
        -: 1144:			0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
        -: 1145:			0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
        -: 1146:			0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
        -: 1147:			0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
        -: 1148:			0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
        -: 1149:			0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
        -: 1150:			0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
        -: 1151:			0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
        -: 1152:			0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
        -: 1153:			0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
        -: 1154:			0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
        -: 1155:			0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
        -: 1156:			0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
        -: 1157:			0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
        -: 1158:			0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
        -: 1159:			0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
        -: 1160:			0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
        -: 1161:			0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
        -: 1162:			0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
        -: 1163:			0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
        -: 1164:			0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
        -: 1165:			0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
        -: 1166:			0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
        -: 1167:			0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
        -: 1168:			0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
        -: 1169:			0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
        -: 1170:			0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
        -: 1171:			0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
        -: 1172:			0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
        -: 1173:			0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
        -: 1174:			0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
        -: 1175:			0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
        -: 1176:			0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
        -: 1177:			0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
        -: 1178:			0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
        -: 1179:			0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
        -: 1180:			0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
        -: 1181:			0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
        -: 1182:			0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
        -: 1183:			0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
        -: 1184:			0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
        -: 1185:			0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
        -: 1186:			0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
        -: 1187:			0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
        -: 1188:			0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
        -: 1189:			0x2d02ef8dL
        -: 1190:	};
        -: 1191:
        -: 1192:	register uint32 c;                           /* temporary variable      */
        -: 1193:
        -: 1194:	static uint32 crc = (uint32)0xffffffffL;     /* shift register contents */
        -: 1195:
       13: 1196:	if (s == NULL) 
        -: 1197:   {
        2: 1198:		c = 0xffffffffL;
        -: 1199:	} 
        -: 1200:   else 
        -: 1201:   {
        -: 1202:		
       11: 1203:		c = crc;
       11: 1204:		if (n) 
        -: 1205:      {
        -: 1206:         do
        -: 1207:         {
   225019: 1208:				c = crc_32_tab[ ( (int16)c ^ (*s++) ) & 0xff ] ^ (c >> 8);
        -: 1209:				
   225019: 1210:         } while (--n);			
        -: 1211:		}		
        -: 1212:	}
        -: 1213:
       13: 1214:	crc = c;
        -: 1215:
       13: 1216:	return c ^ 0xffffffffL;      /* (instead of ~c for 64-bit machines) */
        -: 1217:
        -: 1218:}
        -: 1219:
        -: 1220:
