        -:    0:Source:/home/mdeschu/cfe-660-ut/cfe/fsw/cfe-core/src/es/cfe_es_api.c
        -:    0:Programs:11
        -:    1:/*
        -:    2:**  File:  
        -:    3:**    cfe_es_api.c
        -:    4:**
        -:    5:**      Copyright (c) 2004-2012, United States government as represented by the 
        -:    6:**      administrator of the National Aeronautics Space Administration.  
        -:    7:**      All rights reserved. This software(cFE) was created at NASA's Goddard 
        -:    8:**      Space Flight Center pursuant to government contracts.
        -:    9:**
        -:   10:**      This is governed by the NASA Open Source Agreement and may be used,
        -:   11:**      distributed and modified only pursuant to the terms of that agreement.
        -:   12:**
        -:   13:**
        -:   14:**  Purpose:  
        -:   15:**    This file implements the cFE Executive Services API functions.
        -:   16:**
        -:   17:**  References:
        -:   18:**     Flight Software Branch C Coding Standard Version 1.0a
        -:   19:**     cFE Flight Software Application Developers Guide
        -:   20:**
        -:   21:**  Notes:
        -:   22:**
        -:   23:*/
        -:   24:
        -:   25:/*
        -:   26:** Required header files.
        -:   27:*/
        -:   28:#include "private/cfe_private.h"
        -:   29:#include "cfe_es.h"
        -:   30:#include "cfe_es_apps.h"
        -:   31:#include "cfe_es_global.h"
        -:   32:#include "cfe_es_events.h"
        -:   33:#include "cfe_es_cds.h"
        -:   34:#include "cfe_es_cds_mempool.h"
        -:   35:#include "cfe_psp.h"
        -:   36:#include "cfe_es_log.h"
        -:   37:
        -:   38:
        -:   39:#include <string.h>
        -:   40:#include <stdio.h>
        -:   41:#include <stdarg.h>
        -:   42:
        -:   43:
        -:   44:/*
        -:   45:** Function: CFE_ES_GetResetType
        -:   46:**
        -:   47:** Purpose:  Return The Type of reset the cFE had.
        -:   48:**           The function will return the start type 
        -:   49:**           which is CFE_PSP_RST_TYPE_POWERON or CFE_PSP_RST_TYPE_PROCESSOR.
        -:   50:**           The sub-type is optional and will be returned if a non-NULL pointer
        -:   51:**           is passed in to the function.
        -:   52:*/
        2:   53:int32 CFE_ES_GetResetType(uint32 *ResetSubtypePtr)
        -:   54:{
        2:   55:    if ( ResetSubtypePtr != NULL )
        -:   56:    {
        1:   57:       *ResetSubtypePtr = CFE_ES_ResetDataPtr->ResetVars.ResetSubtype;
        -:   58:    }
        -:   59:
        2:   60:    return(CFE_ES_ResetDataPtr->ResetVars.ResetType);
        -:   61:
        -:   62:} /* End of CFE_ES_GetResetType() */
        -:   63:
        -:   64:
        -:   65:/*
        -:   66:** Function: CFE_ES_ResetCFE
        -:   67:**
        -:   68:** Purpose:  Reset the cFE core and all apps.
        -:   69:**
        -:   70:*/
        7:   71:int32 CFE_ES_ResetCFE(uint32 ResetType)
        -:   72:{
        -:   73:    int32 ReturnCode;
        -:   74:    
        7:   75:    if ( ResetType == CFE_PSP_RST_TYPE_PROCESSOR )
        -:   76:    {
        -:   77:       /*
        -:   78:       ** Increment the processor reset count
        -:   79:       */
        4:   80:       CFE_ES_ResetDataPtr->ResetVars.ProcessorResetCount++;
        -:   81:
        -:   82:       /*
        -:   83:       ** Before doing a Processor reset, check to see 
        -:   84:       ** if the maximum number has been exceeded
        -:   85:       */
        8:   86:       if ( CFE_ES_ResetDataPtr->ResetVars.ProcessorResetCount > 
        4:   87:            CFE_ES_ResetDataPtr->ResetVars.MaxProcessorResetCount )
        -:   88:       {
        2:   89:           CFE_ES_WriteToSysLog("POWER ON RESET due to max proc resets (Commanded).\n");
        -:   90:
        -:   91:           /*
        -:   92:           ** Log the reset in the ER Log. The log will be wiped out, but it's good to have
        -:   93:           ** the entry just in case something fails.
        -:   94:           */
        2:   95:           CFE_ES_WriteToERLog(CFE_ES_LogEntryType_CORE, CFE_PSP_RST_TYPE_POWERON,
        -:   96:                                         CFE_PSP_RST_SUBTYPE_RESET_COMMAND,
        -:   97:                                         "POWER ON RESET due to max proc resets (Commanded).", NULL,0 );
        -:   98:           /*
        -:   99:           ** Call the BSP reset routine 
        -:  100:           */
        2:  101:           CFE_PSP_Restart(CFE_PSP_RST_TYPE_POWERON);
        -:  102:       }
        -:  103:       else
        -:  104:       {
        2:  105:           CFE_ES_WriteToSysLog("PROCESSOR RESET called from CFE_ES_ResetCFE (Commanded).\n");
        -:  106:
        -:  107:           /*
        -:  108:           ** Update the reset variables
        -:  109:           */
        2:  110:           CFE_ES_ResetDataPtr->ResetVars.ES_CausedReset = TRUE;
        -:  111:
        -:  112:           /*
        -:  113:           ** Log the reset in the ER Log
        -:  114:           */
        2:  115:           CFE_ES_WriteToERLog(CFE_ES_LogEntryType_CORE, CFE_ES_PROCESSOR_RESET,
        -:  116:                                       CFE_ES_RESET_COMMAND,
        -:  117:                                       "PROCESSOR RESET called from CFE_ES_ResetCFE (Commanded).", NULL,0 );
        -:  118:           /*
        -:  119:           ** Call the BSP reset routine
        -:  120:           */
        2:  121:           CFE_PSP_Restart(CFE_PSP_RST_TYPE_PROCESSOR);
        -:  122:       
        -:  123:       } /* end if */
        -:  124:       
        -:  125:       /* 
        -:  126:       ** If the BSP routine is not implemented, 
        -:  127:       ** it will return. 
        -:  128:       */
        4:  129:       ReturnCode = CFE_ES_NOT_IMPLEMENTED;
        -:  130:    }
        3:  131:    else if ( ResetType == CFE_PSP_RST_TYPE_POWERON )
        -:  132:    {
        2:  133:       CFE_ES_WriteToSysLog("POWERON RESET called from CFE_ES_ResetCFE (Commanded).\n");
        -:  134:
        -:  135:       /*
        -:  136:       ** Log the reset in the ER Log. The log will be wiped out, but it's good to have
        -:  137:       ** the entry just in case something fails.
        -:  138:       */
        2:  139:       CFE_ES_WriteToERLog(CFE_ES_LogEntryType_CORE, CFE_PSP_RST_TYPE_POWERON,
        -:  140:                                       CFE_PSP_RST_SUBTYPE_RESET_COMMAND,
        -:  141:                                       "POWERON RESET called from CFE_ES_ResetCFE (Commanded).", NULL,0 );
        -:  142:
        -:  143:       /*
        -:  144:       ** Call the BSP reset routine
        -:  145:       */
        2:  146:       CFE_PSP_Restart(CFE_PSP_RST_TYPE_POWERON);
        -:  147:       
        -:  148:       /* 
        -:  149:       ** If the BSP routine is not implemented, 
        -:  150:       ** it will return. 
        -:  151:       */
        2:  152:       ReturnCode = CFE_ES_NOT_IMPLEMENTED;
        -:  153:    }
        -:  154:    else
        -:  155:    {
        1:  156:       CFE_ES_WriteToSysLog("ES ResetCFE: Invalid Reset Type: %d.\n",(int)ResetType);
        1:  157:       ReturnCode = CFE_ES_BAD_ARGUMENT;
        -:  158:    }
        -:  159:
        7:  160:    return(ReturnCode);
        -:  161:    
        -:  162:} /* End of CFE_ES_ResetCFE() */
        -:  163:
        -:  164:/*
        -:  165: * Function: CFE_ES_SetAppState
        -:  166: *
        -:  167: * Purpose: Internal ES function to set the state of an app.  This performs
        -:  168: *          any necessary internal housekeeping related to the state change,
        -:  169: *          and provides a single place to keep logic for state entry/exit.
        -:  170: *
        -:  171: * The typical progression of APP states:
        -:  172: *
        -:  173: * UNDEFINED -> EARLY_INIT -> LATE_INIT -> RUNNING -> WAITING
        -:  174: *
        -:  175: * State can go to "STOPPED" (the last state) from any state.  This is used for error conditions.
        -:  176: *
        -:  177: * NOTE: This is an ES internal function and must only be called when the ES global state is already locked.
        -:  178: *
        -:  179: */
       12:  180:void CFE_ES_SetAppState(uint32 AppID, uint32 TargetState)
        -:  181:{
       12:  182:    CFE_ES_AppState_t *AppState = &CFE_ES_Global.AppTable[AppID].StateRecord;
        -:  183:
       12:  184:    if (TargetState >= CFE_ES_AppState_MAX)
        -:  185:    {
        -:  186:        /* Caller error - invalid state */
    #####:  187:        return;
        -:  188:    }
        -:  189:
        -:  190:    /*
        -:  191:     * States should not move backward under normal circumstances.
        -:  192:     *
        -:  193:     * This relational comparison depends on the app states being defined in logical order
        -:  194:     * (they should be)
        -:  195:     */
       12:  196:    if (TargetState != CFE_ES_AppState_UNDEFINED && AppState->AppState >= TargetState)
        -:  197:    {
        -:  198:        /* Do nothing */
        3:  199:        return;
        -:  200:    }
        -:  201:
        9:  202:    AppState->AppState = TargetState;
        -:  203:}
        -:  204:
        -:  205:/*
        -:  206:** Function: CFE_ES_RestartApp
        -:  207:**
        -:  208:** Purpose:  Restart a single cFE App.
        -:  209:**
        -:  210:*/
        5:  211:int32 CFE_ES_RestartApp(uint32 AppID)
        -:  212:{
        5:  213:    int32 ReturnCode = CFE_SUCCESS;
        -:  214:
        5:  215:    if ( AppID < CFE_PLATFORM_ES_MAX_APPLICATIONS )
        -:  216:    {
        -:  217:
        4:  218:       CFE_ES_LockSharedData(__func__,__LINE__);
        -:  219:    
        -:  220:       /*
        -:  221:       ** Check to see if the App is an external cFE App.
        -:  222:       */
        4:  223:       if ( CFE_ES_Global.AppTable[AppID].Type == CFE_ES_AppType_CORE )
        -:  224:       {
        1:  225:          CFE_ES_SysLogWrite_Unsync ("CFE_ES_DeleteApp: Cannot Restart a CORE Application: %s.\n",
        -:  226:                             CFE_ES_Global.AppTable[AppID].StartParams.Name );
        1:  227:          ReturnCode = CFE_ES_ERR_APPID; 
        -:  228:       }
        3:  229:       else if ( CFE_ES_Global.AppTable[AppID].StateRecord.AppState != CFE_ES_AppState_RUNNING )
        -:  230:       {
        2:  231:          CFE_ES_SysLogWrite_Unsync ("CFE_ES_RestartApp: Cannot Restart Application %s, It is not running.\n",
        -:  232:                              CFE_ES_Global.AppTable[AppID].StartParams.Name);
        2:  233:          ReturnCode = CFE_ES_ERR_APPID; 
        -:  234:       }
        -:  235:       else
        -:  236:       {
        1:  237:          CFE_ES_SysLogWrite_Unsync("CFE_ES_RestartApp: Restart Application %s Initiated\n",
        -:  238:                             CFE_ES_Global.AppTable[AppID].StartParams.Name);
        1:  239:          CFE_ES_Global.AppTable[AppID].StateRecord.AppControlRequest = CFE_ES_RunStatus_SYS_RESTART;
        1:  240:          CFE_ES_SetAppState(AppID, CFE_ES_AppState_WAITING);
        1:  241:          CFE_ES_Global.AppTable[AppID].StateRecord.AppTimer = CFE_PLATFORM_ES_APP_KILL_TIMEOUT;
        -:  242:       }
        -:  243:    
        4:  244:       CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  245:    }
        -:  246:    else /* App ID is not valid */
        -:  247:    {
        1:  248:       ReturnCode = CFE_ES_ERR_APPID;
        -:  249:
        1:  250:       CFE_ES_WriteToSysLog("CFE_ES_RestartApp: Invalid Application ID received, RC = 0x%08X\n",
        -:  251:                            (unsigned int) ReturnCode);
        -:  252:
        -:  253:    } /* end if */
        -:  254:
        5:  255:    return(ReturnCode);
        -:  256:
        -:  257:} /* End of CFE_ES_RestartApp() */
        -:  258:
        -:  259:/*
        -:  260:** Function: CFE_ES_ReloadApp
        -:  261:**
        -:  262:** Purpose:  Reload a single cFE App.
        -:  263:**
        -:  264:*/
        3:  265:int32 CFE_ES_ReloadApp(uint32 AppID, const char *AppFileName)
        -:  266:{
        3:  267:    int32 ReturnCode = CFE_SUCCESS;
        -:  268:    os_fstat_t FileStatus;
        -:  269:
        3:  270:    CFE_ES_LockSharedData(__func__,__LINE__);
        -:  271:    
        -:  272:    /*
        -:  273:    ** Check to see if the App is an external cFE App.
        -:  274:    */
        3:  275:    if ( CFE_ES_Global.AppTable[AppID].Type == CFE_ES_AppType_CORE )
        -:  276:    {
        1:  277:       CFE_ES_SysLogWrite_Unsync ("CFE_ES_DeleteApp: Cannot Reload a CORE Application: %s.\n", 
        -:  278:       CFE_ES_Global.AppTable[AppID].StartParams.Name );
        1:  279:       ReturnCode = CFE_ES_ERR_APPID; 
        -:  280:    }
        2:  281:    else if ( CFE_ES_Global.AppTable[AppID].StateRecord.AppState != CFE_ES_AppState_RUNNING )
        -:  282:    {
        1:  283:       CFE_ES_SysLogWrite_Unsync ("CFE_ES_ReloadApp: Cannot Reload Application %s, It is not running.\n",
        -:  284:                              CFE_ES_Global.AppTable[AppID].StartParams.Name);
        1:  285:       ReturnCode = CFE_ES_ERR_APPID; 
        -:  286:    }    
        -:  287:    else
        -:  288:    {
        -:  289:       /*
        -:  290:       ** Check to see if the file exists
        -:  291:       */
        1:  292:       if (OS_stat(AppFileName, &FileStatus) == OS_SUCCESS)
        -:  293:       {
        1:  294:           CFE_ES_SysLogWrite_Unsync("CFE_ES_ReloadApp: Reload Application %s Initiated. New filename = %s\n", 
        -:  295:                                CFE_ES_Global.AppTable[AppID].StartParams.Name, AppFileName);
        1:  296:           strncpy((char *)CFE_ES_Global.AppTable[AppID].StartParams.FileName, AppFileName, OS_MAX_PATH_LEN);
        1:  297:           CFE_ES_Global.AppTable[AppID].StateRecord.AppControlRequest = CFE_ES_RunStatus_SYS_RELOAD;
        1:  298:           CFE_ES_SetAppState(AppID, CFE_ES_AppState_WAITING);
        1:  299:           CFE_ES_Global.AppTable[AppID].StateRecord.AppTimer = CFE_PLATFORM_ES_APP_KILL_TIMEOUT;
        -:  300:       }
        -:  301:       else
        -:  302:       {
    #####:  303:           CFE_ES_SysLogWrite_Unsync ("CFE_ES_ReloadApp: Cannot Reload Application %s, File %s does not exist.\n",
        -:  304:                                  CFE_ES_Global.AppTable[AppID].StartParams.Name,
        -:  305:                                  AppFileName);
    #####:  306:           ReturnCode = CFE_ES_FILE_IO_ERR;
        -:  307:       }
        -:  308:    }
        -:  309:    
        3:  310:    CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  311:        
        3:  312:    return(ReturnCode);
        -:  313:
        -:  314:} /* End of CFE_ES_ReloadApp() */
        -:  315:
        -:  316:/*
        -:  317:** Function: CFE_ES_DeleteApp
        -:  318:**
        -:  319:** Purpose:  Delete a cFE App.
        -:  320:**
        -:  321:*/
        3:  322:int32 CFE_ES_DeleteApp(uint32 AppID)
        -:  323:{
        3:  324:    int32 ReturnCode = CFE_SUCCESS;
        -:  325:
        3:  326:    CFE_ES_LockSharedData(__func__,__LINE__);
        -:  327:    
        -:  328:    /*
        -:  329:    ** Check to see if the App is an external cFE App.
        -:  330:    */
        3:  331:    if ( CFE_ES_Global.AppTable[AppID].Type == CFE_ES_AppType_CORE )
        -:  332:    {
        1:  333:       CFE_ES_SysLogWrite_Unsync ("CFE_ES_DeleteApp: Cannot Delete a CORE Application: %s.\n", 
        -:  334:       CFE_ES_Global.AppTable[AppID].StartParams.Name );
        1:  335:       ReturnCode = CFE_ES_ERR_APPID; 
        -:  336:    }
        2:  337:    else if ( CFE_ES_Global.AppTable[AppID].StateRecord.AppState != CFE_ES_AppState_RUNNING )
        -:  338:    {
        1:  339:       CFE_ES_SysLogWrite_Unsync ("CFE_ES_DeleteApp: Cannot Delete Application %s, It is not running.\n",
        -:  340:                              CFE_ES_Global.AppTable[AppID].StartParams.Name);
        1:  341:       ReturnCode = CFE_ES_ERR_APPID; 
        -:  342:    }
        -:  343:    else
        -:  344:    {
        1:  345:       CFE_ES_SysLogWrite_Unsync("CFE_ES_DeleteApp: Delete Application %s Initiated\n",
        -:  346:                             CFE_ES_Global.AppTable[AppID].StartParams.Name);    
        1:  347:       CFE_ES_Global.AppTable[AppID].StateRecord.AppControlRequest = CFE_ES_RunStatus_SYS_DELETE;
        1:  348:       CFE_ES_SetAppState(AppID, CFE_ES_AppState_WAITING);
        1:  349:       CFE_ES_Global.AppTable[AppID].StateRecord.AppTimer = CFE_PLATFORM_ES_APP_KILL_TIMEOUT;
        -:  350:    }
        -:  351:    
        3:  352:    CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  353:        
        3:  354:    return(ReturnCode);
        -:  355:
        -:  356:} /* End of CFE_ES_DeleteApp() */
        -:  357:
        -:  358:/*
        -:  359:** Function: CFE_ES_ExitApp
        -:  360:**
        -:  361:** Purpose:  Exit a cFE App.
        -:  362:**
        -:  363:*/
        5:  364:void CFE_ES_ExitApp(uint32 ExitStatus)
        -:  365:{
        -:  366:    int32   ReturnCode;
        -:  367:    uint32  AppID;
        -:  368:
        5:  369:    CFE_ES_LockSharedData(__func__,__LINE__);
        -:  370:
        5:  371:    ReturnCode = CFE_ES_GetAppIDInternal(&AppID);
        5:  372:    if ( ReturnCode == CFE_SUCCESS )
        -:  373:    {
        -:  374:       /*
        -:  375:       ** Check to see if the App is an external cFE App.
        -:  376:       */
        3:  377:       if ( CFE_ES_Global.AppTable[AppID].Type == CFE_ES_AppType_CORE )
        -:  378:       {
        -:  379:          /*
        -:  380:          ** A core app should only call this function with one of two ExitStatus codes.
        -:  381:          */
        3:  382:          if ( ExitStatus == CFE_ES_RunStatus_CORE_APP_INIT_ERROR )
        -:  383:          {
        1:  384:              CFE_ES_SysLogWrite_Unsync ("CFE_ES_ExitApp: CORE Application %s Had an Init Error.\n",
        -:  385:                                     CFE_ES_Global.AppTable[AppID].StartParams.Name );
        -:  386:                                     
        -:  387:              /*
        -:  388:              ** Unlock the ES Shared data before calling ResetCFE 
        -:  389:              */
        1:  390:              CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  391:              
        -:  392:              
        -:  393:              /*
        -:  394:              ** Do a Processor Reset the cFE
        -:  395:              */                                                                                                          
        1:  396:              ReturnCode = CFE_ES_ResetCFE(CFE_PSP_RST_TYPE_PROCESSOR);
        -:  397:
        -:  398:              /*
        -:  399:              ** The CFE_ES_ResetCFE function does not normally return,
        -:  400:              ** but it may return during unit testing. If it does,
        -:  401:              ** log the return code (even if it claims CFE_SUCCESS).
        -:  402:              */
        1:  403:              CFE_ES_WriteToSysLog("CFE_ES_ExitApp: CORE Application Init Error Processor Reset, RC = 0x%08X\n",
        -:  404:                                   (unsigned int) ReturnCode);
        -:  405:
        1:  406:              return;
        -:  407:              
        -:  408:          }
        2:  409:          else if ( ExitStatus == CFE_ES_RunStatus_CORE_APP_RUNTIME_ERROR )
        -:  410:          {
        1:  411:              CFE_ES_SysLogWrite_Unsync ("CFE_ES_ExitApp: CORE Application %s Had a Runtime Error.\n",
        -:  412:                                     CFE_ES_Global.AppTable[AppID].StartParams.Name );  
        -:  413:                                                                                             
        -:  414:              /*
        -:  415:              ** Unlock the ES Shared data before killing the main task
        -:  416:              */
        1:  417:              CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  418:                             
        -:  419:              /*
        -:  420:              ** Exit this task
        -:  421:              */
        1:  422:              OS_TaskExit();   
        -:  423:              
        -:  424:              /*
        -:  425:              ** Code will not return, except under unit test
        -:  426:              */
        1:  427:              return;
        -:  428:          }
        -:  429:          else 
        -:  430:          {
        1:  431:              CFE_ES_SysLogWrite_Unsync ("CFE_ES_ExitApp, Cannot Exit CORE Application %s\n",
        -:  432:                                    CFE_ES_Global.AppTable[AppID].StartParams.Name );         
        -:  433:          }
        -:  434:                    
        -:  435:       }
        -:  436:       else /* It is an external App */
        -:  437:       {
        -:  438:          
    #####:  439:          CFE_ES_SysLogWrite_Unsync ("Application %s called CFE_ES_ExitApp\n",
        -:  440:                                 CFE_ES_Global.AppTable[AppID].StartParams.Name);
    #####:  441:          CFE_ES_SetAppState(AppID, CFE_ES_AppState_STOPPED);
        -:  442:
        -:  443:          /*
        -:  444:          ** Unlock the ES Shared data before suspending the app 
        -:  445:          */
    #####:  446:          CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  447:
        -:  448:          /*
        -:  449:          ** Suspend the Application until ES kills it.
        -:  450:          ** It might be better to have a way of suspending the app in the OS
        -:  451:          */
        -:  452:          while(1)
        -:  453:          {
    #####:  454:             OS_TaskDelay(500);
    #####:  455:          }
        -:  456:
        -:  457:       } /* end if */
        -:  458:   
        -:  459:   } /* end if ReturnCode == CFE_SUCCESS */
        -:  460:
        3:  461:   CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  462:   
        -:  463:} /* End of CFE_ES_ExitApp() */
        -:  464:
        -:  465:/*
        -:  466:** Function: CFE_ES_RunLoop
        -:  467:**
        -:  468:** Purpose:  Check the Run Status of an Application.
        -:  469:**
        -:  470:*/
        7:  471:int32 CFE_ES_RunLoop(uint32 *RunStatus)
        -:  472:{
        -:  473:    int32  ReturnCode;
        -:  474:    uint32 AppID;
        -:  475:    uint32 TaskID;
        -:  476:    
        7:  477:    CFE_ES_LockSharedData(__func__,__LINE__);
        -:  478:
        -:  479:    /*
        -:  480:    ** Get App ID
        -:  481:    */
        7:  482:    ReturnCode = CFE_ES_GetAppIDInternal(&AppID);
        -:  483:
        7:  484:    if ( ReturnCode == CFE_SUCCESS )
        -:  485:    {
        -:  486:    
        -:  487:       /*
        -:  488:       ** Get the Task ID for the main task
        -:  489:       */
        6:  490:       OS_ConvertToArrayIndex(CFE_ES_Global.AppTable[AppID].TaskInfo.MainTaskId, &TaskID);
        -:  491:       
        -:  492:       /*
        -:  493:       ** Increment the execution counter for the main task
        -:  494:       */
        6:  495:       CFE_ES_Global.TaskTable[TaskID].ExecutionCounter++;
        -:  496:    
        -:  497:       /*
        -:  498:       ** Validate RunStatus
        -:  499:       */
       11:  500:       if ( *RunStatus == CFE_ES_RunStatus_APP_RUN || *RunStatus == CFE_ES_RunStatus_APP_EXIT || *RunStatus == CFE_ES_RunStatus_APP_ERROR )
        -:  501:       {  
        -:  502:          /*
        -:  503:          ** Look up the system control request
        -:  504:          */
        5:  505:          if ( *RunStatus == CFE_ES_RunStatus_APP_RUN )
        -:  506:          {            
        -:  507:             /* 
        -:  508:             ** App state must be RUNNING (no-op if already set to running)
        -:  509:             */
        3:  510:             CFE_ES_SetAppState(AppID, CFE_ES_AppState_RUNNING);
        -:  511:             
        3:  512:             if ( CFE_ES_Global.AppTable[AppID].StateRecord.AppControlRequest != CFE_ES_RunStatus_APP_RUN )
        -:  513:             { 
        -:  514:                 /*
        -:  515:                 ** We have an external request to stop
        -:  516:                 */
        1:  517:                 ReturnCode = FALSE;
        -:  518:                 
        -:  519:             }
        -:  520:             else
        -:  521:             {
        -:  522:                /*
        -:  523:                ** Everything is OK
        -:  524:                */
        2:  525:                ReturnCode = TRUE;
        -:  526:             }
        -:  527:          }
        -:  528:          else
        -:  529:          {
        -:  530:             /*
        -:  531:             ** Application wants to exit, so let it
        -:  532:             */
        2:  533:             CFE_ES_Global.AppTable[AppID].StateRecord.AppControlRequest = *RunStatus; 
        2:  534:             ReturnCode = FALSE;
        -:  535:          }
        -:  536:       }
        -:  537:       else 
        -:  538:       {
        -:  539:          /*
        -:  540:          ** Not a supported RunStatus code, the app will abort
        -:  541:          */
        1:  542:          CFE_ES_SysLogWrite_Unsync("CFE_ES_RunLoop Error: Invalid RunStatus:%d!\n",(int)(*RunStatus));
        1:  543:          CFE_ES_Global.AppTable[AppID].StateRecord.AppControlRequest = CFE_ES_RunStatus_APP_ERROR;
        1:  544:          ReturnCode = FALSE;
        -:  545:       
        -:  546:       } /* End if *RunStatus == CFE_ES_RunStatus_APP_RUN .. */
        -:  547:   
        -:  548:    }
        -:  549:    else
        -:  550:    {
        -:  551:       /*
        -:  552:       ** Cannot do anything without the AppID
        -:  553:       */
        1:  554:       CFE_ES_SysLogWrite_Unsync("CFE_ES_RunLoop Error: Cannot get AppID for the caller: RC = %08X\n",(unsigned int)ReturnCode);
        1:  555:       ReturnCode = FALSE;
        -:  556:         
        -:  557:    } /* end if ReturnCode == CFE_SUCCESS */
        -:  558:
        7:  559:    CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  560:
        7:  561:    return(ReturnCode);
        -:  562:
        -:  563:} /* End of CFE_ES_RunLoop() */
        -:  564:
        -:  565:/*
        -:  566:** Function: CFE_ES_WaitForSystemState
        -:  567:**
        -:  568:** Purpose:  Called by applications that need to ensure that all other apps are running
        -:  569:**           before completing their initialization process.
        -:  570:**
        -:  571:**           This will also mark the calling task itself as "ready"
        -:  572:**
        -:  573:*/
        8:  574:int32 CFE_ES_WaitForSystemState(uint32 MinSystemState, uint32 TimeOutMilliseconds)
        -:  575:{
        -:  576:    int32 Status;
        -:  577:    uint32 AppID;
        -:  578:    uint32 RequiredAppState;
        -:  579:    uint32 WaitTime;
        -:  580:    uint32 WaitRemaining;
        -:  581:
        -:  582:    /*
        -:  583:     * An application calling CFE_ES_WaitForStartupSync() is assumed to have
        -:  584:     * completed its own initialization up to the point it is waiting for.
        -:  585:     *
        -:  586:     * Determine the implicit app state based on the system state it is indicating
        -:  587:     */
        8:  588:    CFE_ES_LockSharedData(__func__,__LINE__);
        8:  589:    Status = CFE_ES_GetAppIDInternal(&AppID);
        8:  590:    if ( Status == CFE_SUCCESS )
        -:  591:    {
        6:  592:        RequiredAppState = CFE_ES_AppState_EARLY_INIT;
        -:  593:        /*
        -:  594:         * If a core app waits for anything above "CORE_READY" then it is assumed to be RUNNING
        -:  595:         *
        -:  596:         * External apps have additional finer-grained sync:
        -:  597:         *  - SYSTEM_STATE_APPS_INIT requires that all apps are at least up to LATE_INIT
        -:  598:         *  - SYSTEM_STATE_OPERATIONAL requires that all apps are RUNNING
        -:  599:         *  - SYSTEM_STATE_SHUTDOWN requires that all apps are STOPPED (in concept anyway)
        -:  600:         */
        6:  601:        if (CFE_ES_Global.AppTable[AppID].Type == CFE_ES_AppType_CORE)
        -:  602:        {
        2:  603:            if (MinSystemState >= CFE_ES_SystemState_CORE_READY)
        -:  604:            {
        2:  605:                RequiredAppState = CFE_ES_AppState_RUNNING;
        -:  606:            }
        -:  607:        }
        4:  608:        else if (MinSystemState >= CFE_ES_SystemState_SHUTDOWN)
        -:  609:        {
        1:  610:            RequiredAppState = CFE_ES_AppState_STOPPED;
        -:  611:        }
        3:  612:        else if (MinSystemState >= CFE_ES_SystemState_OPERATIONAL)
        -:  613:        {
        2:  614:            RequiredAppState = CFE_ES_AppState_RUNNING;
        -:  615:        }
        1:  616:        else if (MinSystemState >= CFE_ES_SystemState_APPS_INIT)
        -:  617:        {
        1:  618:            RequiredAppState = CFE_ES_AppState_LATE_INIT;
        -:  619:        }
        -:  620:
        -:  621:        /*
        -:  622:         * NOTE -- a call to "CFE_ES_WaitForSystemState()" implies that the calling app MUST also
        -:  623:         * be in the requisite state.  This is hooked into here to avoid needing to update all existing
        -:  624:         * apps to add an explicit state change call, but it makes sense because if this was not done an app could
        -:  625:         * be waiting for itself (which will always time out).
        -:  626:         */
        6:  627:        CFE_ES_SetAppState(AppID, RequiredAppState);
        -:  628:
        -:  629:    }
        8:  630:    CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  631:
        -:  632:    /*
        -:  633:     * Do the actual delay loop.
        -:  634:     *
        -:  635:     * This is only dependent on the main (startup) task updating the global variable
        -:  636:     * to be at least the state requested.
        -:  637:     */
        8:  638:    WaitRemaining = TimeOutMilliseconds;
       80:  639:    while (CFE_ES_Global.SystemState < MinSystemState)
        -:  640:    {
        -:  641:        /* TBD: Very Crude timing here, but not sure if it matters,
        -:  642:         * as this is only done during startup, not real work */
       69:  643:        if (WaitRemaining > CFE_PLATFORM_ES_STARTUP_SYNC_POLL_MSEC)
        -:  644:        {
       59:  645:            WaitTime = CFE_PLATFORM_ES_STARTUP_SYNC_POLL_MSEC;
        -:  646:        }
       10:  647:        else if (WaitRemaining > 0)
        -:  648:        {
        5:  649:            WaitTime = WaitRemaining;
        -:  650:        }
        -:  651:        else
        -:  652:        {
        5:  653:            Status = CFE_ES_OPERATION_TIMED_OUT;
        5:  654:            break;
        -:  655:        }
        -:  656:
       64:  657:        OS_TaskDelay(WaitTime);
       64:  658:        WaitRemaining -= WaitTime;
        -:  659:    }
        -:  660:
        8:  661:    return Status;
        -:  662:
        -:  663:} /* End of CFE_ES_WaitForSystemState() */
        -:  664:
        -:  665:/*
        -:  666:** Function: CFE_ES_WaitForStartupSync
        -:  667:**
        -:  668:** Purpose:  Called by applications that need to ensure that all other apps are running
        -:  669:**           before completing their initialization process.
        -:  670:**
        -:  671:**           This API is required for compatibility with existing applications.  It
        -:  672:**           is equivalent to calling CFE_ES_WaitForSystemState(CFE_ES_SystemState_OPERATIONAL)
        -:  673:**           for apps that don't require any finer-grained synchronization.
        -:  674:**
        -:  675:*/
        3:  676:void CFE_ES_WaitForStartupSync(uint32 TimeOutMilliseconds)
        -:  677:{
        3:  678:    CFE_ES_WaitForSystemState(CFE_ES_SystemState_OPERATIONAL, TimeOutMilliseconds);
        3:  679:}
        -:  680:
        -:  681:/*
        -:  682:** Function: CFE_ES_RegisterApp
        -:  683:**
        -:  684:** Purpose:  Register a new Application with the cFE. This
        -:  685:**           function must be called in a cFE app before
        -:  686:**           any other cFE function.
        -:  687:**
        -:  688:*/
       12:  689:int32 CFE_ES_RegisterApp(void)
        -:  690:{
       12:  691:   int32 Result = CFE_SUCCESS;
        -:  692:
       12:  693:   CFE_ES_LockSharedData(__func__,__LINE__);
        -:  694:
        -:  695:   /*
        -:  696:   ** Register the task 
        -:  697:   */
       12:  698:   Result = OS_TaskRegister();
        -:  699:
       12:  700:   if (Result == OS_SUCCESS)
        -:  701:   {
       10:  702:       Result = CFE_SUCCESS;
        -:  703:   }
        -:  704:   else
        -:  705:   {
        -:  706:       /* 
        -:  707:       ** Cannot create a syslog entry here because it requires the task to 
        -:  708:       ** be registered
        -:  709:       */
        2:  710:       Result = CFE_ES_ERR_APP_REGISTER;
        -:  711:   }
        -:  712:
        -:  713:   /*
        -:  714:   ** Set the default exception environment
        -:  715:   */
       12:  716:   CFE_PSP_SetDefaultExceptionEnvironment();
        -:  717:   
       12:  718:   CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  719:
       12:  720:   return(Result);
        -:  721:  
        -:  722:
        -:  723:} /* End of CFE_ES_RegisterApp() */
        -:  724:
        -:  725:/*
        -:  726:** Function: CFE_ES_GetAppIDByName
        -:  727:**
        -:  728:** Purpose:  Given a valid App Name, return the 
        -:  729:**           Application ID.
        -:  730:**
        -:  731:*/
       18:  732:int32 CFE_ES_GetAppIDByName(uint32 *AppIdPtr, const char *AppName)
        -:  733:{
       18:  734:   int32 Result = CFE_ES_ERR_APPNAME;
        -:  735:   uint32 i;
        -:  736:
       18:  737:   CFE_ES_LockSharedData(__func__,__LINE__);
        -:  738:
        -:  739:   /*
        -:  740:   ** Search the ES Application table for an app with a matching name.
        -:  741:   */
      282:  742:   for ( i = 0; i < CFE_PLATFORM_ES_MAX_APPLICATIONS; i++ )
        -:  743:   {
      274:  744:      if ( CFE_ES_Global.AppTable[i].RecordUsed == TRUE )
        -:  745:      {
       11:  746:         if ( strncmp(AppName, (char *)CFE_ES_Global.AppTable[i].StartParams.Name, OS_MAX_API_NAME) == 0 )
        -:  747:         {
       10:  748:            *AppIdPtr = i;
       10:  749:            Result = CFE_SUCCESS;
       10:  750:            break;
        -:  751:         }
        -:  752:      }
        -:  753:   } /* end for */
        -:  754:   
       18:  755:   CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  756:      
       18:  757:   return(Result);
        -:  758:
        -:  759:} /* End of CFE_ES_GetAppIDByName() */
        -:  760:
        -:  761:
        -:  762:/*
        -:  763:** Function: CFE_ES_GetAppID
        -:  764:**
        -:  765:** Purpose:  Return the Caller's cFE Application ID.
        -:  766:**
        -:  767:*/
       17:  768:int32 CFE_ES_GetAppID(uint32 *AppIdPtr)
        -:  769:{
        -:  770:   int32  Result;
        -:  771:
       17:  772:   CFE_ES_LockSharedData(__func__,__LINE__);
        -:  773:
       17:  774:   Result = CFE_ES_GetAppIDInternal(AppIdPtr);
        -:  775:
       17:  776:   CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  777:      
       17:  778:   return(Result);
        -:  779:
        -:  780:} /* End of CFE_ES_GetAppID() */
        -:  781:
        -:  782:/*
        -:  783:** Function: CFE_ES_GetAppName
        -:  784:**
        -:  785:** Purpose:  Given a valid AppID, return the 
        -:  786:**           Application name string.
        -:  787:**
        -:  788:*/
       19:  789:int32 CFE_ES_GetAppName(char *AppName, uint32 AppId, uint32 BufferLength)
        -:  790:{
        -:  791:   int32 Result;
        -:  792:
       19:  793:   CFE_ES_LockSharedData(__func__,__LINE__);
        -:  794:
       19:  795:   if ( AppId < CFE_PLATFORM_ES_MAX_APPLICATIONS )
        -:  796:   {
       18:  797:      if ( CFE_ES_Global.AppTable[AppId].RecordUsed == TRUE )
        -:  798:      {
       11:  799:         strncpy(AppName, (char *)CFE_ES_Global.AppTable[AppId].StartParams.Name, BufferLength);
       11:  800:         AppName[BufferLength - 1] = '\0';
       11:  801:         Result = CFE_SUCCESS;
        -:  802:      }
        -:  803:      else
        -:  804:      {
        7:  805:         Result = CFE_ES_ERR_APPID;
        -:  806:      }
        -:  807:   }
        -:  808:   else
        -:  809:   {
        1:  810:      Result = CFE_ES_ERR_APPID;
        -:  811:   }
        -:  812:   
       19:  813:   CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  814:
        -:  815:   /*
        -:  816:    * Appeasement for poorly-behaved callers:
        -:  817:    *
        -:  818:    * There is a fair amount of existing code that calls this function but
        -:  819:    * does not correctly check the return code.  Although these callers are
        -:  820:    * incorrect, this at least ensures that if the output buffer will be
        -:  821:    * appropriately null terminated (empty string) in the failure case.
        -:  822:    */
       19:  823:   if (Result != CFE_SUCCESS)
        -:  824:   {
        8:  825:       AppName[0] = 0;
        -:  826:   }
        -:  827:      
       19:  828:   return(Result);
        -:  829:
        -:  830:} /* End of CFE_ES_GetAppName() */
        -:  831:
        -:  832:
        -:  833:/*
        -:  834:** Function: CFE_ES_GetAppInfo
        -:  835:**
        -:  836:** Purpose:  Get Application Information given a specified App ID
        -:  837:**
        -:  838:*/
        5:  839:int32 CFE_ES_GetAppInfo(CFE_ES_AppInfo_t *AppInfo, uint32 AppId)
        -:  840:{
        5:  841:   int32  ReturnCode = CFE_SUCCESS;
        -:  842:
        5:  843:   if ( AppInfo != 0 )
        -:  844:   {
        4:  845:      if ( AppId < CFE_PLATFORM_ES_MAX_APPLICATIONS )
        -:  846:      {
        3:  847:         if ( CFE_ES_Global.AppTable[AppId].RecordUsed == TRUE )
        -:  848:         {
        2:  849:            CFE_ES_GetAppInfoInternal(AppId, AppInfo);
        2:  850:            ReturnCode = CFE_SUCCESS;
        -:  851:         }
        -:  852:         else
        -:  853:         {
        1:  854:            CFE_ES_WriteToSysLog("CFE_ES_GetAppInfo: App ID Not Active: %d\n",(int)AppId);
        1:  855:            ReturnCode = CFE_ES_ERR_APPID;
        -:  856:         }
        -:  857:      }
        -:  858:      else
        -:  859:      {
        1:  860:         CFE_ES_WriteToSysLog("CFE_ES_GetAppInfo: App ID Exceeds CFE_ES_APPLICATION_MAX: %d\n",(int)AppId);
        1:  861:         ReturnCode = CFE_ES_ERR_APPID;
        -:  862:      }
        -:  863:   }
        -:  864:   else
        -:  865:   {
        1:  866:      CFE_ES_WriteToSysLog("CFE_ES_GetAppInfo: Invalid Parameter ( Null Pointer )\n");
        1:  867:      ReturnCode = CFE_ES_ERR_BUFFER;
        -:  868:   }
        5:  869:   return(ReturnCode);
        -:  870:
        -:  871:} /* End of CFE_ES_GetAppInfo() */
        -:  872:
        -:  873:/*
        -:  874:** Function: CFE_ES_GetTaskInfo
        -:  875:**
        -:  876:** Purpose:  Get Task Information given a specified Task ID
        -:  877:**
        -:  878:*/
       11:  879:int32 CFE_ES_GetTaskInfo(CFE_ES_TaskInfo_t *TaskInfo, uint32 OSTaskId)
        -:  880:{
       11:  881:   int32  ReturnCode = CFE_SUCCESS;
        -:  882:   uint32 TaskId;
        -:  883:
       11:  884:   CFE_ES_LockSharedData(__func__,__LINE__);
        -:  885:
       12:  886:   if (OS_ConvertToArrayIndex(OSTaskId, &TaskId) != OS_SUCCESS || TaskId >= OS_MAX_TASKS)
        -:  887:   {
        1:  888:      CFE_ES_SysLogWrite_Unsync("CFE_ES_GetTaskInfo: Task ID Not Valid: %u\n",(unsigned int)OSTaskId);
        1:  889:      ReturnCode = CFE_ES_ERR_TASKID;
        -:  890:   }
       10:  891:   else if (  CFE_ES_Global.TaskTable[TaskId].RecordUsed == TRUE )
        -:  892:   {
        -:  893:
        -:  894:      /*
        -:  895:      ** Get the Application ID and Task Name
        -:  896:      */
        8:  897:      TaskInfo->AppId = CFE_ES_Global.TaskTable[TaskId].AppId;
        8:  898:      strncpy((char *)TaskInfo->TaskName,
        -:  899:              (char *)CFE_ES_Global.TaskTable[TaskId].TaskName,OS_MAX_API_NAME);
        8:  900:      TaskInfo->TaskName[OS_MAX_API_NAME - 1] = '\0';
        -:  901:
        -:  902:      /*
        -:  903:      ** Get the Application Name
        -:  904:      */
        8:  905:      if ( CFE_ES_Global.AppTable[TaskInfo->AppId].RecordUsed == TRUE )
        -:  906:      {
        4:  907:         strncpy((char *)TaskInfo->AppName,
        4:  908:                 (char *)CFE_ES_Global.AppTable[TaskInfo->AppId].StartParams.Name,
        -:  909:                 OS_MAX_API_NAME);
        4:  910:         TaskInfo->AppName[OS_MAX_API_NAME - 1] = '\0';
        -:  911:
        -:  912:         /*
        -:  913:         ** Store away the Task ID ( for the QueryAllTasks Cmd )
        -:  914:         */
        4:  915:         TaskInfo->TaskId = OSTaskId;
        -:  916:
        -:  917:
        -:  918:         /*
        -:  919:         ** Get the Execution counter for the task
        -:  920:         */
        4:  921:         TaskInfo->ExecutionCounter =  CFE_ES_Global.TaskTable[TaskId].ExecutionCounter;
        -:  922:
        4:  923:         ReturnCode = CFE_SUCCESS;
        -:  924:
        -:  925:      }
        -:  926:      else
        -:  927:      {
        4:  928:         CFE_ES_SysLogWrite_Unsync("CFE_ES_GetTaskInfo: Task ID:%u Parent App ID:%d not Active.\n",
        -:  929:                 (unsigned int)OSTaskId,(int)TaskInfo->AppId);
        4:  930:         ReturnCode = CFE_ES_ERR_TASKID;
        -:  931:      }
        -:  932:   }
        -:  933:   else
        -:  934:   {
        2:  935:      CFE_ES_SysLogWrite_Unsync("CFE_ES_GetTaskInfo: Task ID Not Active: %u\n",(unsigned int)OSTaskId);
        2:  936:      ReturnCode = CFE_ES_ERR_TASKID;
        -:  937:   }
        -:  938:   
       11:  939:   CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  940:
       11:  941:   return(ReturnCode);
        -:  942:
        -:  943:} /* End of CFE_ES_GetAppName() */
        -:  944:
        -:  945:
        -:  946:/*
        -:  947:** Function: CFE_ES_CreateChildTask
        -:  948:**
        -:  949:** Purpose:  Create a Child task for the Application.
        -:  950:**
        -:  951:*/
       11:  952:int32 CFE_ES_CreateChildTask(uint32 *TaskIdPtr,
        -:  953:                        const char   *TaskName,
        -:  954:                        CFE_ES_ChildTaskMainFuncPtr_t   FunctionPtr,
        -:  955:                        uint32 *StackPtr,
        -:  956:                        uint32  StackSize,
        -:  957:                        uint32  Priority,
        -:  958:                        uint32  Flags)
        -:  959:{
        -:  960:
        -:  961:   int32          Result;
       11:  962:   uint32         AppId= 0xFFFFFFFF;
        -:  963:   int32          ReturnCode;
        -:  964:   uint32         TaskId;
        -:  965:   uint32         ParentTaskId;
        -:  966:
        -:  967:   /*
        -:  968:   ** Validate some of the arguments
        -:  969:   */
       11:  970:   if ( TaskIdPtr == NULL )
        -:  971:   {
        2:  972:      if (TaskName == NULL)
        -:  973:      {
        1:  974:          CFE_ES_WriteToSysLog("CFE_ES_CreateChildTask: Task Id and Name Pointer Parameters are NULL.\n");
        1:  975:          ReturnCode = CFE_ES_BAD_ARGUMENT;
        -:  976:      }
        -:  977:      else
        -:  978:      {
        1:  979:          CFE_ES_WriteToSysLog("CFE_ES_CreateChildTask: Task Id Pointer Parameter is NULL for Task '%s'.\n",TaskName);
        1:  980:          ReturnCode = CFE_ES_BAD_ARGUMENT;
        -:  981:      }
        -:  982:   }
        9:  983:   else if ( TaskName == NULL )
        -:  984:   {
        1:  985:      CFE_ES_WriteToSysLog("CFE_ES_CreateChildTask: TaskName Parameter is NULL for Task ID %d.\n",(int)(*TaskIdPtr));
        1:  986:      ReturnCode = CFE_ES_BAD_ARGUMENT;
        -:  987:   }
        8:  988:   else if ( FunctionPtr == NULL )
        -:  989:   {
        1:  990:      CFE_ES_WriteToSysLog("CFE_ES_CreateChildTask: Function Pointer Parameter is NULL for Task '%s' (ID %d).\n",TaskName,(int)(*TaskIdPtr));
        1:  991:      ReturnCode = CFE_ES_BAD_ARGUMENT;
        -:  992:   }
        -:  993:   else 
        -:  994:   {
        -:  995:   
        7:  996:      CFE_ES_LockSharedData(__func__,__LINE__);
        -:  997:   
        -:  998:      /*
        -:  999:      ** Get the AppID of the calling Application
        -: 1000:      */
        7: 1001:      Result = CFE_ES_GetAppIDInternal(&AppId);
        7: 1002:      if (Result != CFE_SUCCESS)
        -: 1003:      {
        2: 1004:          CFE_ES_SysLogWrite_Unsync("CFE_ES_CreateChildTask: Error calling CFE_ES_GetAppID for Task '%s'. RC = 0x%08X\n",TaskName,(unsigned int)Result);
        2: 1005:          ReturnCode = Result;
        -: 1006:      }
        -: 1007:      else  /* else AppId is valid */
        -: 1008:      {
        -: 1009:         /*
        -: 1010:         ** First, Make sure the Calling Task is a cFE Main task.
        -: 1011:         ** TaskID must be the same as the Parent Task ID.
        -: 1012:         */
        5: 1013:         TaskId = OS_TaskGetId();
        5: 1014:         ParentTaskId = CFE_ES_Global.AppTable[AppId].TaskInfo.MainTaskId;
        5: 1015:         if ( TaskId == ParentTaskId )
        -: 1016:         {
        -: 1017:            /*
        -: 1018:            ** Truncate the priority if needed
        -: 1019:            */                          
        4: 1020:            if ( Priority >  255  )
        -: 1021:            {
        2: 1022:                Priority = 255;
        -: 1023:            }
        -: 1024:
        -: 1025:            /*
        -: 1026:            ** Step 2: Create the new task using the OS API call
        -: 1027:            */
        4: 1028:            Result = OS_TaskCreate(TaskIdPtr, TaskName, FunctionPtr, StackPtr,
        -: 1029:                                StackSize, Priority, OS_FP_ENABLED );
        -: 1030:
        -: 1031:            /*
        -: 1032:            ** Step 3: Record the task information in the task table
        -: 1033:            */
        4: 1034:            if ( Result == OS_SUCCESS )
        -: 1035:            {
        3: 1036:               OS_ConvertToArrayIndex(*TaskIdPtr, &TaskId);
        -: 1037:
        3: 1038:               CFE_ES_Global.TaskTable[TaskId].RecordUsed = TRUE;
        3: 1039:               CFE_ES_Global.TaskTable[TaskId].AppId = AppId;
        3: 1040:               CFE_ES_Global.TaskTable[TaskId].TaskId = *TaskIdPtr;
        3: 1041:               strncpy((char *)CFE_ES_Global.TaskTable[TaskId].TaskName,TaskName,OS_MAX_API_NAME);
        3: 1042:               CFE_ES_Global.TaskTable[TaskId].TaskName[OS_MAX_API_NAME - 1] = '\0';
        3: 1043:               CFE_ES_Global.RegisteredTasks++;
        -: 1044:
        -: 1045:               /*
        -: 1046:               ** Increment the "Registered" child task count for the App
        -: 1047:               */
        3: 1048:               CFE_ES_Global.AppTable[AppId].TaskInfo.NumOfChildTasks ++;
        -: 1049:
        3: 1050:               ReturnCode = CFE_SUCCESS;
        -: 1051:            }
        -: 1052:            else
        -: 1053:            {
        1: 1054:               CFE_ES_SysLogWrite_Unsync("CFE_ES_CreateChildTask: Error calling OS_TaskCreate for Task '%s' RC = 0x%08X\n",TaskName,(unsigned int)Result);
        1: 1055:               ReturnCode = CFE_ES_ERR_CHILD_TASK_CREATE;
        -: 1056:            }
        -: 1057:         } 
        -: 1058:         else
        -: 1059:         {
        1: 1060:            CFE_ES_SysLogWrite_Unsync("CFE_ES_CreateChildTask: Error: Cannot call from a Child Task (for Task '%s').\n",TaskName);
        1: 1061:            ReturnCode = CFE_ES_ERR_CHILD_TASK_CREATE;
        -: 1062:         
        -: 1063:         } /* end if Calling task is a main task */
        -: 1064:         
        -: 1065:      }/* end If AppID is valid */
        -: 1066:      
        7: 1067:      CFE_ES_UnlockSharedData(__func__,__LINE__);
        -: 1068:
        -: 1069:   } /* end if parameter checking */
        -: 1070:   
       11: 1071:   return(ReturnCode);
        -: 1072:
        -: 1073:} /* End of CFE_ES_CreateChildTask() */
        -: 1074:
        -: 1075:
        -: 1076:/*
        -: 1077:** Function: CFE_ES_RegisterChildTask
        -: 1078:**
        -: 1079:** Purpose:  Register a child task. This must be called by a Child Task before any
        -: 1080:**           other cFE calls.
        -: 1081:**
        -: 1082:*/
        6: 1083:int32 CFE_ES_RegisterChildTask(void)
        -: 1084:{
        -: 1085:   int32 Result;
        -: 1086:   int32 ReturnCode;
        -: 1087:
        6: 1088:   CFE_ES_LockSharedData(__func__,__LINE__);
        -: 1089:
        -: 1090:   /*
        -: 1091:   ** Register the task with the OS 
        -: 1092:   */
        6: 1093:   Result = OS_TaskRegister();
        -: 1094:
        6: 1095:   if (Result != OS_SUCCESS)
        -: 1096:   {
        -: 1097:       /* 
        -: 1098:       ** Cannot create a syslog entry here because it requires the task to 
        -: 1099:       ** be registered
        -: 1100:       */
        1: 1101:       ReturnCode = CFE_ES_ERR_CHILD_TASK_REGISTER;
        -: 1102:   }
        -: 1103:   else
        -: 1104:   { 
        5: 1105:       ReturnCode = CFE_SUCCESS;
        -: 1106:   }
        -: 1107:   
        -: 1108:   /*
        -: 1109:   ** Set the default exception environment
        -: 1110:   */
        6: 1111:   CFE_PSP_SetDefaultExceptionEnvironment();
        -: 1112:
        6: 1113:   CFE_ES_UnlockSharedData(__func__,__LINE__);
        -: 1114:
        6: 1115:   return(ReturnCode);
        -: 1116:
        -: 1117:} /* End of CFE_ES_RegisterChildTask() */
        -: 1118:
        -: 1119:/*
        -: 1120:** Function: CFE_ES_IncrementTaskCounter
        -: 1121:**
        -: 1122:** Purpose:  Increment the Child Task Execution Counter.
        -: 1123:**
        -: 1124:*/
        3: 1125:void CFE_ES_IncrementTaskCounter(void)
        -: 1126:{
        -: 1127:   uint32 TaskId;
        -: 1128:
        3: 1129:   if (OS_ConvertToArrayIndex(OS_TaskGetId(), &TaskId) == OS_SUCCESS)
        -: 1130:   {
        3: 1131:      CFE_ES_Global.TaskTable[TaskId].ExecutionCounter++;
        -: 1132:   }
        -: 1133:   
        3: 1134:} /* End of CFE_ES_ExitChildTask() */
        -: 1135:
        -: 1136:
        -: 1137:
        -: 1138:/*
        -: 1139:** Function: CFE_ES_DeleteChildTask
        -: 1140:**
        -: 1141:** Purpose:  Remove a Child Task from the cFE system.
        -: 1142:**
        -: 1143:*/
        5: 1144:int32 CFE_ES_DeleteChildTask(uint32 OSTaskId)
        -: 1145:{
        -: 1146:    uint32  i;
        -: 1147:    uint32  TaskId;
        5: 1148:    uint32  TaskIsMain = FALSE;
        5: 1149:    int32   ReturnCode = CFE_SUCCESS;
        -: 1150:    int32   OSReturnCode;
        -: 1151:
        -: 1152:
        -: 1153:    /*
        -: 1154:    ** Make sure the task ID is within range
        -: 1155:    */
        5: 1156:    if (OS_ConvertToArrayIndex(OSTaskId, &TaskId) == OS_SUCCESS)
        -: 1157:    {
        5: 1158:       CFE_ES_LockSharedData(__func__,__LINE__);
        -: 1159:    
        -: 1160:       /*
        -: 1161:       ** Make sure the task is active/valid
        -: 1162:       */
        8: 1163:       if (TaskId < OS_MAX_TASKS && CFE_ES_Global.TaskTable[TaskId].RecordUsed == TRUE )
        -: 1164:       {
        -: 1165:          /*
        -: 1166:          ** Search for this task ID in the ES App Table to make sure
        -: 1167:          ** it is not a cFE App Main Task
        -: 1168:          */
        3: 1169:          TaskIsMain = FALSE;
       68: 1170:          for ( i = 0; i < CFE_PLATFORM_ES_MAX_APPLICATIONS; i++ )
        -: 1171:          {
       66: 1172:             if ( CFE_ES_Global.AppTable[i].RecordUsed == TRUE )
        -: 1173:             {
        3: 1174:                if ( CFE_ES_Global.AppTable[i].TaskInfo.MainTaskId == OSTaskId )
        -: 1175:                {
        -: 1176:                   /*
        -: 1177:                   ** Error, the task Id is an App Main Task ID
        -: 1178:                   */
        1: 1179:                   TaskIsMain = TRUE;
        1: 1180:                   break; 
        -: 1181:                } /* end if */
        -: 1182:             } /* end if */
        -: 1183:          } /* end for */
        -: 1184:          
        3: 1185:          if ( TaskIsMain == FALSE )
        -: 1186:          {
        -: 1187:             /*
        -: 1188:             ** Can delete the Task
        -: 1189:             */
        2: 1190:             OSReturnCode = OS_TaskDelete(OSTaskId);
        2: 1191:             if ( OSReturnCode == OS_SUCCESS )
        -: 1192:             {
        -: 1193:                /*
        -: 1194:                ** Invalidate the task table entry
        -: 1195:                */
        1: 1196:                CFE_ES_Global.TaskTable[TaskId].RecordUsed = FALSE;
        1: 1197:                CFE_ES_Global.RegisteredTasks--;
        -: 1198:
        -: 1199:                /*
        -: 1200:                ** Report the task delete
        -: 1201:                */
        1: 1202:                CFE_ES_SysLogWrite_Unsync("CFE_ES_DeleteChildTask Task %u Deleted\n",(unsigned int)OSTaskId );
        1: 1203:                ReturnCode = CFE_SUCCESS;
        -: 1204:             }
        -: 1205:             else
        -: 1206:             {
        1: 1207:                CFE_ES_SysLogWrite_Unsync("CFE_ES_DeleteChildTask Error: Error Calling OS_TaskDelete: Task %u, RC = 0x%08X\n",
        -: 1208:                        (unsigned int)OSTaskId, (unsigned int)OSReturnCode);
        1: 1209:                ReturnCode = CFE_ES_ERR_CHILD_TASK_DELETE;
        -: 1210:             }
        -: 1211:          }
        -: 1212:          else
        -: 1213:          {
        -: 1214:             /*
        -: 1215:             ** Error: The task is a cFE Application Main task
        -: 1216:             */
        1: 1217:             CFE_ES_SysLogWrite_Unsync("CFE_ES_DeleteChildTask Error: Task %u is a cFE Main Task.\n",(unsigned int)OSTaskId );
        1: 1218:             ReturnCode = CFE_ES_ERR_CHILD_TASK_DELETE_MAIN_TASK;
        -: 1219:          } /* end if TaskMain == FALSE */
        -: 1220:       }
        -: 1221:       else
        -: 1222:       {
        -: 1223:          /*
        -: 1224:          ** Task ID is not in use, so it is invalid
        -: 1225:          */
        2: 1226:          CFE_ES_SysLogWrite_Unsync("CFE_ES_DeleteChildTask Error: Task ID is not active: %u\n",(unsigned int)OSTaskId );
        2: 1227:          ReturnCode = CFE_ES_ERR_TASKID;
        -: 1228:   
        -: 1229:       } /* end if */
        -: 1230:       
        5: 1231:       CFE_ES_UnlockSharedData(__func__,__LINE__);
        -: 1232:   
        -: 1233:    }
        -: 1234:    else
        -: 1235:    {
        -: 1236:       /*
        -: 1237:       ** Task ID is invalid ( too large )
        -: 1238:       */
    #####: 1239:       CFE_ES_WriteToSysLog("CFE_ES_DeleteChildTask Error: Invalid Task ID: %u\n",(unsigned int)OSTaskId );
    #####: 1240:       ReturnCode = CFE_ES_ERR_TASKID;
        -: 1241:       
        -: 1242:    }
        5: 1243:    return(ReturnCode);
        -: 1244:
        -: 1245:} /* End of CFE_ES_DeleteTask() */
        -: 1246:
        -: 1247:/*
        -: 1248:** Function: CFE_ES_ExitChildTask
        -: 1249:**
        -: 1250:** Purpose:  Stop execution of a child task.
        -: 1251:**
        -: 1252:*/
        7: 1253:void CFE_ES_ExitChildTask(void)
        -: 1254:{
        -: 1255:   uint32 TaskId;
        -: 1256:   uint32 ParentTaskId;
        -: 1257:   uint32 AppId; 
        -: 1258:   uint32 ReturnCode;
        -: 1259:
        7: 1260:   CFE_ES_LockSharedData(__func__,__LINE__);
        -: 1261:
        -: 1262:   /*
        -: 1263:   ** Check to see if this is being called from a cFE Application's 
        -: 1264:   ** main task.
        -: 1265:   */
        7: 1266:   TaskId = OS_TaskGetId();
        -: 1267:   
        7: 1268:   ReturnCode = CFE_ES_GetAppIDInternal(&AppId);
        7: 1269:   if ( ReturnCode == CFE_SUCCESS )
        -: 1270:   {
        2: 1271:      ParentTaskId = CFE_ES_Global.AppTable[AppId].TaskInfo.MainTaskId;
        2: 1272:      if ( TaskId != ParentTaskId )
        -: 1273:      {
        1: 1274:         if (OS_ConvertToArrayIndex(TaskId, &TaskId) == OS_SUCCESS)
        -: 1275:         {
        -: 1276:            /*
        -: 1277:            ** Invalidate the task table entry
        -: 1278:            */
        1: 1279:            CFE_ES_Global.TaskTable[TaskId].RecordUsed = FALSE;
        1: 1280:            CFE_ES_Global.RegisteredTasks--;
        -: 1281:
        -: 1282:
        1: 1283:            CFE_ES_UnlockSharedData(__func__,__LINE__);
        -: 1284:
        -: 1285:
        -: 1286:            /*
        -: 1287:            ** Call the OS AL routine
        -: 1288:            */
        1: 1289:            OS_TaskExit();
        -: 1290:            /*
        -: 1291:            ** Does not return from OS_TaskExit, except under unit test
        -: 1292:            */
        1: 1293:            return;
        -: 1294:         }
        -: 1295:         
        -: 1296:      }
        -: 1297:      else
        -: 1298:      {
        1: 1299:         CFE_ES_SysLogWrite_Unsync("CFE_ES_ExitChildTask Error: Cannot Call from a cFE App Main Task. ID = %d\n",(int)TaskId );
        -: 1300:      }
        -: 1301:   }
        -: 1302:   else
        -: 1303:   {   
        5: 1304:      CFE_ES_SysLogWrite_Unsync("CFE_ES_ExitChildTask Error Calling CFE_ES_GetAppID. Task ID = %d, RC = 0x%08X\n",
        -: 1305:              (int)TaskId, (unsigned int)ReturnCode );
        -: 1306:   } /* end if GetAppId */
        -: 1307:
        6: 1308:   CFE_ES_UnlockSharedData(__func__,__LINE__);
        -: 1309:   
        -: 1310:} /* End of CFE_ES_ExitChildTask() */
        -: 1311:
        -: 1312:
        -: 1313:/*
        -: 1314:** Function: CFE_ES_WriteToSysLog
        -: 1315:**
        -: 1316:** Purpose:  Add a time stamped message to the cFE ES System Log.
        -: 1317:**
        -: 1318:*/
      330: 1319:int32 CFE_ES_WriteToSysLog(const char *SpecStringPtr, ...)
        -: 1320:{
        -: 1321:    char          TmpString[CFE_ES_MAX_SYSLOG_MSG_SIZE];
        -: 1322:    int32         ReturnCode;
        -: 1323:    va_list       ArgPtr;
        -: 1324:
      330: 1325:    va_start(ArgPtr, SpecStringPtr);
      330: 1326:    CFE_ES_SysLog_vsnprintf(TmpString, sizeof(TmpString), SpecStringPtr, ArgPtr);
      330: 1327:    va_end(ArgPtr);
        -: 1328:
        -: 1329:    /*
        -: 1330:     * Append to the syslog buffer, which must be done while locked.
        -: 1331:     * Only one thread can actively write into the buffer at time.
        -: 1332:     */
      330: 1333:    CFE_ES_LockSharedData(__func__, __LINE__);
      330: 1334:    ReturnCode = CFE_ES_SysLogAppend_Unsync(TmpString);
      330: 1335:    CFE_ES_UnlockSharedData(__func__, __LINE__);
        -: 1336:
        -: 1337:    /* Output the entry to the console */
      330: 1338:    OS_printf("%s",TmpString);
        -: 1339:
      330: 1340:    return(ReturnCode);
        -: 1341:
        -: 1342:} /* End of CFE_ES_WriteToSysLog() */
        -: 1343:
        -: 1344:
        -: 1345:/*
        -: 1346:** Function: CFE_ES_CalculateCRC
        -: 1347:**
        -: 1348:** Purpose:  Perform a CRC calculation on a range of memory.
        -: 1349:**
        -: 1350:*/
       14: 1351:uint32 CFE_ES_CalculateCRC(const void *DataPtr, uint32 DataLength, uint32 InputCRC, uint32 TypeCRC)
        -: 1352:{
        -: 1353:    uint32  i;
        -: 1354:    int16  Index;
       14: 1355:    int16  Crc = 0;
        -: 1356:    const uint8 *BufPtr;
        -: 1357:    uint8  ByteValue;
        -: 1358:
        -: 1359:    static const uint16 CrcTable[256]=
        -: 1360:    {
        -: 1361:
        -: 1362:		    0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
        -: 1363:		    0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
        -: 1364:		    0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,
        -: 1365:		    0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
        -: 1366:		    0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,
        -: 1367:		    0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
        -: 1368:		    0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,
        -: 1369:		    0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
        -: 1370:		    0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,
        -: 1371:		    0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
        -: 1372:		    0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,
        -: 1373:		    0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
        -: 1374:		    0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
        -: 1375:		    0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
        -: 1376:		    0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,
        -: 1377:		    0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
        -: 1378:		    0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
        -: 1379:		    0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
        -: 1380:		    0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
        -: 1381:		    0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
        -: 1382:		    0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,
        -: 1383:		    0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
        -: 1384:		    0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,
        -: 1385:		    0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
        -: 1386:		    0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,
        -: 1387:		    0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
        -: 1388:		    0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,
        -: 1389:		    0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
        -: 1390:		    0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,
        -: 1391:		    0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
        -: 1392:		    0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
        -: 1393:		    0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
        -: 1394:
        -: 1395:    };
        -: 1396:
       14: 1397:    switch(TypeCRC)
        -: 1398:    {
        -: 1399:      case CFE_MISSION_ES_CRC_32:
        1: 1400:           CFE_ES_WriteToSysLog("CFE ES Calculate CRC32 not Implemented\n");
        1: 1401:           break;
        -: 1402:
        -: 1403:      case CFE_MISSION_ES_CRC_16:
       11: 1404:           Crc    =  (int16 )( 0xFFFF & InputCRC );
       11: 1405:           BufPtr = (const uint8 *)DataPtr;
        -: 1406:
     2459: 1407:           for ( i = 0 ; i < DataLength ; i++,  BufPtr++)
        -: 1408:           {
     2448: 1409:              if (CFE_PSP_MemRead8((cpuaddr)BufPtr, &ByteValue) != CFE_PSP_SUCCESS)
        -: 1410:              {
     1612: 1411:                 ByteValue = 0;
        -: 1412:              }
     2448: 1413:              Index = ( ( Crc ^ ByteValue) & 0x00FF);
     2448: 1414:              Crc = ( (Crc >> 8 ) & 0x00FF) ^ CrcTable[Index];
        -: 1415:           }
       11: 1416:           break;
        -: 1417:
        -: 1418:      case CFE_MISSION_ES_CRC_8:
        1: 1419:           CFE_ES_WriteToSysLog("CFE ES Calculate CRC8 not Implemented\n");
        -: 1420:           break;
        -: 1421:
        -: 1422:      default:
        -: 1423:           break;
        -: 1424:    }
       14: 1425:    return(Crc);
        -: 1426:
        -: 1427:} /* End of CFE_ES_CalculateCRC() */
        -: 1428:
        -: 1429:
        -: 1430:/*
        -: 1431:** Function: CFE_ES_RegisterCDS
        -: 1432:**
        -: 1433:** Purpose:  Allocate a data block for a Critical Data Store.
        -: 1434:**
        -: 1435:*/
       12: 1436:int32 CFE_ES_RegisterCDS(CFE_ES_CDSHandle_t *CDSHandlePtr, int32 BlockSize, const char *Name)
        -: 1437:{
       12: 1438:    int32   Status = CFE_SUCCESS;
       12: 1439:    size_t  NameLen = 0;
       12: 1440:    uint32  ThisAppId = 0;
        -: 1441:    
       12: 1442:    char    AppName[OS_MAX_API_NAME] = {"UNKNOWN"};
       12: 1443:    char    CDSName[CFE_ES_CDS_MAX_FULL_NAME_LEN] = {""};
        -: 1444:
        -: 1445:    /* Check to make sure calling application is legit */
       12: 1446:    Status = CFE_ES_CDS_ValidateAppID(&ThisAppId);
        -: 1447:    
       12: 1448:    if ( Status != CFE_SUCCESS )  /* Application ID was invalid */
        -: 1449:    {
        1: 1450:         CFE_ES_WriteToSysLog("CFE_CDS:Register-Bad AppId(%d)\n", (int)ThisAppId);
        -: 1451:    }
       11: 1452:    else if (CFE_ES_Global.CDSVars.MemPoolSize == 0)
        -: 1453:    {
        1: 1454:        CFE_ES_WriteToSysLog("CFE_CDS:Register-CDS not available\n");
        1: 1455:        Status = CFE_ES_NOT_IMPLEMENTED;
        -: 1456:    }
        -: 1457:    else
        -: 1458:    {
        -: 1459:        /* Assume we can't make a CDS and return a bad handle for now */
       10: 1460:        *CDSHandlePtr = CFE_ES_CDS_BAD_HANDLE;
        -: 1461:
        -: 1462:        /* Make sure specified CDS name is not too long or too short */
       10: 1463:        NameLen = strlen(Name);
       12: 1464:        if ((NameLen > CFE_MISSION_ES_CDS_MAX_NAME_LENGTH) || (NameLen == 0))
        -: 1465:        {
        2: 1466:           Status = CFE_ES_CDS_INVALID_NAME;
        -: 1467:
        -: 1468:           /* Perform a buffer overrun safe copy of name for debug log message */
        -: 1469:
        2: 1470:           strncpy(CDSName, Name, CFE_MISSION_ES_CDS_MAX_NAME_LENGTH);
        2: 1471:           CDSName[CFE_MISSION_ES_CDS_MAX_NAME_LENGTH-1] = '\0';
        2: 1472:           CFE_ES_WriteToSysLog("CFE_CDS:Register-CDS Name (%s) is too long\n", CDSName);
        -: 1473:        }
        -: 1474:        else
        -: 1475:        {
        -: 1476:           /* Modify specified name to be processor specific name */
        -: 1477:           /* of the form "AppName.Name"                          */
        8: 1478:           CFE_ES_FormCDSName(CDSName, Name, ThisAppId);
        -: 1479:
        -: 1480:           /* Make sure the specified size is acceptable */
        8: 1481:           if (BlockSize == 0)
        -: 1482:           {
        1: 1483:              Status = CFE_ES_CDS_INVALID_SIZE;
        1: 1484:              CFE_ES_WriteToSysLog("CFE_CDS:Register-CDS %s has size of zero\n", Name);
        -: 1485:           }
        -: 1486:           else
        -: 1487:           {
        -: 1488:              /* Create CDS and designate it as NOT being a Critical Table */
        7: 1489:              Status = CFE_ES_RegisterCDSEx(CDSHandlePtr, BlockSize, CDSName, FALSE);
        -: 1490:           }
        -: 1491:        }
        -: 1492:    }
        -: 1493:
        -: 1494:    /* On Error conditions, notify ground of screw up */
       12: 1495:    if (Status < 0)
        -: 1496:    {
        -: 1497:        /* Translate AppID of caller into App Name */
        8: 1498:        CFE_ES_GetAppName(AppName, ThisAppId, OS_MAX_API_NAME);
        -: 1499:
        8: 1500:        CFE_EVS_SendEventWithAppID(CFE_ES_CDS_REGISTER_ERR_EID,
        -: 1501:                                   CFE_EVS_EventType_ERROR,
        -: 1502:                                   ThisAppId,
        -: 1503:                                   "%s Failed to Register CDS '%s', Status=0x%08X",
        -: 1504:                                   AppName, Name, (unsigned int)Status);
        -: 1505:    }
        -: 1506:    
       12: 1507:    return Status;
        -: 1508:} /* End of CFE_ES_RegisterCDS */
        -: 1509:
        -: 1510:/*
        -: 1511:** Function: CFE_ES_CopyToCDS
        -: 1512:**
        -: 1513:** Purpose:  Copies a data block to a Critical Data Store.
        -: 1514:**
        -: 1515:*/
        1: 1516:int32 CFE_ES_CopyToCDS(CFE_ES_CDSHandle_t Handle, void *DataToCopy)
        -: 1517:{
        1: 1518:    int32 Status = CFE_SUCCESS;
        -: 1519:    
        1: 1520:    Status = CFE_ES_CDSBlockWrite(CFE_ES_Global.CDSVars.Registry[Handle].MemHandle, DataToCopy);
        -: 1521:    
        1: 1522:    return Status;
        -: 1523:} /* End of CFE_ES_CopyToCDS() */
        -: 1524:
        -: 1525:/*
        -: 1526:** Function: CFE_ES_RestoreFromCDS
        -: 1527:**
        -: 1528:** Purpose:  Restores a data block from a Critical Data Store.
        -: 1529:**
        -: 1530:*/
        1: 1531:int32 CFE_ES_RestoreFromCDS(void *RestoreToMemory, CFE_ES_CDSHandle_t Handle)
        -: 1532:{
        1: 1533:    int32 Status = CFE_SUCCESS;
        -: 1534:    
        1: 1535:    Status = CFE_ES_CDSBlockRead(RestoreToMemory, CFE_ES_Global.CDSVars.Registry[Handle].MemHandle);
        -: 1536:    
        1: 1537:    return Status;
        -: 1538:} /* End of CFE_ES_RestoreFromCDS() */
        -: 1539:
        -: 1540:/* end of file */
        -: 1541:
        -: 1542:
       13: 1543:int32 CFE_ES_RegisterGenCounter(uint32 *CounterIdPtr, const char *CounterName)
        -: 1544:{
       13: 1545:   int32 ReturnCode = CFE_ES_BAD_ARGUMENT;
        -: 1546:   uint32 CheckPtr;
        -: 1547:   int32 Status;
        -: 1548:   uint32 i;
        -: 1549:
       13: 1550:   Status = CFE_ES_GetGenCounterIDByName(&CheckPtr, CounterName);
        -: 1551:
       13: 1552:   if ((CounterIdPtr != NULL) && (CounterName != NULL) && (Status != CFE_SUCCESS))
        -: 1553:   {
       50: 1554:      for ( i = 0; i < CFE_PLATFORM_ES_MAX_GEN_COUNTERS; i++ )
        -: 1555:      {
       49: 1556:         if ( CFE_ES_Global.CounterTable[i].RecordUsed == FALSE )
        -: 1557:         {
        9: 1558:            strncpy((char *)CFE_ES_Global.CounterTable[i].CounterName,CounterName,OS_MAX_API_NAME);
        -: 1559:
        9: 1560:            CFE_ES_Global.CounterTable[i].RecordUsed = TRUE;
        9: 1561:            CFE_ES_Global.CounterTable[i].Counter = 0;
        9: 1562:            *CounterIdPtr = i;
        9: 1563:            break;
        -: 1564:         }
        -: 1565:      }
       10: 1566:      if (i < CFE_PLATFORM_ES_MAX_GEN_COUNTERS)
        -: 1567:      {
        9: 1568:         ReturnCode = CFE_SUCCESS;
        -: 1569:      }
        -: 1570:   }
        -: 1571:
       13: 1572:   return ReturnCode;
        -: 1573:
        -: 1574:}
        -: 1575:
        -: 1576:/*
        -: 1577:** Function: CFE_ES_DeleteGenCounter
        -: 1578:**
        -: 1579:** Purpose:  Delete a Generic Counter.
        -: 1580:**
        -: 1581:*/
        2: 1582:int32 CFE_ES_DeleteGenCounter(uint32 CounterId)
        -: 1583:{
        -: 1584:
        2: 1585:   int32 Status = CFE_ES_BAD_ARGUMENT;
        -: 1586:
        2: 1587:   if(CounterId < CFE_PLATFORM_ES_MAX_GEN_COUNTERS) 
        -: 1588:   {
        1: 1589:      CFE_ES_Global.CounterTable[CounterId].RecordUsed = FALSE;
        1: 1590:      CFE_ES_Global.CounterTable[CounterId].Counter = 0;
        1: 1591:      Status = CFE_SUCCESS;
        -: 1592:   }
        -: 1593:
        2: 1594:   return Status;
        -: 1595:
        -: 1596:} /* End of CFE_ES_DeleteGenCounter() */
        -: 1597:
        -: 1598:/*
        -: 1599:** Function: CFE_ES_IncrementGenCounter
        -: 1600:**
        -: 1601:** Purpose:  Increment a Generic Counter.
        -: 1602:**
        -: 1603:*/
        3: 1604:int32 CFE_ES_IncrementGenCounter(uint32 CounterId)
        -: 1605:{
        3: 1606:   int32 Status = CFE_ES_BAD_ARGUMENT;
        -: 1607:
        5: 1608:   if((CounterId < CFE_PLATFORM_ES_MAX_GEN_COUNTERS) &&
        2: 1609:      (CFE_ES_Global.CounterTable[CounterId].RecordUsed == TRUE))
        -: 1610:   {
        1: 1611:      CFE_ES_Global.CounterTable[CounterId].Counter++;
        1: 1612:      Status = CFE_SUCCESS;
        -: 1613:   }
        3: 1614:   return Status;
        -: 1615:   
        -: 1616:} /* End of CFE_ES_IncrementGenCounter() */
        -: 1617:
        -: 1618:/*
        -: 1619:** Function: CFE_ES_SetGenCount
        -: 1620:**
        -: 1621:** Purpose:  Sets a Generic Counter's count.
        -: 1622:**
        -: 1623:*/
        3: 1624:int32 CFE_ES_SetGenCount(uint32 CounterId, uint32 Count)
        -: 1625:{
        3: 1626:   int32 Status = CFE_ES_BAD_ARGUMENT;
        -: 1627:
        5: 1628:   if((CounterId < CFE_PLATFORM_ES_MAX_GEN_COUNTERS) &&
        2: 1629:      (CFE_ES_Global.CounterTable[CounterId].RecordUsed == TRUE))
        -: 1630:   {
        1: 1631:      CFE_ES_Global.CounterTable[CounterId].Counter = Count;
        1: 1632:      Status = CFE_SUCCESS;
        -: 1633:   }
        3: 1634:   return Status;
        -: 1635:} /* End of CFE_ES_SetGenCount() */
        -: 1636:
        -: 1637:/*
        -: 1638:** Function: CFE_ES_GetGenCount
        -: 1639:**
        -: 1640:** Purpose:  Gets the value of a Generic Counter.
        -: 1641:**
        -: 1642:*/
        5: 1643:int32 CFE_ES_GetGenCount(uint32 CounterId, uint32 *Count)
        -: 1644:{
        5: 1645:   int32 Status = CFE_ES_BAD_ARGUMENT;
        -: 1646:
        9: 1647:   if((CounterId < CFE_PLATFORM_ES_MAX_GEN_COUNTERS) &&
        4: 1648:      (CFE_ES_Global.CounterTable[CounterId].RecordUsed == TRUE) &&
        -: 1649:      (Count != NULL ))
        -: 1650:   {
        2: 1651:      *Count = CFE_ES_Global.CounterTable[CounterId].Counter;
        2: 1652:      Status = CFE_SUCCESS;
        -: 1653:   }
        5: 1654:   return Status;
        -: 1655:} /* End of CFE_ES_GetGenCount() */
        -: 1656:
       16: 1657:int32 CFE_ES_GetGenCounterIDByName(uint32 *CounterIdPtr, const char *CounterName)
        -: 1658:{
        -: 1659:
       16: 1660:   int32 Result = CFE_ES_BAD_ARGUMENT;
        -: 1661:   uint32   i;
        -: 1662:
        -: 1663:   /*
        -: 1664:   ** Search the ES Generic Counter table for a counter with a matching name.
        -: 1665:   */
      120: 1666:   for ( i = 0; i < CFE_PLATFORM_ES_MAX_GEN_COUNTERS; i++ )
        -: 1667:   {
      108: 1668:      if ( CFE_ES_Global.CounterTable[i].RecordUsed == TRUE )
        -: 1669:      {
       59: 1670:         if ( strncmp(CounterName, (char *)CFE_ES_Global.CounterTable[i].CounterName, OS_MAX_API_NAME) == 0 )
        -: 1671:         {
        4: 1672:            if(CounterIdPtr != NULL)
        -: 1673:            {
        3: 1674:               *CounterIdPtr = i;
        3: 1675:               Result = CFE_SUCCESS;
        -: 1676:            }
        4: 1677:            break;
        -: 1678:         }
        -: 1679:      }
        -: 1680:   } /* end for */
        -: 1681:   
       16: 1682:   return(Result);
        -: 1683:
        -: 1684:} /* End of CFE_ES_GetGenCounterIDByName() */
        -: 1685:
        -: 1686:
        -: 1687:/***************************************************************************************
        -: 1688:** Private API functions
        -: 1689:*/
        -: 1690:
        -: 1691:/*
        -: 1692:** Function: CFE_ES_GetAppIDInternal
        -: 1693:**
        -: 1694:** Purpose:  Return the Caller's cFE Application ID. This internal version is needed
        -: 1695:**            so there are not nested calls to the ES Shared Data mutex lock.
        -: 1696:**
        -: 1697:*/
       53: 1698:int32 CFE_ES_GetAppIDInternal(uint32 *AppIdPtr)
        -: 1699:{
       53: 1700:   int32  Result = CFE_ES_ERR_APPID;
        -: 1701:   uint32 TaskId;
        -: 1702:
        -: 1703:   /*
        -: 1704:   ** Step 1: Get the OS task ID
        -: 1705:   */
       53: 1706:   if (OS_ConvertToArrayIndex(OS_TaskGetId(), &TaskId) == OS_SUCCESS)
        -: 1707:   {
        -: 1708:      /*
        -: 1709:      ** Step 2: get the Application ID for the current task
        -: 1710:      */
       53: 1711:      if ( CFE_ES_Global.TaskTable[TaskId].RecordUsed == TRUE )
        -: 1712:      {
       37: 1713:         *AppIdPtr = CFE_ES_Global.TaskTable[TaskId].AppId;
       37: 1714:         Result = CFE_SUCCESS;
        -: 1715:      }
        -: 1716:      else
        -: 1717:      {
       16: 1718:         *AppIdPtr = 0;
        -: 1719:      } /* end if */
        -: 1720:   }
        -: 1721:   else
        -: 1722:   {
    #####: 1723:      *AppIdPtr = 0;
        -: 1724:   } /* end if */
        -: 1725:
       53: 1726:   return(Result);
        -: 1727:
        -: 1728:} /* End of CFE_ES_GetAppIDInternal() */
        -: 1729:
        -: 1730:
        -: 1731:/******************************************************************************
        -: 1732:**  Function:  CFE_ES_LockSharedData()
        -: 1733:**
        -: 1734:**  Purpose:
        -: 1735:**    ES internal function to take the Shared Data Mutex and handle
        -: 1736:**    error conditions.
        -: 1737:**
        -: 1738:**  Arguments:
        -: 1739:**    FunctionName   - the name of the function containing the code that generated the error.
        -: 1740:**    LineNumber     - the file line number of the code that generated the error.
        -: 1741:**
        -: 1742:**  Return:
        -: 1743:**    None
        -: 1744:*/
    12715: 1745:void CFE_ES_LockSharedData(const char *FunctionName, int32 LineNumber)
        -: 1746:{
        -: 1747:
        -: 1748:    int32   Status;
        -: 1749:    uint32  AppId;
        -: 1750:
    12715: 1751:    Status = OS_MutSemTake(CFE_ES_Global.SharedDataMutex);
    12715: 1752:    if (Status != OS_SUCCESS) 
        -: 1753:    {
        1: 1754:        CFE_ES_GetAppIDInternal(&AppId);
        -: 1755:
        -: 1756:        /*
        -: 1757:         * NOTE: this is going to write into a buffer that itself
        -: 1758:         * is _supposed_ to be protected by this same mutex.
        -: 1759:         */
        1: 1760:        CFE_ES_SysLogWrite_Unsync("ES SharedData Mutex Take Err Stat=0x%x,App=%d,Func=%s,Line=%d\n",
        -: 1761:                (unsigned int)Status,(int)AppId,FunctionName,(int)LineNumber);
        -: 1762:
        -: 1763:    }/* end if */
        -: 1764:
    12715: 1765:    return;
        -: 1766:
        -: 1767:}/* end CFE_ES_LockSharedData */
        -: 1768:
        -: 1769:/******************************************************************************
        -: 1770:**  Function:  CFE_ES_UnlockSharedData()
        -: 1771:**
        -: 1772:**  Purpose:
        -: 1773:**    ES internal function to Release the shared data mutex and handle error
        -: 1774:**    conditions.
        -: 1775:**
        -: 1776:**  Arguments:
        -: 1777:**    FunctionName   - the name of the function containing the code that generated the error.
        -: 1778:**    LineNumber     - the file line number of the code that generated the error.
        -: 1779:**
        -: 1780:**  Return:
        -: 1781:**    None
        -: 1782:*/
    12715: 1783:void CFE_ES_UnlockSharedData(const char *FunctionName, int32 LineNumber)
        -: 1784:{
        -: 1785:    int32   Status;
        -: 1786:    uint32  AppId;
        -: 1787:
    12715: 1788:    Status = OS_MutSemGive(CFE_ES_Global.SharedDataMutex);
    12715: 1789:    if (Status != OS_SUCCESS) 
        -: 1790:    {
        -: 1791:
        1: 1792:        CFE_ES_GetAppIDInternal(&AppId);
        -: 1793:
        -: 1794:        /*
        -: 1795:         * NOTE: this is going to write into a buffer that itself
        -: 1796:         * is _supposed_ to be protected by this same mutex.
        -: 1797:         */
        1: 1798:        CFE_ES_SysLogWrite_Unsync("ES SharedData Mutex Give Err Stat=0x%x,App=%d,Func=%s,Line=%d\n",
        -: 1799:                (unsigned int)Status,(int)AppId,FunctionName,(int)LineNumber);
        -: 1800:
        -: 1801:    }/* end if */
        -: 1802:
    12715: 1803:    return;
        -: 1804:
        -: 1805:}/* end CFE_ES_UnlockSharedData */
        -: 1806:
        -: 1807:/******************************************************************************
        -: 1808:**  Function:  CFE_ES_ProcessCoreException()
        -: 1809:**
        -: 1810:**  Purpose:
        -: 1811:**    ES internal function to handle the logging and reset from a system or
        -: 1812:**    cFE core exception
        -: 1813:**
        -: 1814:**  Arguments:
        -: 1815:**    Reason String
        -: 1816:**    Context
        -: 1817:**    Context Size
        -: 1818:** 
        -: 1819:**  Return:
        -: 1820:**    None
        -: 1821:*/
        6: 1822:void CFE_ES_ProcessCoreException(uint32  HostTaskId,     const char *ReasonString,
        -: 1823:                                 const uint32 *ContextPointer, uint32 ContextSize)
        -: 1824:{
        -: 1825:    uint32                 i;
        -: 1826:    int32                  Status;
        -: 1827:    OS_task_prop_t         TaskProp;
        -: 1828:    CFE_ES_TaskInfo_t      EsTaskInfo;
        6: 1829:    uint32                 FoundExceptionTask = 0;
        6: 1830:    uint32                 ExceptionTaskID = 0;
        -: 1831:    
        -: 1832:    /*
        -: 1833:    ** If a loadable cFE Application caused the reset and it's
        -: 1834:    ** exception action is set to Restart the App rather than cause a
        -: 1835:    ** processor reset, then just reset the App.
        -: 1836:    */
        -: 1837:
        -: 1838:    /*
        -: 1839:    ** We have the Host Task Id ( vxWorks, RTEMS, etc ). Search
        -: 1840:    ** the OSAPI to see if a match can be found.
        -: 1841:    */ 
      264: 1842:    for ( i = 0; i < OS_MAX_TASKS; i++ )
        -: 1843:    {
      260: 1844:       if (CFE_ES_Global.TaskTable[i].RecordUsed == TRUE)
        -: 1845:       {
        4: 1846:          ExceptionTaskID = CFE_ES_Global.TaskTable[i].TaskId;
        4: 1847:          Status = OS_TaskGetInfo (ExceptionTaskID, &TaskProp);
        -: 1848:
        4: 1849:          if ( Status == OS_SUCCESS && TaskProp.OStask_id == HostTaskId )
        -: 1850:          {
        2: 1851:             FoundExceptionTask = 1;
        2: 1852:             break;
        -: 1853:          }
        -: 1854:       }
        -: 1855:    }
        -: 1856:
        -: 1857:    /*
        -: 1858:    ** If the Task is found in the OS, see if the cFE App ID associated with it can be found.
        -: 1859:    */
        6: 1860:    if ( FoundExceptionTask == 1 )
        -: 1861:    {
        2: 1862:       Status = CFE_ES_GetTaskInfo( &EsTaskInfo, ExceptionTaskID );
        -: 1863:       /*
        -: 1864:       ** The App ID was found, now see if the ExceptionAction is set for a reset
        -: 1865:       */                                                                                                                         
        2: 1866:       if ( Status == CFE_SUCCESS )
        -: 1867:       {
        1: 1868:          if ( CFE_ES_Global.AppTable[EsTaskInfo.AppId].StartParams.ExceptionAction == CFE_ES_ExceptionAction_RESTART_APP )
        -: 1869:          {
        -: 1870:
        -: 1871:             /*
        -: 1872:             ** Log the Application reset 
        -: 1873:             */
        1: 1874:             CFE_ES_WriteToERLog(CFE_ES_LogEntryType_CORE, CFE_ES_APP_RESTART,
        -: 1875:                            CFE_PSP_RST_SUBTYPE_EXCEPTION, (char *)ReasonString,
        -: 1876:                            ContextPointer, ContextSize );
        -: 1877:
        -: 1878:             /*
        -: 1879:             ** Finally restart the App! This call is just a request
        -: 1880:             ** to ES.
        -: 1881:             */ 
        1: 1882:             CFE_ES_RestartApp(EsTaskInfo.AppId );
        -: 1883:             
        -: 1884:             /*
        -: 1885:             ** Return to avoid the Processor Restart Logic
        -: 1886:             */
        1: 1887:             return;
        -: 1888:
        -: 1889:          } /* end if ExceptionAction */
        -: 1890:                                                                                                                                     
        -: 1891:       } /* end if */
        -: 1892:                                                                                                                                   
        -: 1893:    } /* End if FoundExceptionTask */
        -: 1894:                                                                                                                                     
        -: 1895:    /*
        -: 1896:    ** If we made it here, which means that we need to do a processor reset
        -: 1897:    */
        -: 1898:
        -: 1899:    /*
        -: 1900:    ** Before doing a Processor reset, check to see 
        -: 1901:    ** if the maximum number has been exceeded
        -: 1902:    */
       10: 1903:    if ( CFE_ES_ResetDataPtr->ResetVars.ProcessorResetCount >= 
        5: 1904:         CFE_ES_ResetDataPtr->ResetVars.MaxProcessorResetCount )
        -: 1905:    {
        -: 1906:        /*
        -: 1907:        ** Log the reset in the ER Log. The log will be wiped out, but it's good to have
        -: 1908:        ** the entry just in case something fails.
        -: 1909:        */
        1: 1910:        CFE_ES_WriteToERLog(CFE_ES_LogEntryType_CORE,  CFE_PSP_RST_TYPE_POWERON, 
        -: 1911:                            CFE_PSP_RST_SUBTYPE_EXCEPTION, (char *)ReasonString,
        -: 1912:                            ContextPointer, ContextSize );
        -: 1913:
        -: 1914:        /*
        -: 1915:        ** Call the BSP reset routine to do a Poweron Reset 
        -: 1916:        */
        1: 1917:        CFE_PSP_Restart(CFE_PSP_RST_TYPE_POWERON);
        -: 1918:
        -: 1919:    }
        -: 1920:    else /* Do a processor reset */
        -: 1921:    {
        -: 1922:        /*
        -: 1923:        ** Update the reset variables
        -: 1924:        */
        4: 1925:        CFE_ES_ResetDataPtr->ResetVars.ProcessorResetCount++;
        4: 1926:        CFE_ES_ResetDataPtr->ResetVars.ES_CausedReset = TRUE;
        -: 1927:
        -: 1928:        /*
        -: 1929:        ** Log the reset in the ER Log
        -: 1930:        */
        4: 1931:        CFE_ES_WriteToERLog(CFE_ES_LogEntryType_CORE, CFE_PSP_RST_TYPE_PROCESSOR, 
        -: 1932:                            CFE_PSP_RST_SUBTYPE_EXCEPTION, (char *)ReasonString,
        -: 1933:                            ContextPointer, ContextSize );
        -: 1934:
        -: 1935:        /*
        -: 1936:        ** Need to do a processor reset
        -: 1937:        */   
        4: 1938:        CFE_PSP_Restart(CFE_PSP_RST_TYPE_PROCESSOR);
        -: 1939:
        -: 1940:    } /* end if */
        -: 1941:           
        -: 1942:} /* End of CFE_ES_ProcessCoreException */
