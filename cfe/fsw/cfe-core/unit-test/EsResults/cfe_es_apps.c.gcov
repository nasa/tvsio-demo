        -:    0:Source:/home/mdeschu/cfe-660-ut/cfe/fsw/cfe-core/src/es/cfe_es_apps.c
        -:    0:Programs:11
        -:    1:/*
        -:    2:**  File:  
        -:    3:**    cfe_es_apps.c
        -:    4:** 
        -:    5:**
        -:    6:**
        -:    7:**      Copyright (c) 2004-2012, United States government as represented by the 
        -:    8:**      administrator of the National Aeronautics Space Administration.  
        -:    9:**      All rights reserved. This software(cFE) was created at NASA's Goddard 
        -:   10:**      Space Flight Center pursuant to government contracts.
        -:   11:**
        -:   12:**      This is governed by the NASA Open Source Agreement and may be used, 
        -:   13:**      distributed and modified only pursuant to the terms of that agreement.
        -:   14:**
        -:   15:**  Purpose:  
        -:   16:**    This file contains functions for starting cFE applications from a filesystem.
        -:   17:**
        -:   18:**  References:
        -:   19:**     Flight Software Branch C Coding Standard Version 1.0a
        -:   20:**     cFE Flight Software Application Developers Guide
        -:   21:**
        -:   22:**  Notes:
        -:   23:**
        -:   24:*/
        -:   25:
        -:   26:/* 
        -:   27:** Includes
        -:   28:*/
        -:   29:#include "private/cfe_private.h"
        -:   30:#include "cfe_es.h"
        -:   31:#include "cfe_psp.h"     
        -:   32:#include "cfe_es_global.h"
        -:   33:#include "cfe_es_apps.h"
        -:   34:#include "cfe_es_log.h"
        -:   35:
        -:   36:#include <stdio.h>
        -:   37:#include <string.h> /* memset() */
        -:   38:#include <fcntl.h>
        -:   39:
        -:   40:#ifdef _ENHANCED_BUILD_
        -:   41:#include "target_config.h"
        -:   42:#endif
        -:   43:
        -:   44:/*
        -:   45:** Defines
        -:   46:*/
        -:   47:#define ES_START_BUFF_SIZE 128
        -:   48:
        -:   49:/* For extra debug code */
        -:   50:#undef ES_APP_DEBUG
        -:   51:
        -:   52:/*
        -:   53:**
        -:   54:**  Global Variables
        -:   55:**
        -:   56:*/
        -:   57:
        -:   58:/*
        -:   59:****************************************************************************
        -:   60:** Functions
        -:   61:***************************************************************************
        -:   62:*/
        -:   63:
        -:   64:/*
        -:   65:** Name: 
        -:   66:**   CFE_ES_StartApplications
        -:   67:**
        -:   68:** Purpose: 
        -:   69:**   This routine loads/starts cFE applications.
        -:   70:**
        -:   71:*/
        8:   72:void CFE_ES_StartApplications(uint32 ResetType, const char *StartFilePath )
        -:   73:{
        -:   74:   char ES_AppLoadBuffer[ES_START_BUFF_SIZE];  /* A buffer of for a line in a file */   
        -:   75:   const char *TokenList[CFE_ES_STARTSCRIPT_MAX_TOKENS_PER_LINE];
        -:   76:   uint32      NumTokens;
        8:   77:   uint32      BuffLen = 0;                            /* Length of the current buffer */
        8:   78:   int32       AppFile = 0;
        -:   79:   char        c;
        -:   80:   int32       ReadStatus;
        8:   81:   boolean     LineTooLong = FALSE;
        8:   82:   boolean     FileOpened = FALSE;
        -:   83:
        -:   84:#ifdef _ENHANCED_BUILD_
        -:   85:   CFE_StaticModuleLoadEntry_t *Entry;
        -:   86:   CFE_ES_AppStaticModuleApi_t *ApiPtr;
        -:   87:   uint32       StaticId;
        -:   88:
        -:   89:   /* First run through the static application list */
        -:   90:   Entry = GLOBAL_CONFIGDATA.CfsModuleList;
        -:   91:   if (Entry != NULL)
        -:   92:   {
        -:   93:       while (Entry->Name != NULL)
        -:   94:       {
        -:   95:           ApiPtr = (CFE_ES_AppStaticModuleApi_t *)Entry->Api;
        -:   96:           if (ApiPtr->EntryType == CFE_ES_STATICENTRYTYPE_APPLICATION)
        -:   97:           {
        -:   98:               ReadStatus = CFE_ES_AppCreate(&StaticId, NULL,
        -:   99:                       Entry->Api, Entry->Name, ApiPtr->Priority,
        -:  100:                       ApiPtr->StackSize, CFE_ES_ExceptionAction_PROC_RESTART);
        -:  101:           }
        -:  102:           else if (ApiPtr->EntryType == CFE_ES_STATICENTRYTYPE_LIBRARY)
        -:  103:           {
        -:  104:               ReadStatus = CFE_ES_LoadLibrary(&StaticId, NULL,
        -:  105:                       Entry->Api, Entry->Name);
        -:  106:           }
        -:  107:           ++Entry;
        -:  108:       }
        -:  109:   }
        -:  110:#endif
        -:  111:
        -:  112:   /*
        -:  113:   ** Get the ES startup script filename.
        -:  114:   ** If this is a Processor Reset, try to open the file in the volatile disk first.
        -:  115:   */
        8:  116:   if ( ResetType == CFE_PSP_RST_TYPE_PROCESSOR )
        -:  117:   {
        -:  118:      /*
        -:  119:      ** Open the file in the volatile disk.
        -:  120:      */
        5:  121:      AppFile = OS_open( CFE_PLATFORM_ES_VOLATILE_STARTUP_FILE, O_RDONLY, 0);
        -:  122:
        5:  123:      if ( AppFile >= 0 )
        -:  124:      {
        4:  125:         CFE_ES_WriteToSysLog ("ES Startup: Opened ES App Startup file: %s\n", 
        -:  126:                                CFE_PLATFORM_ES_VOLATILE_STARTUP_FILE);
        4:  127:         FileOpened = TRUE;
        -:  128:      }
        -:  129:      else 
        -:  130:      {
        1:  131:         CFE_ES_WriteToSysLog ("ES Startup: Cannot Open Volatile Startup file, Trying Nonvolatile.\n");
        1:  132:         FileOpened = FALSE;
        -:  133:      }
        -:  134:
        -:  135:   } /* end if */
        -:  136:   
        -:  137:   /*
        -:  138:   ** This if block covers two cases: A Power on reset, and a Processor reset when
        -:  139:   ** the startup file on the volatile file system could not be opened.
        -:  140:   */
        8:  141:   if ( FileOpened == FALSE )
        -:  142:   {
        -:  143:      /*
        -:  144:      ** Try to Open the file passed in to the cFE start.
        -:  145:      */
        4:  146:      AppFile = OS_open( (const char *)StartFilePath, O_RDONLY, 0);
        -:  147:
        4:  148:      if ( AppFile >= 0 )
        -:  149:      {
        2:  150:         CFE_ES_WriteToSysLog ("ES Startup: Opened ES App Startup file: %s\n",StartFilePath);
        2:  151:         FileOpened = TRUE;
        -:  152:      }
        -:  153:      else 
        -:  154:      {
        2:  155:         CFE_ES_WriteToSysLog ("ES Startup: Error, Can't Open ES App Startup file: %s EC = 0x%08X\n",
        -:  156:                              StartFilePath, (unsigned int)AppFile );
        2:  157:         FileOpened = FALSE;
        -:  158:      }
        -:  159:   
        -:  160:   }
        -:  161:   
        -:  162:   /*
        -:  163:   ** If the file is opened in either the Nonvolatile or the Volatile disk, process it.
        -:  164:   */
        8:  165:   if ( FileOpened == TRUE)
        -:  166:   {
        6:  167:      memset(ES_AppLoadBuffer,0x0,ES_START_BUFF_SIZE);
        6:  168:      BuffLen = 0;      
        6:  169:      NumTokens = 0;
        6:  170:      TokenList[0] = ES_AppLoadBuffer;
        -:  171:      
        -:  172:      /*
        -:  173:      ** Parse the lines from the file. If it has an error
        -:  174:      ** or reaches EOF, then abort the loop.
        -:  175:      */
        -:  176:      while(1)
        -:  177:      {
     1205:  178:         ReadStatus = OS_read(AppFile, &c, 1);
     1205:  179:         if ( ReadStatus == OS_FS_ERROR )
        -:  180:         {
        1:  181:            CFE_ES_WriteToSysLog ("ES Startup: Error Reading Startup file. EC = 0x%08X\n",(unsigned int)ReadStatus);
        1:  182:            break;
        -:  183:         }
     1204:  184:         else if ( ReadStatus == 0 )
        -:  185:         {
        -:  186:            /*
        -:  187:            ** EOF Reached
        -:  188:            */
        1:  189:            break;
        -:  190:         }
     1203:  191:         else if(c != '!')
        -:  192:         {
     1199:  193:             if ( c <= ' ')
        -:  194:             {
        -:  195:                /*
        -:  196:                ** Skip all white space in the file
        -:  197:                */
        -:  198:                ;
        -:  199:             }
     1071:  200:             else if ( c == ',' )
        -:  201:             {
        -:  202:                /*
        -:  203:                ** replace the field delimiter with a null
        -:  204:                ** This is used to separate the tokens
        -:  205:                */
      112:  206:                if ( BuffLen < ES_START_BUFF_SIZE )
        -:  207:                {
      109:  208:                   ES_AppLoadBuffer[BuffLen] = 0;
        -:  209:                }
        -:  210:                else
        -:  211:                {
        3:  212:                   LineTooLong = TRUE;
        -:  213:                } 
      112:  214:                BuffLen++;
        -:  215:
      112:  216:                if ( NumTokens < (CFE_ES_STARTSCRIPT_MAX_TOKENS_PER_LINE-1))
        -:  217:                {
        -:  218:                    /*
        -:  219:                     * NOTE: pointer never deferenced unless "LineTooLong" is false.
        -:  220:                     */
      112:  221:                    ++NumTokens;
      112:  222:                    TokenList[NumTokens] = &ES_AppLoadBuffer[BuffLen];
        -:  223:                }
        -:  224:             }
      959:  225:             else if ( c != ';' )
        -:  226:             {
        -:  227:                /*
        -:  228:                ** Regular data gets copied in
        -:  229:                */
      943:  230:                if ( BuffLen < ES_START_BUFF_SIZE )
        -:  231:                {
      937:  232:                   ES_AppLoadBuffer[BuffLen] = c;
        -:  233:                }
        -:  234:                else
        -:  235:                {
        6:  236:                   LineTooLong = TRUE;
        -:  237:                }
      943:  238:                BuffLen++;
        -:  239:             }
        -:  240:             else
        -:  241:             {
       16:  242:                if ( LineTooLong == TRUE )
        -:  243:                {   
        -:  244:                   /*
        -:  245:                   ** The was too big for the buffer
        -:  246:                   */
        1:  247:                   CFE_ES_WriteToSysLog ("ES Startup: ES Startup File Line is too long: %u bytes.\n",(unsigned int)BuffLen);
        1:  248:                   LineTooLong = FALSE;
        -:  249:                }
        -:  250:                else
        -:  251:                {
        -:  252:                   /*
        -:  253:                   ** Send the line to the file parser
        -:  254:                   ** Ensure termination of the last token and send it along
        -:  255:                   */
       15:  256:                   ES_AppLoadBuffer[BuffLen] = 0;
       15:  257:                   CFE_ES_ParseFileEntry(TokenList, 1 + NumTokens);
        -:  258:                }
       16:  259:                BuffLen = 0;
       16:  260:                NumTokens = 0;
        -:  261:             }
        -:  262:         }
        -:  263:         else
        -:  264:         {
        -:  265:           /*
        -:  266:           ** break when EOF character '!' is reached
        -:  267:           */
        4:  268:           break;
        -:  269:         }
     1199:  270:      }
        -:  271:      /*
        -:  272:      ** close the file
        -:  273:      */
        6:  274:      OS_close(AppFile);
        -:  275:       
        -:  276:   }
        8:  277:}
        -:  278:
        -:  279:/*
        -:  280:**---------------------------------------------------------------------------------------
        -:  281:** Name: CFE_ES_ParseFileEntry
        -:  282:**
        -:  283:**   Purpose: This function parses the startup file line for an individual
        -:  284:**            cFE application.
        -:  285:**---------------------------------------------------------------------------------------
        -:  286:*/
       19:  287:int32 CFE_ES_ParseFileEntry(const char **TokenList, uint32 NumTokens)
        -:  288:{
        -:  289:   const char   *FileName;
        -:  290:   const char   *AppName;
        -:  291:   const char   *EntryPoint;
        -:  292:   const char   *EntryType;
        -:  293:   unsigned int Priority;
        -:  294:   unsigned int StackSize;
        -:  295:   unsigned int ExceptionAction;
        -:  296:   uint32 ApplicationId;
       19:  297:   int32  CreateStatus = CFE_ES_ERR_APP_CREATE;
        -:  298:
        -:  299:   /*
        -:  300:   ** Check to see if the correct number of items were parsed
        -:  301:   */
       19:  302:   if ( NumTokens < 8 )
        -:  303:   {
        1:  304:      CFE_ES_WriteToSysLog("ES Startup: Invalid ES Startup file entry: %u\n",(unsigned int)NumTokens);
        1:  305:      return (CreateStatus);
        -:  306:   }
        -:  307:
       18:  308:   EntryType = TokenList[0];
       18:  309:   FileName = TokenList[1];
       18:  310:   EntryPoint = TokenList[2];
       18:  311:   AppName = TokenList[3];
        -:  312:
        -:  313:   /*
        -:  314:    * NOTE: In previous CFE versions the sscanf() function was used to convert
        -:  315:    * these string values into integers.  This approach of using the pre-tokenized strings
        -:  316:    * and strtoul() is safer but the side effect is that it will also be more "permissive" in
        -:  317:    * what is accepted vs. rejected by this function.
        -:  318:    *
        -:  319:    * For instance if the startup script contains "123xyz", this will be converted to the value
        -:  320:    * 123 instead of triggering a validation failure as it would have in CFE <= 6.5.0.
        -:  321:    *
        -:  322:    * This permissive parsing should not be relied upon, as it may become more strict again in
        -:  323:    * future CFE revisions.
        -:  324:    */
       18:  325:   Priority = strtoul(TokenList[4], NULL, 0);
       18:  326:   StackSize = strtoul(TokenList[5], NULL, 0);
       18:  327:   ExceptionAction = strtoul(TokenList[7], NULL, 0);
        -:  328:
       18:  329:   if(strcmp(EntryType,"CFE_APP")==0)
        -:  330:   {
       13:  331:      CFE_ES_WriteToSysLog("ES Startup: Loading file: %s, APP: %s\n",
        -:  332:                            FileName, AppName);
        -:  333:      
        -:  334:      /*
        -:  335:      ** Validate Some parameters
        -:  336:      ** Exception action should be 0 ( Restart App ) or
        -:  337:      ** 1 ( Processor reset ). If it's non-zero, assume it means
        -:  338:      ** reset CPU.
        -:  339:      */
       13:  340:      if ( ExceptionAction > CFE_ES_ExceptionAction_RESTART_APP ) 
       12:  341:          ExceptionAction = CFE_ES_ExceptionAction_PROC_RESTART;
        -:  342:      /*
        -:  343:      ** Now create the application 
        -:  344:      */
       13:  345:      CreateStatus = CFE_ES_AppCreate(&ApplicationId, FileName, 
        -:  346:                               EntryPoint, AppName, (uint32) Priority, 
        -:  347:                               (uint32) StackSize, (uint32) ExceptionAction );
        -:  348:   }
        5:  349:   else if(strcmp(EntryType,"CFE_LIB")==0)
        -:  350:   {            
        3:  351:      CFE_ES_WriteToSysLog("ES Startup: Loading shared library: %s\n",FileName);
        -:  352:                                                             
        -:  353:      /*
        -:  354:      ** Now load the library
        -:  355:      */
        3:  356:      CreateStatus = CFE_ES_LoadLibrary(&ApplicationId, FileName, 
        -:  357:                               EntryPoint, AppName);
        -:  358:
        -:  359:   }
        2:  360:   else if(strcmp(EntryType,"CFE_DRV")==0)
        -:  361:   { 
        1:  362:      CFE_ES_WriteToSysLog("ES Startup: Device Drivers not yet implemented. %s\n",FileName);
        -:  363:   }
        -:  364:   else
        -:  365:   {
        1:  366:      CFE_ES_WriteToSysLog("ES Startup: Unexpected EntryType %s in startup file.\n",EntryType);
        -:  367:   }
        -:  368:
       18:  369:   return (CreateStatus);
        -:  370:
        -:  371:}
        -:  372:
        -:  373:/*
        -:  374:**---------------------------------------------------------------------------------------
        -:  375:** Name: ES_AppCreate
        -:  376:**
        -:  377:**   Purpose: This function loads and creates a cFE Application.
        -:  378:**            This function can be called from the ES startup code when it
        -:  379:**            loads the cFE Applications from the disk using the startup script, or it
        -:  380:**            can be called when the ES Start Application command is executed.
        -:  381:**
        -:  382:**---------------------------------------------------------------------------------------
        -:  383:*/
       32:  384:int32 CFE_ES_AppCreate(uint32 *ApplicationIdPtr,
        -:  385:                       const char   *FileName,
        -:  386:                       const void   *EntryPointData,
        -:  387:                       const char   *AppName,
        -:  388:                       uint32  Priority,
        -:  389:                       uint32  StackSize,
        -:  390:                       uint32  ExceptionAction)
        -:  391:{
        -:  392:   cpuaddr StartAddr;
        -:  393:   int32   ReturnCode;
        -:  394:   uint32  i;
        -:  395:   boolean AppSlotFound;
        -:  396:   uint32  TaskId;
        -:  397:   uint32  ModuleId;
        -:  398:   char    FileNameOnly[OS_MAX_PATH_LEN];
        -:  399:   char    RamDiskPath[OS_MAX_PATH_LEN];
        -:  400:   size_t  StringLength;
       32:  401:   boolean IsRamDiskFile = FALSE;
       32:  402:   CFE_ES_AppStaticModuleApi_t *StaticEntryPtr = NULL;
        -:  403:
        -:  404:
        -:  405:   /*
        -:  406:   ** Allocate an ES_AppTable entry
        -:  407:   */
       32:  408:   CFE_ES_LockSharedData(__func__,__LINE__);
       32:  409:   AppSlotFound = FALSE;
      112:  410:   for ( i = 0; i < CFE_PLATFORM_ES_MAX_APPLICATIONS; i++ )
        -:  411:   {
      111:  412:      if ( CFE_ES_Global.AppTable[i].RecordUsed == FALSE )
        -:  413:      {
       31:  414:         AppSlotFound = TRUE;
       31:  415:         CFE_ES_Global.AppTable[i].RecordUsed = TRUE; /* Reserve Slot */
       31:  416:         break;
        -:  417:      }
        -:  418:   }
       32:  419:   CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  420:
        -:  421:   /*
        -:  422:   ** If a slot was found, create the application
        -:  423:   */
       32:  424:   if ( AppSlotFound == TRUE)
        -:  425:   {
        -:  426:      /*
        -:  427:       * Check if dynamically loading -
        -:  428:       * if statically linked then FileName is NULL and EntryPointData points to the API structure
        -:  429:       */
       31:  430:      if (FileName != NULL)
        -:  431:      {
        -:  432:          /*
        -:  433:          ** Check to see if the code is a Gzip file
        -:  434:          */
       30:  435:          if ( CFE_FS_IsGzFile(FileName) == TRUE )
        -:  436:          {
        -:  437:             /*
        -:  438:             ** Build up the destination path in the RAM disk
        -:  439:             */
        5:  440:             (void) CFE_SB_MessageStringGet(RamDiskPath, 
        -:  441:                                            CFE_PLATFORM_ES_RAM_DISK_MOUNT_STRING"/", 
        -:  442:                                            NULL, 
        -:  443:                                            sizeof(RamDiskPath), 
        -:  444:                                            sizeof(CFE_PLATFORM_ES_RAM_DISK_MOUNT_STRING"/"));
        -:  445:            
        -:  446:             /*
        -:  447:             ** Extract the filename from the path
        -:  448:             */
        5:  449:             ReturnCode = CFE_FS_ExtractFilenameFromPath(FileName, FileNameOnly);
        -:  450:
        5:  451:             if ( ReturnCode == CFE_SUCCESS )
        -:  452:             {
        3:  453:                if ((strlen(RamDiskPath) + strlen(FileNameOnly)) < OS_MAX_PATH_LEN)
        -:  454:                {
        -:  455:
        -:  456:                    /*
        -:  457:                    ** Cat the Filename to the RamDiskPath
        -:  458:                    */
        2:  459:                    strcat(RamDiskPath, FileNameOnly);
        -:  460:            
        -:  461:                    /*
        -:  462:                    ** Remove the ".gz" prefix from the filename
        -:  463:                    ** Already Determined that the filename ends in ".gz"
        -:  464:                    */
        2:  465:                    StringLength = strlen(RamDiskPath);
        2:  466:                    RamDiskPath[StringLength - 3] = '\0';
        -:  467:
        -:  468:                    /*
        -:  469:                    ** Decompress the file:
        -:  470:                    */
        2:  471:                    ReturnCode =  CFE_FS_Decompress( FileName, RamDiskPath);
        -:  472:
        2:  473:                    if ( ReturnCode != OS_SUCCESS )
        -:  474:                    {
        1:  475:                       CFE_ES_WriteToSysLog("ES Startup: Unable to decompress Application File: %s\n",FileName);
        -:  476:
        1:  477:                       CFE_ES_LockSharedData(__func__,__LINE__);
        1:  478:                       CFE_ES_Global.AppTable[i].RecordUsed = FALSE; /* Release slot */
        1:  479:                       CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  480:
        1:  481:                       return(CFE_ES_ERR_APP_CREATE);
        -:  482:                    }
        -:  483:                    else
        -:  484:                    {
        -:  485:                       /*
        -:  486:                       ** All ready to use unzipped RAM disk file
        -:  487:                       */
        1:  488:                       IsRamDiskFile = TRUE;
        1:  489:                       ReturnCode = OS_ModuleLoad( &ModuleId, AppName, RamDiskPath);
        -:  490:                    }
        -:  491:                }
        -:  492:                else
        -:  493:                {
        -:  494:                    /* Can't include the name string since it could be too long for the message */
        1:  495:                    CFE_ES_WriteToSysLog("ES Startup: Application path plus file name length (%d) exceeds max allowed (%d)\n",
        1:  496:                                         (int)(strlen(RamDiskPath) + strlen(FileNameOnly)), OS_MAX_PATH_LEN);
        -:  497:
        1:  498:                    CFE_ES_LockSharedData(__func__,__LINE__);
        1:  499:                    CFE_ES_Global.AppTable[i].RecordUsed = FALSE; /* Release slot */
        1:  500:                    CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  501:
        1:  502:                    return(CFE_ES_ERR_APP_CREATE);
        -:  503:                }
        -:  504:
        -:  505:             }
        -:  506:             else
        -:  507:             {
        2:  508:                CFE_ES_WriteToSysLog("ES Startup: Unable to extract filename from path: %s.\n",FileName);
        2:  509:                CFE_ES_LockSharedData(__func__,__LINE__);
        2:  510:                CFE_ES_Global.AppTable[i].RecordUsed = FALSE; /* Release slot */
        2:  511:                CFE_ES_UnlockSharedData(__func__,__LINE__);
        2:  512:                return(CFE_ES_ERR_APP_CREATE);
        -:  513:             }
        -:  514:
        -:  515:          }
        -:  516:          else
        -:  517:          {
        -:  518:              /*
        -:  519:              ** Load the module directly
        -:  520:              */
       25:  521:              ReturnCode = OS_ModuleLoad ( &ModuleId, AppName, FileName );
        -:  522:          }
        -:  523:          /*
        -:  524:          ** If the Load was OK, then lookup the address of the entry point
        -:  525:          */
       26:  526:          if ( ReturnCode == OS_SUCCESS )
        -:  527:          {
       25:  528:             ReturnCode = OS_SymbolLookup( &StartAddr, (const char*)EntryPointData );
       25:  529:             if ( ReturnCode != OS_SUCCESS )
        -:  530:             {
        2:  531:                 CFE_ES_WriteToSysLog("ES Startup: Could not find symbol:%s. EC = 0x%08X\n",
        -:  532:                         (const char*)EntryPointData, (unsigned int)ReturnCode);
        -:  533:
        2:  534:                 CFE_ES_LockSharedData(__func__,__LINE__);
        2:  535:                 CFE_ES_Global.AppTable[i].RecordUsed = FALSE; /* Release slot */
        2:  536:                 CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  537:
        -:  538:                 /* Unload the module from memory, so that it does not consume resources */
        2:  539:                 ReturnCode = OS_ModuleUnload(ModuleId);
        2:  540:                 if ( ReturnCode != OS_SUCCESS ) /* There's not much we can do except notify */
        -:  541:                 {
        1:  542:                	CFE_ES_WriteToSysLog("ES Startup: Failed to unload APP: %s. EC = 0x%08X\n",
        -:  543:                			AppName, (unsigned int)ReturnCode);
        -:  544:                 }
        -:  545:
        2:  546:                 return(CFE_ES_ERR_APP_CREATE);
        -:  547:             }
        -:  548:          }
        -:  549:          else /* load not successful */
        -:  550:          {
        1:  551:              CFE_ES_WriteToSysLog("ES Startup: Could not load cFE application file:%s. EC = 0x%08X\n",
        -:  552:                                FileName, (unsigned int)ReturnCode);
        -:  553:
        1:  554:              CFE_ES_LockSharedData(__func__,__LINE__);
        1:  555:              CFE_ES_Global.AppTable[i].RecordUsed = FALSE; /* Release slot */
        1:  556:              CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  557:
        1:  558:              return(CFE_ES_ERR_APP_CREATE);
        -:  559:          }
        -:  560:      }
        -:  561:      else /* Not a dynamic load - app must be statically linked into current exe */
        -:  562:      {
        1:  563:          StaticEntryPtr = (CFE_ES_AppStaticModuleApi_t *)EntryPointData;
        1:  564:          StartAddr = StaticEntryPtr->Ptrs.EntryFuncAddr;
        1:  565:          ModuleId = 0;
        -:  566:      }
        -:  567:
        -:  568:      /*
        -:  569:      ** If the EntryPoint symbol was found, then start creating the App
        -:  570:      */
       24:  571:      CFE_ES_LockSharedData(__func__,__LINE__);
        -:  572:      /*
        -:  573:      ** Allocate and populate the ES_AppTable entry
        -:  574:      */
       24:  575:      memset ( &(CFE_ES_Global.AppTable[i]), 0, sizeof(CFE_ES_AppRecord_t));
       24:  576:      CFE_ES_Global.AppTable[i].RecordUsed = TRUE;
       24:  577:      CFE_ES_Global.AppTable[i].Type = CFE_ES_AppType_EXTERNAL;
        -:  578:
        -:  579:      /*
        -:  580:      ** Fill out the parameters in the AppStartParams sub-structure
        -:  581:      */
       24:  582:      strncpy((char *)CFE_ES_Global.AppTable[i].StartParams.Name, AppName, OS_MAX_API_NAME);
       24:  583:      CFE_ES_Global.AppTable[i].StartParams.Name[OS_MAX_API_NAME - 1] = '\0';
        -:  584:
       24:  585:      if (StaticEntryPtr != NULL)
        -:  586:      {
        -:  587:         /* Leave entry point / filename blank if static load entry */
        1:  588:         CFE_ES_Global.AppTable[i].StartParams.EntryPoint[0] = 0;
        1:  589:         CFE_ES_Global.AppTable[i].StartParams.FileName[0] = 0;
        -:  590:      }
        -:  591:      else
        -:  592:      {
       23:  593:         strncpy((char *)CFE_ES_Global.AppTable[i].StartParams.EntryPoint, (const char *)EntryPointData, OS_MAX_API_NAME);
       23:  594:         CFE_ES_Global.AppTable[i].StartParams.EntryPoint[OS_MAX_API_NAME - 1] = '\0';
       23:  595:         strncpy((char *)CFE_ES_Global.AppTable[i].StartParams.FileName, FileName, OS_MAX_PATH_LEN);
       23:  596:         CFE_ES_Global.AppTable[i].StartParams.FileName[OS_MAX_PATH_LEN - 1] = '\0';
        -:  597:      }
        -:  598:
       24:  599:      CFE_ES_Global.AppTable[i].StartParams.StackSize = StackSize;
        -:  600:
       24:  601:      CFE_ES_Global.AppTable[i].StartParams.StartAddress = StartAddr;
       24:  602:      CFE_ES_Global.AppTable[i].StartParams.ModuleId = ModuleId;
        -:  603:
       24:  604:      CFE_ES_Global.AppTable[i].StartParams.ExceptionAction = ExceptionAction;
       24:  605:      CFE_ES_Global.AppTable[i].StartParams.Priority = Priority;
        -:  606:
        -:  607:      /*
        -:  608:      ** Fill out the Task Info
        -:  609:      */
       24:  610:      strncpy((char *)CFE_ES_Global.AppTable[i].TaskInfo.MainTaskName, AppName, OS_MAX_API_NAME);
       24:  611:      CFE_ES_Global.AppTable[i].TaskInfo.MainTaskName[OS_MAX_API_NAME - 1] = '\0';
       24:  612:      CFE_ES_Global.AppTable[i].TaskInfo.NumOfChildTasks = 0;
        -:  613:
        -:  614:      /*
        -:  615:      ** Fill out the Task State info
        -:  616:      */
       24:  617:      CFE_ES_Global.AppTable[i].StateRecord.AppControlRequest = CFE_ES_RunStatus_APP_RUN;
       24:  618:      CFE_ES_Global.AppTable[i].StateRecord.AppState = CFE_ES_AppState_EARLY_INIT;
       24:  619:      CFE_ES_Global.AppTable[i].StateRecord.AppTimer = 0;
        -:  620:
        -:  621:      /*
        -:  622:      ** Create the primary task for the newly loaded task
        -:  623:      */
       24:  624:      ReturnCode = OS_TaskCreate(&CFE_ES_Global.AppTable[i].TaskInfo.MainTaskId,   /* task id */
        -:  625:                       AppName,             /* task name */
        -:  626:                       (osal_task_entry)StartAddr,   /* task function pointer */
        -:  627:                       NULL,                /* stack pointer */
        -:  628:                       StackSize,           /* stack size */
        -:  629:                       Priority,            /* task priority */
        -:  630:                       OS_FP_ENABLED);     /* task options */
        -:  631:
        -:  632:
       24:  633:      if(ReturnCode != OS_SUCCESS)
        -:  634:      {
        4:  635:         CFE_ES_SysLogWrite_Unsync("ES Startup: AppCreate Error: TaskCreate %s Failed. EC = 0x%08X!\n",
        -:  636:                       AppName,(unsigned int)ReturnCode);
        -:  637:
        4:  638:         CFE_ES_Global.AppTable[i].RecordUsed = FALSE;
        4:  639:         CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  640:
        4:  641:         return(CFE_ES_ERR_APP_CREATE);
        -:  642:      }
        -:  643:      else
        -:  644:      {
        -:  645:
        -:  646:         /*
        -:  647:         ** Record the ES_TaskTable entry
        -:  648:         */
       20:  649:         OS_ConvertToArrayIndex(CFE_ES_Global.AppTable[i].TaskInfo.MainTaskId, &TaskId);
        -:  650:
       20:  651:         if ( CFE_ES_Global.TaskTable[TaskId].RecordUsed == TRUE )
        -:  652:         {
        1:  653:            CFE_ES_SysLogWrite_Unsync("ES Startup: Error: ES_TaskTable slot in use at task creation!\n");
        -:  654:         }
        -:  655:         else
        -:  656:         {
       19:  657:            CFE_ES_Global.TaskTable[TaskId].RecordUsed = TRUE;
        -:  658:         }
       20:  659:         CFE_ES_Global.TaskTable[TaskId].AppId = i;
       20:  660:         CFE_ES_Global.TaskTable[TaskId].TaskId = CFE_ES_Global.AppTable[i].TaskInfo.MainTaskId;
       20:  661:         strncpy((char *)CFE_ES_Global.TaskTable[TaskId].TaskName,
        -:  662:             (char *)CFE_ES_Global.AppTable[i].TaskInfo.MainTaskName,OS_MAX_API_NAME );
       20:  663:         CFE_ES_Global.TaskTable[TaskId].TaskName[OS_MAX_API_NAME - 1]='\0';
       20:  664:         CFE_ES_SysLogWrite_Unsync("ES Startup: %s loaded and created\n", AppName);
       20:  665:         *ApplicationIdPtr = i;
        -:  666:
        -:  667:         /*
        -:  668:         ** Increment the registered App and Registered External Task variables.
        -:  669:         */
       20:  670:         CFE_ES_Global.RegisteredTasks++;
       20:  671:         CFE_ES_Global.RegisteredExternalApps++;
        -:  672:
       20:  673:         CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  674:
        -:  675:         /*
        -:  676:         ** Remove the temporary RAM disk file
        -:  677:         */
       20:  678:         if ( IsRamDiskFile == TRUE )
        -:  679:         {
        1:  680:            ReturnCode = OS_remove(RamDiskPath);
        -:  681:
        1:  682:            if (ReturnCode != OS_SUCCESS)
        -:  683:            {
    #####:  684:                CFE_ES_WriteToSysLog("ES Startup: Error removing temp RAM disk file, EC = 0x%08X\n",
        -:  685:                                     (unsigned int) ReturnCode);
        -:  686:            }
        -:  687:         }
        -:  688:          
       20:  689:         return(CFE_SUCCESS);
        -:  690:
        -:  691:      } /* End If OS_TaskCreate */
        -:  692:   }
        -:  693:   else /* appSlot not found */
        -:  694:   {
        1:  695:      CFE_ES_WriteToSysLog("ES Startup: No free application slots available\n");
        1:  696:      return(CFE_ES_ERR_APP_CREATE);
        -:  697:   }
        -:  698:
        -:  699:} /* End Function */
        -:  700:/*
        -:  701:**---------------------------------------------------------------------------------------
        -:  702:** Name: CFE_ES_LoadLibrary
        -:  703:**
        -:  704:**   Purpose: This function loads and initializes a cFE Shared Library.
        -:  705:**
        -:  706:**---------------------------------------------------------------------------------------
        -:  707:*/
       12:  708:int32 CFE_ES_LoadLibrary(uint32       *LibraryIdPtr,
        -:  709:                         const char   *FileName,
        -:  710:                         const void   *EntryPointData,
        -:  711:                         const char   *LibName)
        -:  712:{
        -:  713:   CFE_ES_LibraryEntryFuncPtr_t FunctionPointer;
        -:  714:   CFE_ES_LibRecord_t *         LibSlotPtr;
        -:  715:   const char *                 ActualLoadFile;
        -:  716:   size_t                       StringLength;
        -:  717:   int32                        Status;
        -:  718:   uint32                       CheckSlot;
        -:  719:   uint32                       ModuleId;
        -:  720:   osalbool                     IsModuleLoaded;
        -:  721:   osalbool                     IsRamDiskFile;
        -:  722:   char                         RamDiskPath[OS_MAX_PATH_LEN];
        -:  723:
        -:  724:   /*
        -:  725:    * First, should verify that the supplied "LibName" fits within the internal limit
        -:  726:    *  (currently sized to OS_MAX_API_NAME, but not assuming that will always be)
        -:  727:    */
       12:  728:   StringLength = strlen(LibName);
       12:  729:   if (StringLength >= sizeof(CFE_ES_Global.LibTable[0].LibName))
        -:  730:   {
        1:  731:       return CFE_ES_BAD_ARGUMENT;
        -:  732:   }
        -:  733:
        -:  734:   /*
        -:  735:   ** Allocate an ES_LibTable entry
        -:  736:   */
       11:  737:   RamDiskPath[0] = 0;
       11:  738:   IsModuleLoaded = FALSE;
       11:  739:   IsRamDiskFile = FALSE;
       11:  740:   ActualLoadFile = NULL;
       11:  741:   LibSlotPtr = NULL;
       11:  742:   FunctionPointer = NULL;
       11:  743:   ModuleId = 0;
       11:  744:   Status = CFE_ES_ERR_LOAD_LIB;    /* error that will be returned if no slots found */
       11:  745:   CFE_ES_LockSharedData(__func__,__LINE__);
      111:  746:   for ( CheckSlot = 0; CheckSlot < CFE_PLATFORM_ES_MAX_LIBRARIES; CheckSlot++ )
        -:  747:   {
      101:  748:      if (CFE_ES_Global.LibTable[CheckSlot].RecordUsed)
        -:  749:      {
       11:  750:          if (strcmp(CFE_ES_Global.LibTable[CheckSlot].LibName, LibName) == 0)
        -:  751:          {
        -:  752:              /*
        -:  753:               * Indicate to caller that the library is already loaded.
        -:  754:               * (This is when there was a matching LibName in the table)
        -:  755:               *
        -:  756:               * Do nothing more; not logging this event as it may or may
        -:  757:               * not be an error.
        -:  758:               */
        1:  759:              *LibraryIdPtr = CheckSlot;
        1:  760:              Status = CFE_ES_LIB_ALREADY_LOADED;
        1:  761:              break;
        -:  762:          }
        -:  763:      }
       90:  764:      else if (LibSlotPtr == NULL)
        -:  765:      {
        -:  766:         /* Remember list position as possible place for new entry. */
        9:  767:          LibSlotPtr = &CFE_ES_Global.LibTable[CheckSlot];
        9:  768:          *LibraryIdPtr = CheckSlot;
        9:  769:          Status = CFE_SUCCESS;
        -:  770:      }
        -:  771:      else
        -:  772:      {
        -:  773:         /* No action */
        -:  774:      }
        -:  775:   }
        -:  776:
       11:  777:   if (Status == CFE_SUCCESS)
        -:  778:   {
        -:  779:       /* reserve the slot while still under lock */
        9:  780:       strcpy(LibSlotPtr->LibName, LibName);
        9:  781:       LibSlotPtr->RecordUsed = TRUE;
        -:  782:   }
        -:  783:
       11:  784:   CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  785:
        -:  786:   /*
        -:  787:    * If any off-nominal condition exists, skip the rest of this logic.
        -:  788:    * Additionally write any extra information about what happened to syslog
        -:  789:    * Note - not logging "already loaded" conditions, as this is not necessarily an error.
        -:  790:    */
       11:  791:   if (Status != CFE_SUCCESS)
        -:  792:   {
        2:  793:       if (Status == CFE_ES_ERR_LOAD_LIB)
        -:  794:       {
        1:  795:           CFE_ES_WriteToSysLog("ES Startup: No free library slots available\n");
        -:  796:       }
        -:  797:
        2:  798:       return Status;
        -:  799:   }
        -:  800:
        -:  801:   /*
        -:  802:    * -------------------
        -:  803:    * IMPORTANT:
        -:  804:    *
        -:  805:    * there is now a reserved entry in the global library table,
        -:  806:    * which must be freed if something goes wrong hereafter.
        -:  807:    *
        -:  808:    * Avoid any inline "return" statements - all paths must proceed to
        -:  809:    * the end of this function where the cleanup will be done.
        -:  810:    *
        -:  811:    * Record sufficient breadcrumbs along the way, such that proper
        -:  812:    * cleanup can be done in case it is necessary.
        -:  813:    * -------------------
        -:  814:    */
        -:  815:
        -:  816:   /*
        -:  817:    * STAGE 1:
        -:  818:    * Figure out what filename to actually load, if a filename was given
        -:  819:    * If the file is compressed, it must be uncompressed to a temp location first and that will be loaded
        -:  820:    *
        -:  821:    * (Note CFE_FS_IsGzFile() handles a NULL filename and properly returns false if NULL)
        -:  822:    */
        9:  823:   if ( ! CFE_FS_IsGzFile(FileName) )
        -:  824:   {
        -:  825:       /*
        -:  826:       ** Not compressed - Load the library module directly
        -:  827:       */
        6:  828:       ActualLoadFile = FileName;
        -:  829:   }
        -:  830:   else
        -:  831:   {
        -:  832:       /*
        -:  833:        * Decompress to a temp file, and get that file name.
        -:  834:        * Implemented in a helper function in the File Services subsystem which avoids clutter here.
        -:  835:        */
        3:  836:       Status = CFE_FS_GetUncompressedFile(RamDiskPath, sizeof(RamDiskPath),
        -:  837:               FileName, CFE_PLATFORM_ES_RAM_DISK_MOUNT_STRING);
        3:  838:       if (Status == CFE_SUCCESS)
        -:  839:       {
        2:  840:           IsRamDiskFile = TRUE;
        2:  841:           ActualLoadFile = RamDiskPath;
        -:  842:       }
        -:  843:   }
        -:  844:
        -:  845:   /*
        -:  846:    * STAGE 2:
        -:  847:    * Do the OS_ModuleLoad() if is called for (i.e. ModuleLoadFile is NOT null)
        -:  848:    */
        9:  849:   if (Status == CFE_SUCCESS && ActualLoadFile != NULL)
        -:  850:   {
        8:  851:       Status = OS_ModuleLoad( &ModuleId, LibName, ActualLoadFile );
        8:  852:       if (Status == OS_SUCCESS)
        -:  853:       {
        7:  854:           Status = CFE_SUCCESS; /* just in case CFE_SUCCESS is different than OS_SUCCESS */
        7:  855:           IsModuleLoaded = TRUE;
        -:  856:       }
        -:  857:       else
        -:  858:       {
        -:  859:           /* load not successful.  Note OS errors are better displayed as decimal integers. */
        1:  860:           CFE_ES_WriteToSysLog("ES Startup: Could not load cFE Shared Library: %d\n", (int)Status);
        1:  861:           Status = CFE_ES_ERR_LOAD_LIB;    /* convert OS error to CFE error code */
        -:  862:       }
        -:  863:   }
        -:  864:
        -:  865:   /*
        -:  866:    * STAGE 3:
        -:  867:    * Figure out the Entry point / Initialization function.
        -:  868:    *
        -:  869:    * This depends on whether it is a dynamically loaded or a statically linked library,
        -:  870:    * or it could be omitted altogether for libraries which do not require an init function.
        -:  871:    *
        -:  872:    * For dynamically loaded objects where FileName is non-NULL, the
        -:  873:    * "EntryPointData" is a normal C string (const char *) with the name of the function.
        -:  874:    *
        -:  875:    * If the name of the function is the string "NULL" -- then treat this as no function
        -:  876:    * needed and skip the lookup entirely (this is to support startup scripts where some
        -:  877:    * string must be in the entry point field).
        -:  878:    */
        9:  879:   if (Status == CFE_SUCCESS && EntryPointData != NULL)
        -:  880:   {
        7:  881:       if (FileName == NULL)
        -:  882:       {
        -:  883:           /*
        -:  884:            * Not a dynamic load - library must be statically linked into current exe.
        -:  885:            * In this case the "EntryPointData" has a direct reference to the init function.
        -:  886:            */
        1:  887:           FunctionPointer = ((CFE_ES_AppStaticModuleApi_t *)EntryPointData)->Ptrs.LibInitFunc;
        -:  888:       }
        6:  889:       else if (strcmp(EntryPointData, "NULL") != 0)
        -:  890:       {
        -:  891:           /*
        -:  892:            * If the entry point is explicitly set as NULL,
        -:  893:            * this means the library has no init function - skip the lookup.
        -:  894:            * Otherwise lookup the address of the entry point
        -:  895:            */
        -:  896:           cpuaddr StartAddr;
        -:  897:
        6:  898:           Status = OS_SymbolLookup( &StartAddr, EntryPointData );
        6:  899:           if (Status == OS_SUCCESS)
        -:  900:           {
        5:  901:               Status = CFE_SUCCESS; /* just in case CFE_SUCCESS is different than OS_SUCCESS */
        5:  902:               FunctionPointer = (CFE_ES_LibraryEntryFuncPtr_t)StartAddr;
        -:  903:           }
        -:  904:           else
        -:  905:           {
        -:  906:               /* could not find symbol.  Note OS errors are better displayed as decimal integers */
        1:  907:               CFE_ES_WriteToSysLog("ES Startup: Could not find Library Init symbol:%s. EC = %d\n",
        -:  908:                                      (const char *)EntryPointData, (int)Status);
        1:  909:               Status = CFE_ES_ERR_LOAD_LIB;    /* convert OS error to CFE error code */
        -:  910:           }
        -:  911:       }
        -:  912:   }
        -:  913:
        -:  914:   /*
        -:  915:    * STAGE 4:
        -:  916:    * Call the Initialization function, if one was identified during the previous stage
        -:  917:    */
        9:  918:   if (Status == CFE_SUCCESS && FunctionPointer != NULL)
        -:  919:   {
        -:  920:       /*
        -:  921:       ** Call the library initialization routine
        -:  922:       */
        6:  923:       Status = (*FunctionPointer)(*LibraryIdPtr);
        6:  924:       if (Status != CFE_SUCCESS)
        -:  925:       {
        2:  926:           CFE_ES_WriteToSysLog("ES Startup: Load Shared Library Init Error = 0x%08x\n", (unsigned int)Status);
        -:  927:       }
        -:  928:   }
        -:  929:
        -:  930:   /*
        -:  931:    * LAST STAGE:
        -:  932:    * Do final clean-up
        -:  933:    *
        -:  934:    * If fully successful, then increment the "RegisteredLibs" counter.
        -:  935:    * Otherwise in case of an error, do clean up based on the breadcrumbs
        -:  936:    */
        9:  937:   if(Status == CFE_SUCCESS)
        -:  938:   {
        -:  939:       /* Increment the counter, which needs to be done under lock */
        4:  940:       CFE_ES_LockSharedData(__func__,__LINE__);
        4:  941:       CFE_ES_Global.RegisteredLibs++;
        4:  942:       CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  943:   }
        -:  944:   else
        -:  945:   {
        -:  946:       /*
        -:  947:        * If the above code had loaded a module, then unload it
        -:  948:        */
        5:  949:       if (IsModuleLoaded)
        -:  950:       {
        3:  951:           OS_ModuleUnload( ModuleId );
        -:  952:       }
        -:  953:
        -:  954:       /*
        -:  955:        * If the above code had used a temp file, then remove it
        -:  956:        */
        5:  957:       if ( IsRamDiskFile == TRUE )
        -:  958:       {
        1:  959:           Status = OS_remove(RamDiskPath);
        -:  960:
        1:  961:           if (Status != OS_SUCCESS)
        -:  962:           {
    #####:  963:                CFE_ES_WriteToSysLog("ES Startup: Error removing temp lib RAM disk file, EC = 0x%08X\n",
        -:  964:                                     (unsigned int) Status);
        -:  965:           }
        -:  966:       }
        -:  967:
        -:  968:       /* Release Slot - No need to lock as it is resetting just a single boolean value */
        5:  969:       LibSlotPtr->RecordUsed = FALSE;
        -:  970:   }
        -:  971:
        9:  972:   return(Status);
        -:  973:
        -:  974:} /* End Function */
        -:  975:
        -:  976:/*
        -:  977:**---------------------------------------------------------------------------------------
        -:  978:** Name: CFE_ES_ScanAppTable
        -:  979:**
        -:  980:**   Purpose: This function scans the ES Application table and acts on the changes
        -:  981:**             in application states. This is where the external cFE Applications are
        -:  982:**             restarted, reloaded, or deleted.
        -:  983:**---------------------------------------------------------------------------------------
        -:  984:*/
        8:  985:void CFE_ES_ScanAppTable(void)
        -:  986:{
        -:  987:   uint32 i;
        -:  988:         
        -:  989:   /*
        -:  990:   ** Scan the ES Application table. Skip entries that are:
        -:  991:   **  - Not in use, or 
        -:  992:   **  - cFE Core apps, or
        -:  993:   **  - Currently running
        -:  994:   */
      264:  995:   for ( i = 0; i < CFE_PLATFORM_ES_MAX_APPLICATIONS; i++ )
        -:  996:   {
        -:  997:   
      267:  998:      if ((CFE_ES_Global.AppTable[i].RecordUsed == TRUE) && 
        6:  999:          (CFE_ES_Global.AppTable[i].Type == CFE_ES_AppType_EXTERNAL) && 
        5: 1000:          (CFE_ES_Global.AppTable[i].StateRecord.AppState != CFE_ES_AppState_RUNNING))
        -: 1001:      {
        -: 1002:      
        -: 1003:          /*
        -: 1004:          ** Process the External cFE App according to it's state.
        -: 1005:          */
        4: 1006:          if ( CFE_ES_Global.AppTable[i].StateRecord.AppState == CFE_ES_AppState_WAITING )
        -: 1007:          {
        -: 1008:              /*
        -: 1009:              ** If the timeout value is zero, take the action to delete/restart/reload the app
        -: 1010:              */
        2: 1011:              if ( CFE_ES_Global.AppTable[i].StateRecord.AppTimer <= 0 )
        -: 1012:              {              
        1: 1013:                 CFE_ES_ProcessControlRequest(i);
        -: 1014:              }
        -: 1015:              else
        -: 1016:              {
        -: 1017:                 #ifdef ES_APP_DEBUG
        -: 1018:                    OS_printf("%d..\n",(int)CFE_ES_Global.AppTable[i].StateRecord.AppTimer);
        -: 1019:                 #endif
        1: 1020:                 CFE_ES_Global.AppTable[i].StateRecord.AppTimer --;   
        -: 1021:                                
        -: 1022:              }
        -: 1023:              
        -: 1024:          }
        2: 1025:          else if ( CFE_ES_Global.AppTable[i].StateRecord.AppState == CFE_ES_AppState_STOPPED )
        -: 1026:          {
        -: 1027:              /*
        -: 1028:              ** The App is stopped and ready to get deleted/restarted/reloaded
        -: 1029:              */
        1: 1030:              CFE_ES_ProcessControlRequest(i);
        -: 1031:            
        -: 1032:          } /* end if */
        -: 1033:                       
        -: 1034:      } /* end if */
        -: 1035:
        -: 1036:   } /* end for loop */
        -: 1037:
        8: 1038:} /* End Function */
        -: 1039:
        -: 1040:
        -: 1041:/*
        -: 1042:**---------------------------------------------------------------------------------------
        -: 1043:**   Name: CFE_ES_ProcessControlRequest
        -: 1044:**
        -: 1045:**   Purpose: This function will perform the requested control action for an application.
        -: 1046:**---------------------------------------------------------------------------------------
        -: 1047:*/
       16: 1048:void CFE_ES_ProcessControlRequest(uint32 AppID)
        -: 1049:{
        -: 1050:   
        -: 1051:   int32                   Status;
        -: 1052:   CFE_ES_AppStartParams_t AppStartParams;
        -: 1053:   uint32                  NewAppId;
        -: 1054:   
        -: 1055:   /*
        -: 1056:   ** First get a copy of the Apps Start Parameters
        -: 1057:   */
       16: 1058:   memcpy(&AppStartParams, &(CFE_ES_Global.AppTable[AppID].StartParams), sizeof(CFE_ES_AppStartParams_t));
        -: 1059:   
        -: 1060:   /*
        -: 1061:   ** Now, find out what kind of Application control is being requested
        -: 1062:   */
       16: 1063:   switch ( CFE_ES_Global.AppTable[AppID].StateRecord.AppControlRequest )
        -: 1064:   {
        -: 1065:         
        -: 1066:      case CFE_ES_RunStatus_APP_EXIT:
        -: 1067:         /*
        -: 1068:         ** Kill the app, and dont restart it
        -: 1069:         */
        2: 1070:         Status = CFE_ES_CleanUpApp(AppID);
        -: 1071:
        2: 1072:         if ( Status == CFE_SUCCESS )
        -: 1073:         {
        1: 1074:            CFE_EVS_SendEvent(CFE_ES_EXIT_APP_INF_EID, CFE_EVS_EventType_INFORMATION, 
        -: 1075:                              "Exit Application %s Completed.",AppStartParams.Name);
        -: 1076:         }
        -: 1077:         else
        -: 1078:         {
        1: 1079:            CFE_EVS_SendEvent(CFE_ES_EXIT_APP_ERR_EID, CFE_EVS_EventType_ERROR, 
        -: 1080:                               "Exit Application %s Failed: CleanUpApp Error 0x%08X.",AppStartParams.Name, (unsigned int)Status);
        -: 1081:         }
        2: 1082:         break;
        -: 1083:                
        -: 1084:      case CFE_ES_RunStatus_APP_ERROR:
        -: 1085:         /*
        -: 1086:         ** Kill the app, and dont restart it
        -: 1087:         */
        2: 1088:         Status = CFE_ES_CleanUpApp(AppID);
        -: 1089:
        2: 1090:         if ( Status == CFE_SUCCESS )
        -: 1091:         {         
        1: 1092:            CFE_EVS_SendEvent(CFE_ES_ERREXIT_APP_INF_EID, CFE_EVS_EventType_INFORMATION, 
        -: 1093:                               "Exit Application %s on Error Completed.",AppStartParams.Name);
        -: 1094:         }
        -: 1095:         else
        -: 1096:         {
        1: 1097:            CFE_EVS_SendEvent(CFE_ES_ERREXIT_APP_ERR_EID, CFE_EVS_EventType_ERROR, 
        -: 1098:                              "Exit Application %s on Error Failed: CleanUpApp Error 0x%08X.",AppStartParams.Name, (unsigned int)Status);
        -: 1099:         }
        2: 1100:         break;
        -: 1101:         
        -: 1102:      case CFE_ES_RunStatus_SYS_DELETE:
        -: 1103:         /*
        -: 1104:         ** Kill the app, and dont restart it
        -: 1105:         */
        2: 1106:         Status = CFE_ES_CleanUpApp(AppID);
        -: 1107:
        2: 1108:         if ( Status == CFE_SUCCESS )
        -: 1109:         {         
        1: 1110:            CFE_EVS_SendEvent(CFE_ES_STOP_INF_EID, CFE_EVS_EventType_INFORMATION, 
        -: 1111:                              "Stop Application %s Completed.",AppStartParams.Name);
        -: 1112:         }
        -: 1113:         else
        -: 1114:         {
        1: 1115:            CFE_EVS_SendEvent(CFE_ES_STOP_ERR3_EID, CFE_EVS_EventType_ERROR, 
        -: 1116:                              "Stop Application %s Failed: CleanUpApp Error 0x%08X.",AppStartParams.Name, (unsigned int)Status);
        -: 1117:         }
        2: 1118:         break;
        -: 1119:                                         
        -: 1120:      case CFE_ES_RunStatus_SYS_RESTART:
        -: 1121:         /*
        -: 1122:         ** Kill the app
        -: 1123:         */
        3: 1124:         Status = CFE_ES_CleanUpApp(AppID);
        -: 1125:
        3: 1126:         if ( Status == CFE_SUCCESS )
        -: 1127:         {
        -: 1128:            /*
        -: 1129:            ** And start it back up again
        -: 1130:            */
        4: 1131:            Status = CFE_ES_AppCreate(&NewAppId, (char *)AppStartParams.FileName, 
        -: 1132:                                           (char *)AppStartParams.EntryPoint, 
        -: 1133:                                           (char *)AppStartParams.Name, 
        2: 1134:                                           AppStartParams.Priority, 
        -: 1135:                                           AppStartParams.StackSize, 
        2: 1136:                                           AppStartParams.ExceptionAction);
        -: 1137:                                           
        2: 1138:            if ( Status == CFE_SUCCESS )
        -: 1139:            {
        1: 1140:               CFE_EVS_SendEvent(CFE_ES_RESTART_APP_INF_EID, CFE_EVS_EventType_INFORMATION, 
        -: 1141:                                  "Restart Application %s Completed.", AppStartParams.Name);
        -: 1142:            }
        -: 1143:            else
        -: 1144:            {
        1: 1145:               CFE_EVS_SendEvent(CFE_ES_RESTART_APP_ERR3_EID, CFE_EVS_EventType_ERROR, 
        -: 1146:                                  "Restart Application %s Failed: AppCreate Error 0x%08X.", AppStartParams.Name, (unsigned int)Status);
        -: 1147:            }
        -: 1148:         }
        -: 1149:         else
        -: 1150:         {
        1: 1151:               CFE_EVS_SendEvent(CFE_ES_RESTART_APP_ERR4_EID, CFE_EVS_EventType_ERROR, 
        -: 1152:                                  "Restart Application %s Failed: CleanUpApp Error 0x%08X.", AppStartParams.Name, (unsigned int)Status);
        -: 1153:         }
        3: 1154:         break;
        -: 1155:            
        -: 1156:      case CFE_ES_RunStatus_SYS_RELOAD:
        -: 1157:         /*
        -: 1158:         ** Kill the app
        -: 1159:         */
        3: 1160:         Status = CFE_ES_CleanUpApp(AppID);
        -: 1161:
        3: 1162:         if ( Status == CFE_SUCCESS )
        -: 1163:         {
        -: 1164:            /*
        -: 1165:            ** And start it back up again
        -: 1166:            */
        4: 1167:            Status = CFE_ES_AppCreate(&NewAppId, (char *)AppStartParams.FileName, 
        -: 1168:                                           (char *)AppStartParams.EntryPoint, 
        -: 1169:                                           (char *)AppStartParams.Name, 
        2: 1170:                                           AppStartParams.Priority, 
        -: 1171:                                           AppStartParams.StackSize, 
        2: 1172:                                           AppStartParams.ExceptionAction);
        2: 1173:            if ( Status == CFE_SUCCESS )
        -: 1174:            {
        1: 1175:               CFE_EVS_SendEvent(CFE_ES_RELOAD_APP_INF_EID, CFE_EVS_EventType_INFORMATION, 
        -: 1176:                                  "Reload Application %s Completed.", AppStartParams.Name);
        -: 1177:            }
        -: 1178:            else
        -: 1179:            {
        1: 1180:               CFE_EVS_SendEvent(CFE_ES_RELOAD_APP_ERR3_EID, CFE_EVS_EventType_ERROR, 
        -: 1181:                                  "Reload Application %s Failed: AppCreate Error 0x%08X.", AppStartParams.Name, (unsigned int)Status);
        -: 1182:            }
        -: 1183:         }
        -: 1184:         else
        -: 1185:         {
        1: 1186:            CFE_EVS_SendEvent(CFE_ES_RELOAD_APP_ERR4_EID, CFE_EVS_EventType_ERROR, 
        -: 1187:                              "Reload Application %s Failed: CleanUpApp Error 0x%08X.", AppStartParams.Name, (unsigned int)Status);
        -: 1188:         }
        -: 1189:                                           
        3: 1190:         break;
        -: 1191:                
        -: 1192:      case CFE_ES_RunStatus_SYS_EXCEPTION:
        -: 1193:      
        1: 1194:         CFE_EVS_SendEvent(CFE_ES_PCR_ERR1_EID, CFE_EVS_EventType_ERROR, 
        -: 1195:                            "ES_ProcControlReq: Invalid State (EXCEPTION) Application %s.",
        -: 1196:                             AppStartParams.Name);            
        1: 1197:         break;
        -: 1198:         
        -: 1199:      default:
        -: 1200: 
        3: 1201:         CFE_EVS_SendEvent(CFE_ES_PCR_ERR2_EID, CFE_EVS_EventType_ERROR, 
        -: 1202:                            "ES_ProcControlReq: Unknown State ( %d ) Application %s.",
        -: 1203:                            (int)CFE_ES_Global.AppTable[AppID].StateRecord.AppControlRequest, AppStartParams.Name);
        -: 1204:         break;
        -: 1205:      
        -: 1206:   } 
        -: 1207:   
       16: 1208:} /* End Function */
        -: 1209:
        -: 1210:/*
        -: 1211:**---------------------------------------------------------------------------------------
        -: 1212:**   Name: CFE_ES_CleanUpApp
        -: 1213:**
        -: 1214:**   Purpose: Delete an application by cleaning up all of it's resources.
        -: 1215:**---------------------------------------------------------------------------------------
        -: 1216:*/
       20: 1217:int32 CFE_ES_CleanUpApp(uint32 AppId)
        -: 1218:{
        -: 1219:   uint32    i;
        -: 1220:   int32  Status;
        -: 1221:   uint32 MainTaskId;
       20: 1222:   int32  ReturnCode = CFE_SUCCESS;
        -: 1223:
        -: 1224:   #ifdef ES_APP_DEBUG
        -: 1225:      OS_printf("------------- Starting App Cleanup: AppID = %d -----------\n",AppId);
        -: 1226:      CFE_ES_ListResourcesDebug();
        -: 1227:   #endif
        -: 1228:   
        -: 1229:   /*
        -: 1230:   ** Call the Table Clean up function
        -: 1231:   */
        -: 1232:#ifndef EXCLUDE_CFE_TBL
       20: 1233:   CFE_TBL_CleanUpApp(AppId);
        -: 1234:#endif   
        -: 1235:   /*
        -: 1236:   ** Call the Software Bus clean up function
        -: 1237:   */
       20: 1238:   CFE_SB_CleanUpApp(AppId);
        -: 1239:   
        -: 1240:   /*
        -: 1241:   ** Call the TIME Clean up function
        -: 1242:   */
       20: 1243:   CFE_TIME_CleanUpApp(AppId);
        -: 1244:     
        -: 1245:   /*
        -: 1246:   ** Call the EVS Clean up function
        -: 1247:   */
       20: 1248:   Status = CFE_EVS_CleanUpApp(AppId);
       20: 1249:   if ( Status != CFE_SUCCESS )
        -: 1250:   {
        6: 1251:      CFE_ES_WriteToSysLog("CFE_ES_CleanUpApp: Call to CFE_EVS_CleanUpApp returned Error: 0x%08X\n",(unsigned int)Status);
        6: 1252:      ReturnCode = CFE_ES_APP_CLEANUP_ERR;
        -: 1253:   }
        -: 1254:     
        -: 1255:   
        -: 1256:   /*
        -: 1257:   ** Delete the ES Resources
        -: 1258:   */
       20: 1259:   CFE_ES_LockSharedData(__func__,__LINE__);
        -: 1260:        
        -: 1261:   /*
        -: 1262:   ** Get Main Task ID
        -: 1263:   */
       20: 1264:   MainTaskId = CFE_ES_Global.AppTable[AppId].TaskInfo.MainTaskId;   
        -: 1265:
        -: 1266:   /*
        -: 1267:   ** Delete all of the OS resources, close files, and delete the main task
        -: 1268:   */
       20: 1269:   Status = CFE_ES_CleanupTaskResources(MainTaskId);
       20: 1270:   if ( Status != CFE_SUCCESS )
        -: 1271:   {
        3: 1272:      CFE_ES_SysLogWrite_Unsync("CFE_ES_CleanUpApp: CleanUpTaskResources for Task ID:%d returned Error: 0x%08X\n",
        -: 1273:                               (int)MainTaskId, (unsigned int)Status);
        3: 1274:      ReturnCode = CFE_ES_APP_CLEANUP_ERR;
        -: 1275: 
        -: 1276:   }
        -: 1277:
        -: 1278:   /*
        -: 1279:   ** Delete any child tasks associated with this app
        -: 1280:   */
     1300: 1281:   for ( i = 0; i < OS_MAX_TASKS; i++ )
        -: 1282:   {
        -: 1283:      /* delete only CHILD tasks - not the MainTaskId, which is already deleted (above) */
     1287: 1284:      if ((CFE_ES_Global.TaskTable[i].RecordUsed == TRUE) &&
        4: 1285:          (CFE_ES_Global.TaskTable[i].AppId == AppId) &&
        3: 1286:          (CFE_ES_Global.TaskTable[i].TaskId != MainTaskId))
        -: 1287:      {         
        2: 1288:         Status = CFE_ES_CleanupTaskResources(CFE_ES_Global.TaskTable[i].TaskId);
        2: 1289:         if ( Status != CFE_SUCCESS )
        -: 1290:         {
        1: 1291:            CFE_ES_SysLogWrite_Unsync("CFE_ES_CleanUpApp: CleanUpTaskResources for Task ID:%d returned Error: 0x%08X\n",
        -: 1292:                                  (int)i, (unsigned int)Status);
        1: 1293:            ReturnCode = CFE_ES_APP_CLEANUP_ERR;
        -: 1294:         }
        -: 1295:      } /* end if */
        -: 1296:   } /* end for */
        -: 1297:
        -: 1298:   /*
        -: 1299:   ** Remove the app from the AppTable
        -: 1300:   */
       20: 1301:   if ( CFE_ES_Global.AppTable[AppId].Type == CFE_ES_AppType_EXTERNAL )
        -: 1302:   {
        -: 1303:      /*
        -: 1304:      ** Unload the module only if it is an external app
        -: 1305:      */
       18: 1306:      Status = OS_ModuleUnload(CFE_ES_Global.AppTable[AppId].StartParams.ModuleId);
       18: 1307:      if ( Status == OS_ERROR )
        -: 1308:      {
        1: 1309:           CFE_ES_SysLogWrite_Unsync("CFE_ES_CleanUpApp: Module (ID:0x%08X) Unload failed. RC=0x%08X\n",
        -: 1310:                                 (unsigned int)CFE_ES_Global.AppTable[AppId].StartParams.ModuleId, (unsigned int)Status);
        1: 1311:           ReturnCode = CFE_ES_APP_CLEANUP_ERR;
        -: 1312:      }
       18: 1313:      CFE_ES_Global.RegisteredExternalApps--;
        -: 1314:   }
        -: 1315:      
       20: 1316:   CFE_ES_Global.AppTable[AppId].RecordUsed = FALSE;
        -: 1317:
        -: 1318:    #ifdef ES_APP_DEBUG   
        -: 1319:       OS_TaskDelay(1000);   
        -: 1320:       CFE_ES_ListResourcesDebug();
        -: 1321:       printf("--------- Finished CFE_ES_CleanUpApp-------------\n");
        -: 1322:    #endif 
        -: 1323:
       20: 1324:   CFE_ES_UnlockSharedData(__func__,__LINE__);
        -: 1325:    
       20: 1326:   return(ReturnCode);
        -: 1327:   
        -: 1328:} /* end function */
        -: 1329:
        -: 1330:
        -: 1331:/*
        -: 1332: * Better methods to find OSAL resources associated with a task
        -: 1333: * have been added in the updated version of OSAL.  Instead of just
        -: 1334: * generating an ID in the range of 0..OS_MAX_<OBJTYPE> and calling
        -: 1335: * OSAL to see if it is valid or not, the OSAL now has a dedicated
        -: 1336: * API to loop through the IDs that _actually are_ valid and call
        -: 1337: * a user-defined function for each one.
        -: 1338: *
        -: 1339: * This is leveraged if a new OSAL is being used, otherwise fall back
        -: 1340: * to assuming that the OSAL ID will be in the range of O..OS_MAX_<OBJTYPE>
        -: 1341: */
        -: 1342:#if defined(OSAL_OPAQUE_OBJECT_IDS)
        -: 1343:
        -: 1344:/*
        -: 1345: * Simple state structure used when cleaning up objects associated with tasks
        -: 1346: *
        -: 1347: * This is used locally between CFE_ES_CleanupTaskResources and the
        -: 1348: * CFE_ES_CountObjectCallback helper function.
        -: 1349: */
        -: 1350:typedef struct
        -: 1351:{
        -: 1352:    uint32 ErrorFlag;
        -: 1353:    uint32 FoundObjects;
        -: 1354:    uint32 PrevFoundObjects;
        -: 1355:    uint32 DeletedObjects;
        -: 1356:    int32  OverallStatus;
        -: 1357:} CFE_ES_CleanupState_t;
        -: 1358:
        -: 1359:/*
        -: 1360:**---------------------------------------------------------------------------------------
        -: 1361:**   Name: CFE_ES_CountObjectCallback
        -: 1362:**
        -: 1363:**   Purpose: Helper function for CFE_ES_ListResourcesDebug to count all objects.
        -: 1364:**
        -: 1365:**   NOTE: This is called while holding the ES global lock
        -: 1366:**---------------------------------------------------------------------------------------
        -: 1367:*/
        -: 1368:void CFE_ES_CleanupObjectCallback(uint32 ObjectId, void *arg)
        -: 1369:{
        -: 1370:    CFE_ES_CleanupState_t   *CleanState;
        -: 1371:    int32                   Status;
        -: 1372:    uint32                  ObjType;
        -: 1373:    osalbool                ObjIsValid;
        -: 1374:
        -: 1375:    CleanState = (CFE_ES_CleanupState_t *)arg;
        -: 1376:    ObjIsValid = TRUE;
        -: 1377:
        -: 1378:    ObjType = OS_IdentifyObject(ObjectId);
        -: 1379:    switch(ObjType)
        -: 1380:    {
        -: 1381:    case OS_OBJECT_TYPE_OS_TASK:
        -: 1382:        Status = OS_TaskDelete(ObjectId);
        -: 1383:        break;
        -: 1384:    case OS_OBJECT_TYPE_OS_QUEUE:
        -: 1385:        Status = OS_QueueDelete(ObjectId);
        -: 1386:        break;
        -: 1387:    case OS_OBJECT_TYPE_OS_BINSEM:
        -: 1388:        Status = OS_BinSemDelete(ObjectId);
        -: 1389:        break;
        -: 1390:    case OS_OBJECT_TYPE_OS_COUNTSEM:
        -: 1391:        Status = OS_CountSemDelete(ObjectId);
        -: 1392:        break;
        -: 1393:    case OS_OBJECT_TYPE_OS_MUTEX:
        -: 1394:        Status = OS_MutSemDelete(ObjectId);
        -: 1395:        break;
        -: 1396:    case OS_OBJECT_TYPE_OS_TIMECB:
        -: 1397:        Status = OS_TimerDelete(ObjectId);
        -: 1398:        break;
        -: 1399:    case OS_OBJECT_TYPE_OS_STREAM:
        -: 1400:        Status = OS_close(ObjectId);
        -: 1401:        break;
        -: 1402:    case OS_OBJECT_TYPE_OS_MODULE:
        -: 1403:        Status = OS_ModuleUnload(ObjectId);
        -: 1404:        break;
        -: 1405:    default:
        -: 1406:        ObjIsValid = FALSE;
        -: 1407:        Status = OS_ERROR;
        -: 1408:        break;
        -: 1409:    }
        -: 1410:
        -: 1411:    if (ObjIsValid)
        -: 1412:    {
        -: 1413:        ++CleanState->FoundObjects;
        -: 1414:        if (Status == OS_SUCCESS)
        -: 1415:        {
        -: 1416:            ++CleanState->DeletedObjects;
        -: 1417:        }
        -: 1418:        else
        -: 1419:        {
        -: 1420:            CFE_ES_SysLogWrite_Unsync("Call to OSAL Delete Object (ID:%d) failed. RC=0x%08X\n",
        -: 1421:                         (int)ObjectId, (unsigned int)Status);
        -: 1422:            if (CleanState->OverallStatus == CFE_SUCCESS)
        -: 1423:            {
        -: 1424:                /*
        -: 1425:                 * Translate any OS failures into the appropriate CFE_ES return codes
        -: 1426:                 * (Some object types have special return codes, depending on what type
        -: 1427:                 * of object failed to delete)
        -: 1428:                 */
        -: 1429:                switch(ObjType)
        -: 1430:                {
        -: 1431:                case OS_OBJECT_TYPE_OS_TASK:
        -: 1432:                    CleanState->OverallStatus = CFE_ES_ERR_CHILD_TASK_DELETE;
        -: 1433:                    break;
        -: 1434:                case OS_OBJECT_TYPE_OS_QUEUE:
        -: 1435:                    CleanState->OverallStatus = CFE_ES_QUEUE_DELETE_ERR;
        -: 1436:                    break;
        -: 1437:                case OS_OBJECT_TYPE_OS_BINSEM:
        -: 1438:                    CleanState->OverallStatus = CFE_ES_BIN_SEM_DELETE_ERR;
        -: 1439:                    break;
        -: 1440:                case OS_OBJECT_TYPE_OS_COUNTSEM:
        -: 1441:                    CleanState->OverallStatus = CFE_ES_COUNT_SEM_DELETE_ERR;
        -: 1442:                    break;
        -: 1443:                case OS_OBJECT_TYPE_OS_MUTEX:
        -: 1444:                    CleanState->OverallStatus = CFE_ES_MUT_SEM_DELETE_ERR;
        -: 1445:                    break;
        -: 1446:                case OS_OBJECT_TYPE_OS_TIMECB:
        -: 1447:                    CleanState->OverallStatus = CFE_ES_TIMER_DELETE_ERR;
        -: 1448:                    break;
        -: 1449:                default:
        -: 1450:                    /* generic failure */
        -: 1451:                    CleanState->OverallStatus = CFE_ES_APP_CLEANUP_ERR;
        -: 1452:                    break;
        -: 1453:                }
        -: 1454:            }
        -: 1455:        }
        -: 1456:    }
        -: 1457:}
        -: 1458:
        -: 1459:/*
        -: 1460:**---------------------------------------------------------------------------------------
        -: 1461:**   Name: CFE_ES_CleanupTaskResources
        -: 1462:**
        -: 1463:**   Purpose: Clean up the OS resources associated with an individual Task
        -: 1464:**---------------------------------------------------------------------------------------
        -: 1465:*/
        -: 1466:int32 CFE_ES_CleanupTaskResources(uint32 TaskId)
        -: 1467:{
        -: 1468:    CFE_ES_CleanupState_t   CleanState;
        -: 1469:    int32                   Result;
        -: 1470:
        -: 1471:    /*
        -: 1472:    ** Delete all OSAL resources that belong to this task
        -: 1473:    */
        -: 1474:    memset(&CleanState, 0, sizeof(CleanState));
        -: 1475:    --CleanState.PrevFoundObjects;
        -: 1476:    while (1)
        -: 1477:    {
        -: 1478:        OS_ForEachObject (TaskId, CFE_ES_CleanupObjectCallback, &CleanState);
        -: 1479:        if (CleanState.FoundObjects == 0 || CleanState.ErrorFlag != 0)
        -: 1480:        {
        -: 1481:            break;
        -: 1482:        }
        -: 1483:        /*
        -: 1484:         * The number of found objects should show a downward trend,
        -: 1485:         * if not, then stop and do not loop here forever.  (This can
        -: 1486:         * happen when using the UT stub functions, or if an object
        -: 1487:         * cannot be fully deleted successfully).
        -: 1488:         */
        -: 1489:        CleanState.ErrorFlag = (CleanState.DeletedObjects == 0 ||
        -: 1490:                CleanState.FoundObjects >= CleanState.PrevFoundObjects);
        -: 1491:        CleanState.PrevFoundObjects = CleanState.FoundObjects;
        -: 1492:        CleanState.FoundObjects = 0;
        -: 1493:        CleanState.DeletedObjects = 0;
        -: 1494:    }
        -: 1495:
        -: 1496:    /*
        -: 1497:    ** Delete the task itself
        -: 1498:    */
        -: 1499:    Result = OS_TaskDelete(TaskId);
        -: 1500:    if (Result == OS_SUCCESS)
        -: 1501:    {
        -: 1502:        Result = CleanState.OverallStatus;
        -: 1503:        if (Result == CFE_SUCCESS && CleanState.FoundObjects > 0)
        -: 1504:        {
        -: 1505:            /* Objects leftover after cleanup -- resource leak */
        -: 1506:            Result = CFE_ES_APP_CLEANUP_ERR;
        -: 1507:        }
        -: 1508:    }
        -: 1509:    else
        -: 1510:    {
        -: 1511:        Result = CFE_ES_TASK_DELETE_ERR;
        -: 1512:    }
        -: 1513:
        -: 1514:    /*
        -: 1515:    ** Invalidate ES Task Table entry
        -: 1516:    */
        -: 1517:    if (OS_ConvertToArrayIndex(TaskId, &TaskId) == OS_SUCCESS)
        -: 1518:    {
        -: 1519:       CFE_ES_Global.TaskTable[TaskId].RecordUsed = FALSE;
        -: 1520:    }
        -: 1521:
        -: 1522:    CFE_ES_Global.RegisteredTasks--;
        -: 1523:    return(Result);
        -: 1524:
        -: 1525:}
        -: 1526:
        -: 1527:/*
        -: 1528:**---------------------------------------------------------------------------------------
        -: 1529:**   Name: CFE_ES_CountObjectCallback
        -: 1530:**
        -: 1531:**   Purpose: Helper function for CFE_ES_ListResourcesDebug to count all objects.
        -: 1532:**---------------------------------------------------------------------------------------
        -: 1533:*/
        -: 1534:void CFE_ES_CountObjectCallback(uint32 ObjectId, void *arg)
        -: 1535:{
        -: 1536:    uint32                 *CountState;
        -: 1537:    uint32                 idtype;
        -: 1538:
        -: 1539:    CountState = (uint32 *)arg;
        -: 1540:    idtype = OS_IdentifyObject(ObjectId);
        -: 1541:    if (idtype < OS_OBJECT_TYPE_USER)
        -: 1542:    {
        -: 1543:        ++CountState[idtype];
        -: 1544:    }
        -: 1545:}
        -: 1546:
        -: 1547:
        -: 1548:/*
        -: 1549:**---------------------------------------------------------------------------------------
        -: 1550:**   Name: CFE_ES_ListResourcesDebug
        -: 1551:**
        -: 1552:**   Purpose: List the resources.
        -: 1553:**---------------------------------------------------------------------------------------
        -: 1554:*/
        -: 1555:int32 CFE_ES_ListResourcesDebug(void)
        -: 1556:{
        -: 1557:    uint32   CountState[OS_OBJECT_TYPE_USER];
        -: 1558:
        -: 1559:    memset(CountState,0,sizeof(CountState));
        -: 1560:    OS_ForEachObject (0, CFE_ES_CountObjectCallback, CountState);
        -: 1561:
        -: 1562:    OS_printf("OS Resources in Use:\n");
        -: 1563:    OS_printf("Number of Tasks: %d\n", (int) CountState[OS_OBJECT_TYPE_OS_TASK]);
        -: 1564:    OS_printf("Number of Queues: %d\n", (int) CountState[OS_OBJECT_TYPE_OS_QUEUE]);
        -: 1565:    OS_printf("Number of Counting Semaphores: %d\n",(int) CountState[OS_OBJECT_TYPE_OS_COUNTSEM]);
        -: 1566:    OS_printf("Number of Binary Semaphores: %d\n",(int) CountState[OS_OBJECT_TYPE_OS_BINSEM]);
        -: 1567:    OS_printf("Number of Mutexes: %d\n", (int) CountState[OS_OBJECT_TYPE_OS_MUTEX]);
        -: 1568:    OS_printf("Number of Open Files: %d\n",(int) CountState[OS_OBJECT_TYPE_OS_STREAM]);
        -: 1569:
        -: 1570:    return CFE_SUCCESS;
        -: 1571:
        -: 1572:}
        -: 1573:
        -: 1574:
        -: 1575:#else  /* Implementation for old versions of OSAL where object IDs are always zero based */
        -: 1576:
        -: 1577:
        -: 1578:/*
        -: 1579:**---------------------------------------------------------------------------------------
        -: 1580:**   Name: CFE_ES_CleanupTaskResources
        -: 1581:**
        -: 1582:**   Purpose: Clean up the OS resources associated with an individual Task
        -: 1583:**
        -: 1584:**   NOTE: This is called while holding the ES global lock
        -: 1585:**---------------------------------------------------------------------------------------
        -: 1586:*/
       31: 1587:int32 CFE_ES_CleanupTaskResources(uint32 TaskId)
        -: 1588:{
        -: 1589:    OS_queue_prop_t         QueueProp;
        -: 1590:    OS_timer_prop_t         TimerProp;
        -: 1591:    OS_bin_sem_prop_t       SemProp;
        -: 1592:    OS_count_sem_prop_t     CountSemProp;
        -: 1593:    OS_mut_sem_prop_t       MutProp;
        -: 1594:    OS_FDTableEntry         FileProp;
        -: 1595:    
        -: 1596:    int32                   Status;
        -: 1597:    
       31: 1598:    int32 Result = CFE_SUCCESS;
        -: 1599:    uint32 i;
        -: 1600:
        -: 1601:    /*
        -: 1602:    ** Delete Mutexes that belong to this task
        -: 1603:    */
      651: 1604:    for ( i= 0; i < OS_MAX_MUTEXES; i++)
        -: 1605:    {
      620: 1606:        if (OS_MutSemGetInfo(i, &MutProp) == OS_SUCCESS)
        -: 1607:        {
      619: 1608:            if ( MutProp.creator == TaskId )
        -: 1609:            {
        -: 1610:               #ifdef ES_APP_DEBUG   
        -: 1611:                 OS_printf("Found a Mutex that belongs to Task %d\n", TaskId);
        -: 1612:               #endif
        -: 1613:               
        -: 1614:               /*
        -: 1615:               ** Delete it
        -: 1616:               */
      239: 1617:               Status = OS_MutSemDelete(i);
      239: 1618:               if ( Status != OS_SUCCESS )
        -: 1619:               {
        2: 1620:                  CFE_ES_SysLogWrite_Unsync("Call to OS_MutSemDelete (ID:%d) failed. RC=0x%08X\n",
        -: 1621:                        (int)i, (unsigned int)Status);
        2: 1622:                  Result = CFE_ES_MUT_SEM_DELETE_ERR;
        -: 1623:               }
        -: 1624:               
        -: 1625:            }            
        -: 1626:        }
        -: 1627:    }
        -: 1628:
        -: 1629:    /*
        -: 1630:    ** Delete Binary Semaphores that belong to this task
        -: 1631:    */
      651: 1632:    for ( i= 0; i < OS_MAX_BIN_SEMAPHORES; i++)
        -: 1633:    {
      620: 1634:        if (OS_BinSemGetInfo(i, &SemProp) == OS_SUCCESS)
        -: 1635:        {
      619: 1636:           if(SemProp.creator == TaskId )
        -: 1637:           {
        -: 1638:               #ifdef ES_APP_DEBUG   
        -: 1639:                 OS_printf("Found a Bin Semaphore that belongs to Task %d\n", TaskId);
        -: 1640:               #endif
        -: 1641:              /*
        -: 1642:              ** Delete it
        -: 1643:              */
      239: 1644:              Status = OS_BinSemDelete(i);
      239: 1645:               if ( Status != OS_SUCCESS )
        -: 1646:               {
        1: 1647:                  CFE_ES_SysLogWrite_Unsync("Call to OS_BinSemDelete (ID:%d) failed. RC=0x%08X\n",
        -: 1648:                        (int)i, (unsigned int)Status);
        1: 1649:                  Result = CFE_ES_BIN_SEM_DELETE_ERR;
        -: 1650:
        -: 1651:               }
        -: 1652:
        -: 1653:           }
        -: 1654:         
        -: 1655:        }
        -: 1656:    }
        -: 1657:
        -: 1658:    /*
        -: 1659:    ** Delete Counting Semaphores that belong to this task
        -: 1660:    */
      651: 1661:    for ( i= 0; i < OS_MAX_COUNT_SEMAPHORES; i++)
        -: 1662:    {
      620: 1663:       if (OS_CountSemGetInfo(i, &CountSemProp) == OS_SUCCESS)
        -: 1664:        {
      619: 1665:           if(CountSemProp.creator == TaskId )
        -: 1666:           {
        -: 1667:               #ifdef ES_APP_DEBUG   
        -: 1668:                 OS_printf("Found a Counting Semaphore that belongs to Task %d\n", TaskId);
        -: 1669:               #endif
        -: 1670:              /*
        -: 1671:              ** Delete it
        -: 1672:              */
      239: 1673:              Status = OS_CountSemDelete(i);
      239: 1674:               if ( Status != OS_SUCCESS )
        -: 1675:               {
        1: 1676:                  CFE_ES_SysLogWrite_Unsync("Call to OS_CountSemDelete (ID:%d) failed. RC=0x%08X\n",
        -: 1677:                        (int)i, (unsigned int)Status);
        1: 1678:                  Result = CFE_ES_COUNT_SEM_DELETE_ERR;
        -: 1679:
        -: 1680:               }
        -: 1681:
        -: 1682:           }
        -: 1683:        }
        -: 1684:    }
        -: 1685:
        -: 1686:
        -: 1687:    /*
        -: 1688:    ** Delete Queues that belong to this task
        -: 1689:    */
     2015: 1690:    for ( i= 0; i < OS_MAX_QUEUES; i++)
        -: 1691:    {
     1984: 1692:        if (OS_QueueGetInfo(i, &QueueProp) == OS_SUCCESS)
        -: 1693:        {
     1983: 1694:           if(QueueProp.creator == TaskId )
        -: 1695:           {
        -: 1696:               #ifdef ES_APP_DEBUG   
        -: 1697:                 OS_printf("Found a Queue that belongs to Task %d\n", TaskId);
        -: 1698:               #endif
        -: 1699:              /*
        -: 1700:              ** Delete it
        -: 1701:              */
      767: 1702:              Status = OS_QueueDelete(i);
      767: 1703:               if ( Status == OS_ERROR )
        -: 1704:               {
        1: 1705:                  CFE_ES_SysLogWrite_Unsync("Call to OS_QueueDelete (ID:%d) failed. RC=0x%08X\n",
        -: 1706:                        (int)i, (unsigned int)Status);
        1: 1707:                  Result = CFE_ES_QUEUE_DELETE_ERR;
        -: 1708:
        -: 1709:               }
        -: 1710:
        -: 1711:           }
        -: 1712:        }
        -: 1713:    }
        -: 1714:
        -: 1715:    /*
        -: 1716:    ** Delete Timers that belong to this task
        -: 1717:    */
      186: 1718:    for ( i= 0; i < OS_MAX_TIMERS; i++)
        -: 1719:    {
      155: 1720:        if (OS_TimerGetInfo(i, &TimerProp) == OS_SUCCESS)
        -: 1721:        {
      151: 1722:           if(TimerProp.creator == TaskId )
        -: 1723:           {
        -: 1724:               #ifdef ES_APP_DEBUG   
        -: 1725:                 OS_printf("Found a Timer that belongs to Task %d\n", TaskId);
        -: 1726:               #endif
        -: 1727:              /*
        -: 1728:              ** Delete it
        -: 1729:              */
       56: 1730:              Status = OS_TimerDelete(i);
       56: 1731:               if ( Status != OS_SUCCESS )
        -: 1732:               {
        1: 1733:                  CFE_ES_SysLogWrite_Unsync("Call to OS_TimerDelete (ID:%d) failed. RC=0x%08X\n",
        -: 1734:                        (int)i, (unsigned int)Status);
        1: 1735:                  Result = CFE_ES_TIMER_DELETE_ERR;
        -: 1736:
        -: 1737:               }
        -: 1738:
        -: 1739:           }
        -: 1740:        }
        -: 1741:    }
        -: 1742:
        -: 1743:    /*
        -: 1744:    ** Close files that belong to this task
        -: 1745:    */
     1581: 1746:    for ( i= 0; i < OS_MAX_NUM_OPEN_FILES; i++)
        -: 1747:    {
     1550: 1748:        if (OS_FDGetInfo(i, &FileProp) == OS_FS_SUCCESS)
        -: 1749:        {
     1549: 1750:           if(FileProp.User == TaskId )
        -: 1751:           {
        -: 1752:               #ifdef ES_APP_DEBUG   
        -: 1753:                 OS_printf("Found an open File that belongs to Task %d\n", TaskId);
        -: 1754:               #endif
        -: 1755:              /*
        -: 1756:              ** Close it
        -: 1757:              */
      599: 1758:              Status = OS_close(i);
      599: 1759:               if ( Status < OS_FS_SUCCESS )
        -: 1760:               {
       50: 1761:                  CFE_ES_SysLogWrite_Unsync("Call to OS_close (FD:%d) failed. RC=0x%08X\n",
        -: 1762:                        (int)i, (unsigned int)Status);
       50: 1763:                  Result = CFE_ES_FILE_CLOSE_ERR;
        -: 1764:               }
        -: 1765:
        -: 1766:           }
        -: 1767:        }
        -: 1768:    }
        -: 1769:
        -: 1770:    /*
        -: 1771:    ** Delete the task
        -: 1772:    */
       31: 1773:    Status = OS_TaskDelete(TaskId);
       31: 1774:    if ( Status < OS_FS_SUCCESS )
        -: 1775:    {
        4: 1776:       CFE_ES_SysLogWrite_Unsync("Call to OS_TaskDelete (TaskID:%d) failed. RC=0x%08X\n",
        -: 1777:             (int)TaskId, (unsigned int)Status);
        4: 1778:       Result = CFE_ES_TASK_DELETE_ERR;
        -: 1779:    }
        -: 1780:    
        -: 1781:    /*
        -: 1782:    ** Invalidate ES Task Table entry
        -: 1783:    */
       31: 1784:    CFE_ES_Global.TaskTable[TaskId].RecordUsed = FALSE;
       31: 1785:    CFE_ES_Global.RegisteredTasks--;
        -: 1786:    
       31: 1787:    return(Result);
        -: 1788:
        -: 1789:}
        -: 1790:
        -: 1791:
        -: 1792:/*
        -: 1793:**---------------------------------------------------------------------------------------
        -: 1794:**   Name: CFE_ES_ListResourcesDebug
        -: 1795:**
        -: 1796:**   Purpose: List the resources.
        -: 1797:**---------------------------------------------------------------------------------------
        -: 1798:*/
        2: 1799:int32 CFE_ES_ListResourcesDebug(void)
        -: 1800:{
        -: 1801:    OS_task_prop_t        TaskProp;
        -: 1802:    OS_queue_prop_t       QueueProp;
        -: 1803:    OS_bin_sem_prop_t     SemProp;
        -: 1804:    OS_count_sem_prop_t   CountSemProp;
        -: 1805:    OS_mut_sem_prop_t     MutProp;
        -: 1806:    OS_FDTableEntry       FileProp;
        2: 1807:    int32                 NumSemaphores = 0;
        2: 1808:    int32                 NumCountSems =0;
        2: 1809:    int32                 NumMutexes = 0;
        2: 1810:    int32                 NumQueues = 0;
        2: 1811:    int32                 NumTasks = 0;
        2: 1812:    int32                 NumFiles = 0;
        -: 1813:    uint32                i;
        -: 1814:
        2: 1815:    OS_printf("OS Resources in Use:\n");
        -: 1816:
      130: 1817:    for ( i= 0; i < OS_MAX_TASKS; i++)
        -: 1818:    {
      128: 1819:        if (OS_TaskGetInfo(i, &TaskProp) == OS_SUCCESS)
        -: 1820:        {
      127: 1821:            NumTasks++;
        -: 1822:        }
        -: 1823:    }
        2: 1824:    OS_printf("Number of Tasks: %d\n", (int) NumTasks);
        -: 1825:
      130: 1826:    for ( i= 0; i < OS_MAX_QUEUES; i++)
        -: 1827:    {
      128: 1828:        if (OS_QueueGetInfo(i, &QueueProp) == OS_SUCCESS)
        -: 1829:        {
      127: 1830:            NumQueues++;
        -: 1831:        }
        -: 1832:    }
        2: 1833:    OS_printf("Number of Queues: %d\n", (int) NumQueues);
        -: 1834:
        -: 1835:
       42: 1836:    for ( i= 0; i < OS_MAX_COUNT_SEMAPHORES; i++)
        -: 1837:    {
       40: 1838:       if (OS_CountSemGetInfo(i, &CountSemProp) == OS_SUCCESS)
        -: 1839:        {
       39: 1840:            NumCountSems++;
        -: 1841:        }
        -: 1842:    }
        2: 1843:    OS_printf("Number of Counting Semaphores: %d\n",(int) NumCountSems);
        -: 1844:    
        -: 1845:    
       42: 1846:    for ( i= 0; i < OS_MAX_BIN_SEMAPHORES; i++)
        -: 1847:    {
       40: 1848:        if (OS_BinSemGetInfo(i, &SemProp) == OS_SUCCESS)
        -: 1849:        {
       39: 1850:            NumSemaphores++;
        -: 1851:        }
        -: 1852:    }
        2: 1853:    OS_printf("Number of Binary Semaphores: %d\n",(int) NumSemaphores);
        -: 1854:
        -: 1855:
       42: 1856:    for ( i= 0; i < OS_MAX_MUTEXES; i++)
        -: 1857:    {
       40: 1858:        if (OS_MutSemGetInfo(i, &MutProp) == OS_SUCCESS)
        -: 1859:        {
       39: 1860:            NumMutexes++;
        -: 1861:        }
        -: 1862:    }
        2: 1863:    OS_printf("Number of Mutexes: %d\n", (int) NumMutexes);
        -: 1864:
      102: 1865:    for ( i= 0; i < OS_MAX_NUM_OPEN_FILES; i++)
        -: 1866:    {
      100: 1867:        if (OS_FDGetInfo(i, &FileProp) == OS_FS_SUCCESS)
        -: 1868:        {
       99: 1869:            NumFiles++;
        -: 1870:        }
        -: 1871:    }
        2: 1872:    OS_printf("Number of Open Files: %d\n",(int) NumFiles);
        -: 1873:
        2: 1874:    return CFE_SUCCESS;
        -: 1875:
        -: 1876:}
        -: 1877:
        -: 1878:#endif
        -: 1879:
        -: 1880:/*
        -: 1881:**---------------------------------------------------------------------------------------
        -: 1882:**   Name: CFE_ES_GetAppInfoInternal
        -: 1883:**
        -: 1884:**   Purpose: Populate the cFE_ES_AppInfo structure with the data for an app.
        -: 1885:**---------------------------------------------------------------------------------------
        -: 1886:*/
        6: 1887:void CFE_ES_GetAppInfoInternal(uint32 AppId, CFE_ES_AppInfo_t *AppInfoPtr )
        -: 1888:{
        -: 1889:
        -: 1890:   int32              ReturnCode;
        -: 1891:   OS_module_record_t ModuleInfo;
        -: 1892:   uint32             TaskIndex;
        -: 1893:   
        -: 1894:   
        6: 1895:   CFE_ES_LockSharedData(__func__,__LINE__);
        -: 1896:
        6: 1897:   AppInfoPtr->AppId = AppId;
        6: 1898:   AppInfoPtr->Type = CFE_ES_Global.AppTable[AppId].Type;
        6: 1899:   strncpy((char *)AppInfoPtr->Name, (char *)CFE_ES_Global.AppTable[AppId].StartParams.Name, OS_MAX_API_NAME);
        6: 1900:   AppInfoPtr->Name[OS_MAX_API_NAME - 1] = '\0';
        -: 1901:
        6: 1902:   strncpy((char *)AppInfoPtr->EntryPoint, (char *)CFE_ES_Global.AppTable[AppId].StartParams.EntryPoint, OS_MAX_API_NAME);
        6: 1903:   AppInfoPtr->EntryPoint[OS_MAX_API_NAME - 1] = '\0';
        -: 1904:   
        6: 1905:   strncpy((char *)AppInfoPtr->FileName, (char *)CFE_ES_Global.AppTable[AppId].StartParams.FileName, OS_MAX_PATH_LEN);
        6: 1906:   AppInfoPtr->FileName[OS_MAX_PATH_LEN - 1] = '\0';
        -: 1907:   
        6: 1908:   AppInfoPtr->ModuleId = CFE_ES_Global.AppTable[AppId].StartParams.ModuleId;
        6: 1909:   AppInfoPtr->StackSize = CFE_ES_Global.AppTable[AppId].StartParams.StackSize;
        6: 1910:   CFE_SB_SET_MEMADDR(AppInfoPtr->StartAddress, CFE_ES_Global.AppTable[AppId].StartParams.StartAddress);
        6: 1911:   AppInfoPtr->ExceptionAction = CFE_ES_Global.AppTable[AppId].StartParams.ExceptionAction;
        6: 1912:   AppInfoPtr->Priority = CFE_ES_Global.AppTable[AppId].StartParams.Priority;
        -: 1913: 
        6: 1914:   AppInfoPtr->MainTaskId = CFE_ES_Global.AppTable[AppId].TaskInfo.MainTaskId;   
        6: 1915:   strncpy((char *)AppInfoPtr->MainTaskName, (char *)CFE_ES_Global.AppTable[AppId].TaskInfo.MainTaskName, OS_MAX_API_NAME);
        6: 1916:   AppInfoPtr->MainTaskName[OS_MAX_API_NAME - 1] = '\0';
        6: 1917:   AppInfoPtr->NumOfChildTasks = CFE_ES_Global.AppTable[AppId].TaskInfo.NumOfChildTasks;
        -: 1918:
        -: 1919:   /*
        -: 1920:   ** Get the execution counter for the main task
        -: 1921:   */
        6: 1922:   if (OS_ConvertToArrayIndex(AppInfoPtr->MainTaskId, &TaskIndex) == OS_SUCCESS)
        -: 1923:   {
        6: 1924:      AppInfoPtr->ExecutionCounter = CFE_ES_Global.TaskTable[TaskIndex].ExecutionCounter;
        -: 1925:   }
        -: 1926:
        -: 1927:   /* 
        -: 1928:   ** Get the address information from the OSAL
        -: 1929:   */
        6: 1930:   ReturnCode = OS_ModuleInfo ( AppInfoPtr->ModuleId, &ModuleInfo );
        6: 1931:   if ( ReturnCode == OS_SUCCESS )
        -: 1932:   {
        5: 1933:      AppInfoPtr->AddressesAreValid = ModuleInfo.addr.valid;
        5: 1934:      CFE_SB_SET_MEMADDR(AppInfoPtr->CodeAddress, ModuleInfo.addr.code_address);
        5: 1935:      CFE_SB_SET_MEMADDR(AppInfoPtr->CodeSize, ModuleInfo.addr.code_size);
        5: 1936:      CFE_SB_SET_MEMADDR(AppInfoPtr->DataAddress, ModuleInfo.addr.data_address);
        5: 1937:      CFE_SB_SET_MEMADDR(AppInfoPtr->DataSize, ModuleInfo.addr.data_size);
        5: 1938:      CFE_SB_SET_MEMADDR(AppInfoPtr->BSSAddress, ModuleInfo.addr.bss_address);
        5: 1939:      CFE_SB_SET_MEMADDR(AppInfoPtr->BSSSize, ModuleInfo.addr.bss_size);
        -: 1940:   } 
        -: 1941:   else
        -: 1942:   {
        1: 1943:      AppInfoPtr->AddressesAreValid = FALSE;
        1: 1944:      AppInfoPtr->CodeAddress = 0;
        1: 1945:      AppInfoPtr->CodeSize = 0;
        1: 1946:      AppInfoPtr->DataAddress = 0;
        1: 1947:      AppInfoPtr->DataSize = 0;
        1: 1948:      AppInfoPtr->BSSAddress = 0;
        1: 1949:      AppInfoPtr->BSSSize = 0;
        -: 1950:   }
        -: 1951:   
        -: 1952:
        -: 1953:
        6: 1954:   CFE_ES_UnlockSharedData(__func__,__LINE__);
        -: 1955:
        6: 1956:} /* end function */
        -: 1957:
