        -:    0:Source:/home/mdeschu/cfe-660-ut/cfe/fsw/cfe-core/src/tbl/cfe_tbl_internal.c
        -:    0:Programs:4
        -:    1:/*
        -:    2:** $Id: cfe_tbl_internal.c 1.15 2014/08/22 16:30:24GMT-05:00 lwalling Exp  $
        -:    3:**
        -:    4:**      Copyright (c) 2004-2012, United States government as represented by the 
        -:    5:**      administrator of the National Aeronautics Space Administration.  
        -:    6:**      All rights reserved. This software(cFE) was created at NASA's Goddard 
        -:    7:**      Space Flight Center pursuant to government contracts.
        -:    8:**
        -:    9:**      This is governed by the NASA Open Source Agreement and may be used, 
        -:   10:**      distributed and modified only pursuant to the terms of that agreement.
        -:   11:**  
        -:   12:** Purpose:  cFE Table Services (TBL) utility function source file
        -:   13:**
        -:   14:** Author:   D. Kobe/the Hammers Company, Inc.
        -:   15:**
        -:   16:** Notes:
        -:   17:**
        -:   18:*/
        -:   19:
        -:   20:
        -:   21:/*
        -:   22:** Required header files...
        -:   23:*/
        -:   24:#include "cfe_msgids.h"
        -:   25:#include "cfe_tbl_internal.h"
        -:   26:#include "cfe_tbl_events.h"
        -:   27:#include "cfe_error.h"
        -:   28:#include "cfe_es.h"
        -:   29:#include "cfe_evs.h"
        -:   30:#include "cfe_fs.h"
        -:   31:#include "cfe_psp.h"
        -:   32:#include <stdio.h>
        -:   33:#include <string.h>
        -:   34:
        -:   35:/*******************************************************************
        -:   36:**
        -:   37:** CFE_TBL_EarlyInit
        -:   38:**
        -:   39:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:   40:********************************************************************/
        -:   41:/******************************************************************************
        -:   42:**  Function:  CFE_TBL_EarlyInit()
        -:   43:**
        -:   44:**  Purpose:
        -:   45:**    Initialize the Table Services
        -:   46:**
        -:   47:**  Arguments:
        -:   48:**
        -:   49:**  Notes:
        -:   50:**    This function MUST be called before any TBL API's are called.
        -:   51:**
        -:   52:**  Return:
        -:   53:**    none
        -:   54:*/
       12:   55:int32 CFE_TBL_EarlyInit (void)
        -:   56:{
        -:   57:    uint16 i;
        -:   58:    uint32 j;
        -:   59:    int32 Status;
        -:   60:
        -:   61:
        -:   62:    /* Initialize the Table Registry */
     1548:   63:    for(i=0; i < CFE_PLATFORM_TBL_MAX_NUM_TABLES; i++)
        -:   64:    {
     1536:   65:        CFE_TBL_InitRegistryRecord(&CFE_TBL_TaskData.Registry[i]);
        -:   66:    }
        -:   67:
        -:   68:    /* Initialize the Table Access Descriptors */
     3084:   69:    for (i=0; i<CFE_PLATFORM_TBL_MAX_NUM_HANDLES; i++)
        -:   70:    {
     3072:   71:        CFE_TBL_TaskData.Handles[i].AppId = CFE_ES_ERR_APPID;
     3072:   72:        CFE_TBL_TaskData.Handles[i].RegIndex = 0;
     3072:   73:        CFE_TBL_TaskData.Handles[i].PrevLink = CFE_TBL_END_OF_LIST;
     3072:   74:        CFE_TBL_TaskData.Handles[i].NextLink = CFE_TBL_END_OF_LIST;
     3072:   75:        CFE_TBL_TaskData.Handles[i].UsedFlag = FALSE;
     3072:   76:        CFE_TBL_TaskData.Handles[i].LockFlag = FALSE;
     3072:   77:        CFE_TBL_TaskData.Handles[i].Updated = FALSE;
     3072:   78:        CFE_TBL_TaskData.Handles[i].BufferIndex = 0;
        -:   79:    }
        -:   80:
        -:   81:    /* Initialize the Table Validation Results Records */
      132:   82:    for (i=0; i<CFE_PLATFORM_TBL_MAX_NUM_VALIDATIONS; i++)
        -:   83:    {
      120:   84:        CFE_TBL_TaskData.ValidationResults[i].State = CFE_TBL_VALIDATION_FREE;
      120:   85:        CFE_TBL_TaskData.ValidationResults[i].CrcOfTable = 0;
      120:   86:        CFE_TBL_TaskData.ValidationResults[i].Result = 0;
      120:   87:        CFE_TBL_TaskData.ValidationResults[i].ActiveBuffer = FALSE;
      120:   88:        CFE_TBL_TaskData.ValidationResults[i].TableName[0] = '\0';
        -:   89:    }
        -:   90:
        -:   91:    /* Initialize the Dump-Only Table Dump Control Blocks */
       60:   92:    for (i=0; i<CFE_PLATFORM_TBL_MAX_SIMULTANEOUS_LOADS; i++)
        -:   93:    {
       48:   94:        CFE_TBL_TaskData.DumpControlBlocks[i].State = CFE_TBL_DUMP_FREE;
       48:   95:        CFE_TBL_TaskData.DumpControlBlocks[i].DumpBufferPtr = NULL;
       48:   96:        CFE_TBL_TaskData.DumpControlBlocks[i].Size = 0;
       48:   97:        CFE_TBL_TaskData.DumpControlBlocks[i].TableName[0] = '\0';
        -:   98:        
        -:   99:        /* Prevent Shared Buffers from being used until successfully allocated */
       48:  100:        CFE_TBL_TaskData.LoadBuffs[i].Taken = TRUE;
        -:  101:    }
        -:  102:
       12:  103:    CFE_TBL_TaskData.ValidationCounter = 0;
        -:  104:
       12:  105:    CFE_TBL_TaskData.HkTlmTblRegIndex = CFE_TBL_NOT_FOUND;
       12:  106:    CFE_TBL_TaskData.LastTblUpdated = CFE_TBL_NOT_FOUND;
        -:  107:    
        -:  108:    /*
        -:  109:    ** Create table registry access mutex
        -:  110:    */
       12:  111:    Status = OS_MutSemCreate(&CFE_TBL_TaskData.RegistryMutex,
        -:  112:                              CFE_TBL_MUT_REG_NAME,
        -:  113:                              CFE_TBL_MUT_REG_VALUE);
       12:  114:    if(Status != OS_SUCCESS)
        -:  115:    {
        1:  116:      CFE_ES_WriteToSysLog("CFE_TBL:Registry mutex creation failed! RC=0x%08x\n",(unsigned int)Status);
        1:  117:      return Status;
        -:  118:    }/* end if */                              
        -:  119:
        -:  120:    /*
        -:  121:    ** Create working buffer access mutex
        -:  122:    */
       11:  123:    Status = OS_MutSemCreate(&CFE_TBL_TaskData.WorkBufMutex,
        -:  124:                              CFE_TBL_MUT_WORK_NAME,
        -:  125:                              CFE_TBL_MUT_WORK_VALUE);
       11:  126:    if(Status != OS_SUCCESS)
        -:  127:    {
        1:  128:      CFE_ES_WriteToSysLog("CFE_TBL:Working buffer mutex creation failed! RC=0x%08x\n",(unsigned int)Status);
        1:  129:      return Status;
        -:  130:    }/* end if */
        -:  131:    
        -:  132:    /*
        -:  133:    ** Initialize housekeeping packet (clear user data area)...
        -:  134:    */
       10:  135:    CFE_SB_InitMsg(&CFE_TBL_TaskData.HkPacket,
        -:  136:                    CFE_TBL_HK_TLM_MID,
        -:  137:                    sizeof(CFE_TBL_TaskData.HkPacket), TRUE);
        -:  138:
        -:  139:    /*
        -:  140:    ** Initialize table registry report packet (clear user data area)...
        -:  141:    */
       10:  142:    CFE_SB_InitMsg(&CFE_TBL_TaskData.TblRegPacket,
        -:  143:                    CFE_TBL_REG_TLM_MID,
        -:  144:                    sizeof(CFE_TBL_TaskData.TblRegPacket), TRUE);
        -:  145:
        -:  146:    /* Initialize memory partition and allocate shared table buffers. */
       10:  147:    Status = CFE_ES_PoolCreate(&CFE_TBL_TaskData.Buf.PoolHdl,
        -:  148:                                CFE_TBL_TaskData.Buf.Partition.Data,
        -:  149:                                CFE_PLATFORM_TBL_BUF_MEMORY_BYTES);        
        -:  150:
       10:  151:    if(Status < 0)
        -:  152:    {
        1:  153:        CFE_ES_WriteToSysLog("CFE_TBL:InitBuffers PoolCreate fail Status=0x%X\n", (unsigned int)Status);
        1:  154:        return Status;
        -:  155:    }
        -:  156:    else
        -:  157:    {
        -:  158:        /* Initialize each of the shared load buffers */
        9:  159:        j=0;
        -:  160:        do
        -:  161:        {
        -:  162:            /* Allocate memory for shared load buffers */
       33:  163:            Status = CFE_ES_GetPoolBuf((uint32 **)&CFE_TBL_TaskData.LoadBuffs[j].BufferPtr,
        -:  164:                                       CFE_TBL_TaskData.Buf.PoolHdl,
        -:  165:                                       CFE_PLATFORM_TBL_MAX_SNGL_TABLE_SIZE);
        -:  166:
       33:  167:            if (Status < CFE_PLATFORM_TBL_MAX_SNGL_TABLE_SIZE)
        -:  168:            {
        1:  169:                CFE_ES_WriteToSysLog("CFE_TBL:InitBuffers GetPoolBuf Fail Index=%d, Status=0x%X\n", (int)j, (unsigned int)Status);
        1:  170:                return Status;
        -:  171:            }
        -:  172:            else
        -:  173:            {
        -:  174:                /* The buffer is successfully created, so allow it to be used */
       32:  175:                CFE_TBL_TaskData.LoadBuffs[j].Taken = FALSE;
        -:  176:                
       32:  177:                memset(CFE_TBL_TaskData.LoadBuffs[j].DataSource, 0, OS_MAX_PATH_LEN);
       32:  178:                CFE_TBL_TaskData.LoadBuffs[j].FileCreateTimeSecs = 0;
       32:  179:                CFE_TBL_TaskData.LoadBuffs[j].FileCreateTimeSubSecs = 0;
        -:  180:            }
        -:  181:
       32:  182:            j++;
        -:  183:        } while ((j < CFE_PLATFORM_TBL_MAX_SIMULTANEOUS_LOADS) && 
       32:  184:                 (Status >= CFE_PLATFORM_TBL_MAX_SNGL_TABLE_SIZE));
        -:  185:    }
        -:  186:    
        -:  187:    /* Try to obtain a previous image of the Critical Table Registry from the Critical Data Store */
        8:  188:    Status = CFE_ES_RegisterCDSEx(&CFE_TBL_TaskData.CritRegHandle, 
        -:  189:                                  (sizeof(CFE_TBL_CritRegRec_t)*CFE_PLATFORM_TBL_MAX_CRITICAL_TABLES),
        -:  190:                                  "CFE_TBL.CritReg", TRUE);
        -:  191:                                
        -:  192:    /* Assume for the moment that nothing is already in the CDS and zero out the Critical Table Registry */
      264:  193:    for (i=0; i<CFE_PLATFORM_TBL_MAX_CRITICAL_TABLES; i++)
        -:  194:    {
      256:  195:        CFE_TBL_TaskData.CritReg[i].CDSHandle = CFE_ES_CDS_BAD_HANDLE;
      256:  196:        CFE_TBL_TaskData.CritReg[i].FileCreateTimeSecs = 0;
      256:  197:        CFE_TBL_TaskData.CritReg[i].FileCreateTimeSubSecs = 0;
      256:  198:        CFE_TBL_TaskData.CritReg[i].LastFileLoaded[0] = '\0';
      256:  199:        CFE_TBL_TaskData.CritReg[i].TimeOfLastUpdate.Seconds = 0;
      256:  200:        CFE_TBL_TaskData.CritReg[i].TimeOfLastUpdate.Subseconds = 0;
      256:  201:        CFE_TBL_TaskData.CritReg[i].TableLoadedOnce = FALSE;
        -:  202:
        -:  203:    }
        -:  204:    
        8:  205:    if (Status == CFE_ES_CDS_ALREADY_EXISTS)
        -:  206:    {
        -:  207:        /* Try to recover the Critical Table Registry from the CDS */
        2:  208:        Status = CFE_ES_RestoreFromCDS(CFE_TBL_TaskData.CritReg, CFE_TBL_TaskData.CritRegHandle);
        -:  209:        
        2:  210:        if (Status != CFE_SUCCESS)
        -:  211:        {
        -:  212:            /* Note if we were unable to recover error free Critical Table Registry from the CDS */
        1:  213:            CFE_ES_WriteToSysLog("CFE_TBL:EarlyInit-Failed to recover Critical Table Registry (Err=0x%08X)\n", (unsigned int)Status);
        -:  214:        }
        -:  215:        
        -:  216:        /* Whether we recovered the Critical Table Registry or not, we are successful with initialization */
        2:  217:        Status = CFE_SUCCESS;
        -:  218:    }
        6:  219:    else if (Status != CFE_SUCCESS)
        -:  220:    {
        -:  221:        /* Not being able to support Critical Tables is not the end of the world */
        -:  222:        /* Note the problem and move on */
        1:  223:        CFE_ES_WriteToSysLog("CFE_TBL:EarlyInit-Failed to create Critical Table Registry (Err=0x%08X)\n", (unsigned int)Status);
        -:  224:        
        -:  225:        /* Failure to support critical tables is not a good enough reason to exit the cFE on start up */
        1:  226:        Status = CFE_SUCCESS;
        -:  227:    }
        -:  228:    else
        -:  229:    {
        -:  230:        /* Save the initial version of the Critical Table Registry in the CDS */
        5:  231:        Status = CFE_ES_CopyToCDS(CFE_TBL_TaskData.CritRegHandle, CFE_TBL_TaskData.CritReg);
        -:  232:        
        5:  233:        if (Status != CFE_SUCCESS)
        -:  234:        {
        -:  235:            /* Not being able to support Critical Tables is not the end of the world */
        -:  236:            /* Note the problem and move on */
        1:  237:            CFE_ES_WriteToSysLog("CFE_TBL:EarlyInit-Failed to save Critical Table Registry (Err=0x%08X)\n", (unsigned int)Status);
        -:  238:        
        -:  239:            /* Failure to support critical tables is not a good enough reason to exit the cFE on start up */
        1:  240:            Status = CFE_SUCCESS;
        -:  241:        }
        -:  242:    }
        -:  243:    
        8:  244:    return Status;
        -:  245:            
        -:  246:}/* end CFE_TBL_EarlyInit */
        -:  247:
        -:  248:
        -:  249:/*******************************************************************
        -:  250:**
        -:  251:** CFE_TBL_InitRegistryRecord
        -:  252:**
        -:  253:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  254:********************************************************************/
        -:  255:
        -:  256:
     2075:  257:void CFE_TBL_InitRegistryRecord (CFE_TBL_RegistryRec_t *RegRecPtr)
        -:  258:{
     2075:  259:    RegRecPtr->OwnerAppId = CFE_TBL_NOT_OWNED;
     2075:  260:    RegRecPtr->Size = 0;
     2075:  261:    RegRecPtr->NotificationMsgId = CFE_SB_INVALID_MSG_ID;
     2075:  262:    RegRecPtr->NotificationCC = 0;
     2075:  263:    RegRecPtr->NotificationParam = 0;
     2075:  264:    RegRecPtr->Buffers[0].BufferPtr = NULL;
     2075:  265:    RegRecPtr->Buffers[0].FileCreateTimeSecs = 0;
     2075:  266:    RegRecPtr->Buffers[0].FileCreateTimeSubSecs = 0;
     2075:  267:    RegRecPtr->Buffers[0].Crc = 0;
     2075:  268:    RegRecPtr->Buffers[0].Taken = FALSE;
     2075:  269:    RegRecPtr->Buffers[0].DataSource[0] = '\0';
     2075:  270:    RegRecPtr->Buffers[1].BufferPtr = NULL;
     2075:  271:    RegRecPtr->Buffers[1].FileCreateTimeSecs = 0;
     2075:  272:    RegRecPtr->Buffers[1].FileCreateTimeSubSecs = 0;
     2075:  273:    RegRecPtr->Buffers[1].Crc = 0;
     2075:  274:    RegRecPtr->Buffers[1].Taken = FALSE;
     2075:  275:    RegRecPtr->Buffers[1].DataSource[0] = '\0';
     2075:  276:    RegRecPtr->ValidationFuncPtr = NULL;
     2075:  277:    RegRecPtr->TimeOfLastUpdate.Seconds = 0;
     2075:  278:    RegRecPtr->TimeOfLastUpdate.Subseconds = 0;
     2075:  279:    RegRecPtr->HeadOfAccessList = CFE_TBL_END_OF_LIST;
     2075:  280:    RegRecPtr->LoadInProgress =  CFE_TBL_NO_LOAD_IN_PROGRESS;
     2075:  281:    RegRecPtr->ValidateActiveIndex = CFE_TBL_NO_VALIDATION_PENDING;
     2075:  282:    RegRecPtr->ValidateInactiveIndex = CFE_TBL_NO_VALIDATION_PENDING;
     2075:  283:    RegRecPtr->CDSHandle = CFE_ES_CDS_BAD_HANDLE;
     2075:  284:    RegRecPtr->CriticalTable = FALSE;
     2075:  285:    RegRecPtr->TableLoadedOnce = FALSE;
     2075:  286:    RegRecPtr->LoadPending = FALSE;
     2075:  287:    RegRecPtr->DumpOnly = FALSE;
     2075:  288:    RegRecPtr->DumpControlIndex = CFE_TBL_NO_DUMP_PENDING;
     2075:  289:    RegRecPtr->UserDefAddr = FALSE;
     2075:  290:    RegRecPtr->DoubleBuffered = FALSE;
     2075:  291:    RegRecPtr->NotifyByMsg = FALSE;
     2075:  292:    RegRecPtr->ActiveBufferIndex = 0;
     2075:  293:    RegRecPtr->Name[0] = '\0';
     2075:  294:    RegRecPtr->LastFileLoaded[0] = '\0';
     2075:  295:}
        -:  296:
        -:  297:
        -:  298:/*******************************************************************
        -:  299:**
        -:  300:** CFE_TBL_ValidateHandle
        -:  301:**
        -:  302:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  303:********************************************************************/
        -:  304:
        -:  305:
      109:  306:int32 CFE_TBL_ValidateHandle(CFE_TBL_Handle_t TblHandle)
        -:  307:{
      109:  308:    int32 Status = CFE_SUCCESS;
        -:  309:
        -:  310:    /* Is the handle out of range? */
      109:  311:    if (TblHandle >= CFE_PLATFORM_TBL_MAX_NUM_HANDLES)
        -:  312:    {
        3:  313:        Status = CFE_TBL_ERR_INVALID_HANDLE;
        -:  314:
        3:  315:        CFE_ES_WriteToSysLog("CFE_TBL:ValidateHandle-Table Handle=%d is > %d\n", TblHandle, CFE_PLATFORM_TBL_MAX_NUM_HANDLES);
        -:  316:    }
        -:  317:    else
        -:  318:    {
        -:  319:        /* Check to see if the Handle is no longer valid for this Table */
      106:  320:        if (CFE_TBL_TaskData.Handles[TblHandle].UsedFlag == FALSE)
        -:  321:        {
        2:  322:            Status = CFE_TBL_ERR_INVALID_HANDLE;
        -:  323:
        2:  324:            CFE_ES_WriteToSysLog("CFE_TBL:ValidateHandle-Table Handle=%d is for unused Table Handle\n", TblHandle);
        -:  325:        }
        -:  326:    }
      109:  327:    return Status;
        -:  328:}   /* End of CFE_TBL_ValidateHandle() */
        -:  329:
        -:  330:/*******************************************************************
        -:  331:**
        -:  332:** CFE_TBL_ValidateAppID
        -:  333:**
        -:  334:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  335:********************************************************************/
        -:  336:
      431:  337:int32 CFE_TBL_ValidateAppID(uint32 *AppIdPtr)
        -:  338:{
      431:  339:    int32 Status = CFE_ES_GetAppID(AppIdPtr);
        -:  340:
      431:  341:    if (Status == CFE_SUCCESS)
        -:  342:    {
      426:  343:        if (*AppIdPtr >= CFE_PLATFORM_ES_MAX_APPLICATIONS)
        -:  344:        {
        7:  345:            Status = CFE_TBL_ERR_BAD_APP_ID;
        -:  346:
        7:  347:            CFE_ES_WriteToSysLog("CFE_TBL:ValidateAppID-AppId=%d > Max Apps (%d)\n",
        7:  348:                                 (int)(*AppIdPtr), CFE_PLATFORM_ES_MAX_APPLICATIONS);
        -:  349:        }
        -:  350:    }
        -:  351:    else
        -:  352:    {
        5:  353:        CFE_ES_WriteToSysLog("CFE_TBL:ValidateAppID-GetAppID failed (Stat=0x%08X)\n", (unsigned int)Status);
        -:  354:    }
        -:  355:
      431:  356:    return Status;
        -:  357:}   /* End of CFE_TBL_ValidateAppID() */
        -:  358:
        -:  359:/*******************************************************************
        -:  360:**
        -:  361:** CFE_TBL_ValidateAccess
        -:  362:**
        -:  363:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  364:********************************************************************/
        -:  365:
      103:  366:int32 CFE_TBL_ValidateAccess(CFE_TBL_Handle_t TblHandle, uint32 *AppIdPtr)
        -:  367:{
      103:  368:    int32 Status = CFE_SUCCESS;
        -:  369:
        -:  370:    /* Check to make sure App ID is legit */
      103:  371:    Status = CFE_TBL_ValidateAppID(AppIdPtr);
        -:  372:
      103:  373:    if (Status == CFE_SUCCESS)
        -:  374:    {
        -:  375:        /* Check table handle validity */
       97:  376:        Status = CFE_TBL_ValidateHandle(TblHandle);
        -:  377:
       97:  378:        if (Status == CFE_SUCCESS)
        -:  379:        {
       93:  380:            Status = CFE_TBL_CheckAccessRights(TblHandle, *AppIdPtr);
        -:  381:
       93:  382:            if (Status != CFE_SUCCESS)
        -:  383:            {
        2:  384:                CFE_ES_WriteToSysLog("CFE_TBL:ValidateAccess-App(%d) no access to Tbl Handle=%d (Stat=0x%08X)\n",
        1:  385:                                     (int)(*AppIdPtr), (int)TblHandle, (unsigned int)Status);
        -:  386:            }
        -:  387:        }
        -:  388:        else
        -:  389:        {
        4:  390:            CFE_ES_WriteToSysLog("CFE_TBL:ValidateAccess-Invalid Tbl Handle=%d\n", (int)TblHandle);
        -:  391:        }
        -:  392:    }
        -:  393:    else
        -:  394:    {
        6:  395:        CFE_ES_WriteToSysLog("CFE_TBL:ValidateAccess-Bad AppId=%d\n", (int)(*AppIdPtr));
        -:  396:    }
        -:  397:
      103:  398:    return Status;
        -:  399:}   /* End of CFE_TBL_ValidateAccess() */
        -:  400:
        -:  401:
        -:  402:/*******************************************************************
        -:  403:**
        -:  404:** CFE_TBL_CheckAccessRights
        -:  405:**
        -:  406:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  407:********************************************************************/
        -:  408:
      105:  409:int32 CFE_TBL_CheckAccessRights(CFE_TBL_Handle_t TblHandle, uint32 ThisAppId)
        -:  410:{
      105:  411:    int32 Status = CFE_SUCCESS;
        -:  412:
      105:  413:    if (ThisAppId != CFE_TBL_TaskData.Handles[TblHandle].AppId)
        -:  414:    {
        -:  415:        /* The Table Service Task always has access rights so that tables */
        -:  416:        /* can be manipulated via ground command                          */
        3:  417:        if (ThisAppId != CFE_TBL_TaskData.TableTaskAppId)
        -:  418:        {
        2:  419:            Status = CFE_TBL_ERR_NO_ACCESS;
        -:  420:        }
        -:  421:    }
        -:  422:
      105:  423:    return Status;
        -:  424:}
        -:  425:
        -:  426:/*******************************************************************
        -:  427:**
        -:  428:** CFE_TBL_RemoveAccessLink
        -:  429:**
        -:  430:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  431:********************************************************************/
        -:  432:
       22:  433:int32 CFE_TBL_RemoveAccessLink(CFE_TBL_Handle_t TblHandle)
        -:  434:{
       22:  435:    int32 Status = CFE_SUCCESS;
       22:  436:    CFE_TBL_AccessDescriptor_t *AccessDescPtr = &CFE_TBL_TaskData.Handles[TblHandle];
       22:  437:    CFE_TBL_RegistryRec_t      *RegRecPtr     = &CFE_TBL_TaskData.Registry[AccessDescPtr->RegIndex];
        -:  438:
        -:  439:    /* Lock Access to the table while we modify the linked list */
       22:  440:    CFE_TBL_LockRegistry();
        -:  441:
        -:  442:    /* If we are removing the head of the linked list, then point */
        -:  443:    /* the head pointer to the link after this one                */
       22:  444:    if (AccessDescPtr->PrevLink == CFE_TBL_END_OF_LIST)
        -:  445:    {
       18:  446:        RegRecPtr->HeadOfAccessList = AccessDescPtr->NextLink;
        -:  447:
        -:  448:        /* Update the next link, if there is one, to be the new head of the list */
       18:  449:        if (AccessDescPtr->NextLink != CFE_TBL_END_OF_LIST)
        -:  450:        {
        1:  451:            CFE_TBL_TaskData.Handles[AccessDescPtr->NextLink].PrevLink = CFE_TBL_END_OF_LIST;
        -:  452:        }
        -:  453:    }
        -:  454:    else /* Access Descriptor is not the head of the list */
        -:  455:    {
        -:  456:        /* Set the next link on the previous link to the next link of the link being removed */
        4:  457:        CFE_TBL_TaskData.Handles[AccessDescPtr->PrevLink].NextLink = AccessDescPtr->NextLink;
        -:  458:
        -:  459:        /* If this link is not the end of the list, then complete two way linkage */
        -:  460:        /* by setting the next link's previous link to the previous link of the link being removed */
        4:  461:        if (AccessDescPtr->NextLink != CFE_TBL_END_OF_LIST)
        -:  462:        {
        2:  463:            CFE_TBL_TaskData.Handles[AccessDescPtr->NextLink].PrevLink = AccessDescPtr->PrevLink;
        -:  464:        }
        -:  465:    }
        -:  466:
        -:  467:    /* Return the Access Descriptor to the pool */
       22:  468:    AccessDescPtr->UsedFlag = FALSE;
        -:  469:
        -:  470:    /* If this was the last Access Descriptor for this table, we can free the memory buffers as well */
       22:  471:    if (RegRecPtr->HeadOfAccessList == CFE_TBL_END_OF_LIST)
        -:  472:    {
        -:  473:        /* Only free memory that we have allocated.  If the image is User Defined, then don't bother */
       19:  474:        if (RegRecPtr->UserDefAddr == FALSE)
        -:  475:        {
        -:  476:            /* Free memory allocated to buffers */
       18:  477:            Status = CFE_ES_PutPoolBuf(CFE_TBL_TaskData.Buf.PoolHdl, (uint32 *)RegRecPtr->Buffers[0].BufferPtr);
       18:  478:            RegRecPtr->Buffers[0].BufferPtr = NULL;
        -:  479:
       18:  480:            if (Status < 0)
        -:  481:            {
        4:  482:                CFE_ES_WriteToSysLog("CFE_TBL:RemoveAccessLink-PutPoolBuf[0] Fail Stat=0x%08X, Hndl=0x%08lX, Buf=0x%08lX\n",
        -:  483:                        (unsigned int)Status, (unsigned long)CFE_TBL_TaskData.Buf.PoolHdl, (unsigned long)RegRecPtr->Buffers[0].BufferPtr);
        -:  484:            }
        -:  485:
        -:  486:            /* If a double buffered table, then free the second buffer as well */
       18:  487:            if (RegRecPtr->DoubleBuffered)
        -:  488:            {
        3:  489:                Status = CFE_ES_PutPoolBuf(CFE_TBL_TaskData.Buf.PoolHdl, (uint32 *)RegRecPtr->Buffers[1].BufferPtr);
        3:  490:                RegRecPtr->Buffers[1].BufferPtr = NULL;
        -:  491:
        3:  492:                if (Status < 0)
        -:  493:                {
        2:  494:                    CFE_ES_WriteToSysLog("CFE_TBL:RemoveAccessLink-PutPoolBuf[1] Fail Stat=0x%08X, Hndl=0x%08lX, Buf=0x%08lX\n",
        -:  495:                            (unsigned int)Status, (unsigned long)CFE_TBL_TaskData.Buf.PoolHdl, (unsigned long)RegRecPtr->Buffers[1].BufferPtr);
        -:  496:                }
        -:  497:            }
        -:  498:            else
        -:  499:            {
        -:  500:                /* If a shared buffer has been allocated to the table, then release it as well */
       15:  501:                if (RegRecPtr->LoadInProgress != CFE_TBL_NO_LOAD_IN_PROGRESS)
        -:  502:                {
        -:  503:                    /* Free the working buffer */
        1:  504:                    CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].Taken = FALSE;
        1:  505:                    RegRecPtr->LoadInProgress = CFE_TBL_NO_LOAD_IN_PROGRESS;
        -:  506:                }
        -:  507:            }
        -:  508:        }
        -:  509:    }
        -:  510:
        -:  511:    /* Unlock the registry to allow others to modify it */
       22:  512:    CFE_TBL_UnlockRegistry();
        -:  513:
       22:  514:    return Status;
        -:  515:}   /* End of CFE_TBL_RemoveAccessLink() */
        -:  516:
        -:  517:
        -:  518:/*******************************************************************
        -:  519:**
        -:  520:** CFE_TBL_GetAddressInternal
        -:  521:**
        -:  522:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  523:********************************************************************/
        -:  524:
        -:  525:
       12:  526:int32 CFE_TBL_GetAddressInternal(void **TblPtr, CFE_TBL_Handle_t TblHandle, uint32 ThisAppId)
        -:  527:{
       12:  528:    int32   Status = CFE_SUCCESS;
        -:  529:    CFE_TBL_AccessDescriptor_t *AccessDescPtr;
        -:  530:    CFE_TBL_RegistryRec_t *RegRecPtr;
        -:  531:
        -:  532:    /* Check table handle validity */
       12:  533:    Status = CFE_TBL_ValidateHandle(TblHandle);
        -:  534:
       12:  535:    if (Status == CFE_SUCCESS)
        -:  536:    {
        -:  537:        /* Get a pointer to the Access Descriptor */
       11:  538:        AccessDescPtr = &CFE_TBL_TaskData.Handles[TblHandle];
        -:  539:
        -:  540:        /* Verify that we are allowed access to the table */
       11:  541:        Status = CFE_TBL_CheckAccessRights(TblHandle, ThisAppId);
        -:  542:
       11:  543:        if (Status == CFE_SUCCESS)
        -:  544:        {
        -:  545:            /* Get a pointer to the Table Registry entry */
       10:  546:            RegRecPtr = &CFE_TBL_TaskData.Registry[AccessDescPtr->RegIndex];
        -:  547:
        -:  548:            /* If table is unowned, then owner must have unregistered it when we weren't looking */
       10:  549:            if (RegRecPtr->OwnerAppId == CFE_TBL_NOT_OWNED)
        -:  550:            {
        1:  551:                Status = CFE_TBL_ERR_UNREGISTERED;
        -:  552:
        1:  553:                CFE_ES_WriteToSysLog("CFE_TBL:GetAddressInternal-App(%d) attempt to access unowned Tbl Handle=%d\n",
        -:  554:                                     (int)ThisAppId, (int)TblHandle);
        -:  555:            }
        -:  556:            else /* Table Registry Entry is valid */
        -:  557:            {
        -:  558:                /* Lock the table and return the current pointer */
        9:  559:                AccessDescPtr->LockFlag = TRUE;
        -:  560:
        -:  561:                /* Save the buffer we are using in the access descriptor */
        -:  562:                /* This is used to ensure that if the buffer becomes inactive while */
        -:  563:                /* we are using it, no one will modify it until we are done */
        9:  564:                AccessDescPtr->BufferIndex = RegRecPtr->ActiveBufferIndex;
        -:  565:
        9:  566:                *TblPtr = RegRecPtr->Buffers[AccessDescPtr->BufferIndex].BufferPtr;
        -:  567:
        -:  568:                /* Return any pending warning or info status indicators */
        9:  569:                Status = CFE_TBL_GetNextNotification(TblHandle);
        -:  570:
        -:  571:                /* Clear Table Updated Notify Bit so that caller only gets it once */
        9:  572:                AccessDescPtr->Updated = FALSE;
        -:  573:            }
        -:  574:        }
        -:  575:        else
        -:  576:        {
        1:  577:            CFE_ES_WriteToSysLog("CFE_TBL:GetAddressInternal-App(%d) does not have access to Tbl Handle=%d\n",
        -:  578:                                 (int)ThisAppId, (int)TblHandle);
        -:  579:        }
        -:  580:    }
        -:  581:    else
        -:  582:    {
        1:  583:        CFE_ES_WriteToSysLog("CFE_TBL:GetAddressInternal-App(%d) using invalid Tbl Handle=%d\n",
        -:  584:                             (int)ThisAppId, (int)TblHandle);
        -:  585:    }
        -:  586:
       12:  587:    return Status;
        -:  588:}   /* End of CFE_TBL_GetAddressInternal() */
        -:  589:
        -:  590:
        -:  591:/*******************************************************************
        -:  592:**
        -:  593:** CFE_TBL_GetNextNotification
        -:  594:**
        -:  595:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  596:********************************************************************/
        -:  597:
       16:  598:int32 CFE_TBL_GetNextNotification(CFE_TBL_Handle_t TblHandle)
        -:  599:{
       16:  600:    int32 Status = CFE_SUCCESS;
       16:  601:    CFE_TBL_AccessDescriptor_t *AccessDescPtr = &CFE_TBL_TaskData.Handles[TblHandle];
       16:  602:    CFE_TBL_RegistryRec_t *RegRecPtr = &CFE_TBL_TaskData.Registry[AccessDescPtr->RegIndex];
        -:  603:
       16:  604:    if (!RegRecPtr->TableLoadedOnce)
        -:  605:    {
        -:  606:        /* If the table has never been loaded, return an error code for the address */
        6:  607:        Status = CFE_TBL_ERR_NEVER_LOADED;
        -:  608:    }
       10:  609:    else if (AccessDescPtr->Updated)
        -:  610:    {
        -:  611:        /* If the table has been updated recently, return the update status */
        6:  612:        Status = CFE_TBL_INFO_UPDATED;
        -:  613:    }
        -:  614:
       16:  615:    return Status;
        -:  616:}   /* End of CFE_TBL_GetNextNotification() */
        -:  617:
        -:  618:
        -:  619:/*******************************************************************
        -:  620:**
        -:  621:** CFE_TBL_FindTableInRegistry
        -:  622:**
        -:  623:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  624:********************************************************************/
        -:  625:
      354:  626:int16 CFE_TBL_FindTableInRegistry(const char *TblName)
        -:  627:{
      354:  628:    int16 RegIndx = CFE_TBL_NOT_FOUND;
      354:  629:    int16 i = -1;
        -:  630:
        -:  631:    do
        -:  632:    {
        -:  633:        /* Point to next record in the Table Registry */
    22225:  634:        i++;
        -:  635:
        -:  636:        /* Check to see if the record is currently being used */
    22225:  637:        if (CFE_TBL_TaskData.Registry[i].OwnerAppId != CFE_TBL_NOT_OWNED)
        -:  638:        {
        -:  639:            /* Perform a case sensitive name comparison */
    10375:  640:            if (strcmp(TblName, CFE_TBL_TaskData.Registry[i].Name) == 0)
        -:  641:            {
        -:  642:                /* If the names match, then return the index */
      183:  643:                RegIndx = i;
        -:  644:            }
        -:  645:        }
    22225:  646:    } while ( (RegIndx == CFE_TBL_NOT_FOUND) && (i < (CFE_PLATFORM_TBL_MAX_NUM_TABLES-1)) );
        -:  647:
      354:  648:    return RegIndx;
        -:  649:}   /* End of CFE_TBL_FindTableInRegistry() */
        -:  650:
        -:  651:
        -:  652:/*******************************************************************
        -:  653:**
        -:  654:** CFE_TBL_FindFreeRegistryEntry
        -:  655:**
        -:  656:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  657:********************************************************************/
        -:  658:
      158:  659:int16 CFE_TBL_FindFreeRegistryEntry(void)
        -:  660:{
      158:  661:    int16 RegIndx = CFE_TBL_NOT_FOUND;
      158:  662:    int16 i = 0;
        -:  663:
     8995:  664:    while ( (RegIndx == CFE_TBL_NOT_FOUND) && (i < CFE_PLATFORM_TBL_MAX_NUM_TABLES) )
        -:  665:    {
        -:  666:        /* A Table Registry is only "Free" when there isn't an owner AND */
        -:  667:        /* all other applications are not sharing or locking the table   */
     8994:  668:        if ((CFE_TBL_TaskData.Registry[i].OwnerAppId == CFE_TBL_NOT_OWNED) &&
      158:  669:            (CFE_TBL_TaskData.Registry[i].HeadOfAccessList == CFE_TBL_END_OF_LIST))
        -:  670:        {
      157:  671:            RegIndx = i;
        -:  672:        }
        -:  673:        else
        -:  674:        {
     8522:  675:            i++;
        -:  676:        }
        -:  677:    }
        -:  678:
      158:  679:    return RegIndx;
        -:  680:}   /* End of CFE_TBL_FindFreeRegistryEntry() */
        -:  681:
        -:  682:
        -:  683:/*******************************************************************
        -:  684:**
        -:  685:** CFE_TBL_FindFreeHandle
        -:  686:**
        -:  687:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  688:********************************************************************/
        -:  689:
      295:  690:CFE_TBL_Handle_t CFE_TBL_FindFreeHandle(void)
        -:  691:{
      295:  692:    CFE_TBL_Handle_t HandleIndx = CFE_TBL_END_OF_LIST;
      295:  693:    int16 i = 0;
        -:  694:
    34569:  695:    while ((HandleIndx == CFE_TBL_END_OF_LIST) && (i < CFE_PLATFORM_TBL_MAX_NUM_HANDLES))
        -:  696:    {
    33979:  697:        if (CFE_TBL_TaskData.Handles[i].UsedFlag == FALSE)
        -:  698:        {
      293:  699:            HandleIndx = i;
        -:  700:        }
        -:  701:        else
        -:  702:        {
    33686:  703:            i++;
        -:  704:        }
        -:  705:    }
        -:  706:
      295:  707:    return HandleIndx;
        -:  708:}   /* End of CFE_TBL_FindFreeHandle() */
        -:  709:
        -:  710:
        -:  711:/*******************************************************************
        -:  712:**
        -:  713:** CFE_TBL_FormTableName
        -:  714:**
        -:  715:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  716:********************************************************************/
        -:  717:
      172:  718:void CFE_TBL_FormTableName(char *FullTblName, const char *TblName, uint32 ThisAppId)
        -:  719:{
        -:  720:    char AppName[OS_MAX_API_NAME];
        -:  721:
      172:  722:    CFE_ES_GetAppName(AppName, ThisAppId, OS_MAX_API_NAME);
        -:  723:
        -:  724:    /* Ensure that AppName is null terminated */
      172:  725:    AppName[OS_MAX_API_NAME-1] = '\0';
        -:  726:
        -:  727:    /* Complete formation of processor specific table name */
      172:  728:    sprintf(FullTblName, "%s.%s", AppName, TblName);
        -:  729:
      172:  730:    return;
        -:  731:}   /* End of CFE_TBL_FormTableName() */
        -:  732:
        -:  733:
        -:  734:/*******************************************************************
        -:  735:**
        -:  736:** CFE_TBL_LockRegistry
        -:  737:**
        -:  738:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  739:********************************************************************/
        -:  740:
      323:  741:int32 CFE_TBL_LockRegistry(void)
        -:  742:{
        -:  743:    int32   Status;
        -:  744:
      323:  745:    Status = OS_MutSemTake(CFE_TBL_TaskData.RegistryMutex);
        -:  746:
      323:  747:    if (Status == OS_SUCCESS)
        -:  748:    {
      322:  749:        Status = CFE_SUCCESS;
        -:  750:
        -:  751:    }
        -:  752:
      323:  753:    return Status;
        -:  754:
        -:  755:}   /* End of CFE_TBL_LockRegistry() */
        -:  756:
        -:  757:
        -:  758:/*******************************************************************
        -:  759:**
        -:  760:** CFE_TBL_UnlockRegistry
        -:  761:**
        -:  762:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  763:********************************************************************/
        -:  764:
      323:  765:int32 CFE_TBL_UnlockRegistry(void)
        -:  766:{
        -:  767:    int32   Status;
        -:  768:
      323:  769:    Status = OS_MutSemGive(CFE_TBL_TaskData.RegistryMutex);
        -:  770:
      323:  771:    if (Status == OS_SUCCESS)
        -:  772:    {
      322:  773:        Status = CFE_SUCCESS;
        -:  774:
        -:  775:    }
        -:  776:
      323:  777:    return Status;
        -:  778:
        -:  779:}   /* End of CFE_TBL_UnlockRegistry() */
        -:  780:
        -:  781:
        -:  782:/*******************************************************************
        -:  783:**
        -:  784:** CFE_TBL_GetWorkingBuffer
        -:  785:**
        -:  786:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  787:********************************************************************/
        -:  788:
       37:  789:int32 CFE_TBL_GetWorkingBuffer(CFE_TBL_LoadBuff_t **WorkingBufferPtr,
        -:  790:                               CFE_TBL_RegistryRec_t *RegRecPtr,
        -:  791:                               boolean CalledByApp)
        -:  792:{
       37:  793:    int32   Status = CFE_SUCCESS;
        -:  794:    int32   i;
        -:  795:    int32   InactiveBufferIndex;
        -:  796:    CFE_TBL_Handle_t AccessIterator;
        -:  797:
        -:  798:    /* Initialize return pointer to NULL */
       37:  799:    *WorkingBufferPtr = NULL;
        -:  800:
        -:  801:    /* If a load is already in progress, return the previously allocated working buffer */
       37:  802:    if (RegRecPtr->LoadInProgress != CFE_TBL_NO_LOAD_IN_PROGRESS)
        -:  803:    {
        5:  804:        if (RegRecPtr->DoubleBuffered)
        -:  805:        {
        1:  806:            *WorkingBufferPtr = &RegRecPtr->Buffers[(1U-RegRecPtr->ActiveBufferIndex)];
        -:  807:        }
        -:  808:        else
        -:  809:        {
        4:  810:            *WorkingBufferPtr = &CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress];
        -:  811:        }
        -:  812:    }
        -:  813:    else
        -:  814:    {
        -:  815:        /* If the table is uninitialized and the function is called by an application (rather than       */
        -:  816:        /* by the Table Services application), then use the current active buffer as the working buffer. */
        -:  817:        /* This allows many tasks with many tables to perform the initialization without conflict        */
        -:  818:        /* over the accessibility of the shared working buffers.                                         */
       43:  819:        if ((RegRecPtr->TableLoadedOnce == FALSE) && (CalledByApp == TRUE))
        -:  820:        {
       11:  821:            if (RegRecPtr->DoubleBuffered)
        -:  822:            {
        2:  823:                *WorkingBufferPtr = &RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex];
        -:  824:            }
        -:  825:            else
        -:  826:            {
        9:  827:                *WorkingBufferPtr = &RegRecPtr->Buffers[0];
        -:  828:            }
        -:  829:        }
        -:  830:        else
        -:  831:        {
        -:  832:            /* If the table is a double buffered table, then check to make sure the */
        -:  833:            /* inactive buffer has been freed by any Applications that may have been using it */
       21:  834:            if (RegRecPtr->DoubleBuffered)
        -:  835:            {
        -:  836:                /* Determine the index of the Inactive Buffer Pointer */
        8:  837:                InactiveBufferIndex = 1 - RegRecPtr->ActiveBufferIndex;
        -:  838:
        -:  839:                /* Scan the access descriptor table to determine if anyone is still using the inactive buffer */
        8:  840:                AccessIterator = RegRecPtr->HeadOfAccessList;
       25:  841:                while ((AccessIterator != CFE_TBL_END_OF_LIST) && (Status == CFE_SUCCESS))
        -:  842:                {
       12:  843:                    if ((CFE_TBL_TaskData.Handles[AccessIterator].BufferIndex == InactiveBufferIndex) &&
        3:  844:		                (CFE_TBL_TaskData.Handles[AccessIterator].LockFlag))
        -:  845:                    {
        2:  846:                        Status = CFE_TBL_ERR_NO_BUFFER_AVAIL;
        -:  847:
        2:  848:                        CFE_ES_WriteToSysLog("CFE_TBL:GetWorkingBuffer-Inactive Dbl Buff Locked for '%s' by AppId=%d\n",
        -:  849:                                             RegRecPtr->Name, (int)CFE_TBL_TaskData.Handles[AccessIterator].AppId);
        -:  850:                    }
        -:  851:
        -:  852:                    /* Move to next access descriptor in linked list */
        9:  853:                    AccessIterator = CFE_TBL_TaskData.Handles[AccessIterator].NextLink;
        -:  854:                }
        -:  855:
        -:  856:                /* If buffer is free, then return the pointer to it */
        8:  857:                if (Status == CFE_SUCCESS)
        -:  858:                {
        6:  859:                    *WorkingBufferPtr = &RegRecPtr->Buffers[InactiveBufferIndex];
        6:  860:                    RegRecPtr->LoadInProgress = InactiveBufferIndex;
        -:  861:                }
        -:  862:            }
        -:  863:            else /* Single Buffered Table */
        -:  864:            {
        -:  865:                /* Take Mutex to make sure we are not trying to grab a working buffer that some */
        -:  866:                /* other application is also trying to grab. */
       13:  867:                Status = OS_MutSemTake(CFE_TBL_TaskData.WorkBufMutex);
        -:  868:
        -:  869:                /* Make note of any errors but continue and hope for the best */
       13:  870:                if (Status != OS_SUCCESS)
        -:  871:                {
        1:  872:                    CFE_ES_WriteToSysLog("CFE_TBL:GetWorkBuf-Internal error taking WorkBuf Mutex (Status=0x%08X)\n",
        -:  873:                            (unsigned int)Status);
        -:  874:                }
        -:  875:
        -:  876:                /* Determine if there are any common buffers available */
       13:  877:                i = 0;
       38:  878:                while ((i < CFE_PLATFORM_TBL_MAX_SIMULTANEOUS_LOADS) && (CFE_TBL_TaskData.LoadBuffs[i].Taken == TRUE))
        -:  879:                {
       12:  880:                    i++;
        -:  881:                }
        -:  882:
        -:  883:                /* If a free buffer was found, then return the address to the associated shared buffer */
       13:  884:                if (i < CFE_PLATFORM_TBL_MAX_SIMULTANEOUS_LOADS)
        -:  885:                {
       10:  886:                    CFE_TBL_TaskData.LoadBuffs[i].Taken = TRUE;
       10:  887:                    *WorkingBufferPtr = &CFE_TBL_TaskData.LoadBuffs[i];
       10:  888:                    RegRecPtr->LoadInProgress = i;
        -:  889:
        -:  890:                    /* Translate OS_SUCCESS into CFE_SUCCESS */
       10:  891:                    Status = CFE_SUCCESS;
        -:  892:                }
        -:  893:                else
        -:  894:                {
        3:  895:                    Status = CFE_TBL_ERR_NO_BUFFER_AVAIL;
        -:  896:
        3:  897:                    CFE_ES_WriteToSysLog("CFE_TBL:GetWorkingBuffer-All shared buffers are locked\n");
        -:  898:                }
        -:  899:
        -:  900:                /* Allow others to obtain a shared working buffer */
       13:  901:                OS_MutSemGive(CFE_TBL_TaskData.WorkBufMutex);
        -:  902:            }
        -:  903:
       37:  904:            if ((*WorkingBufferPtr) != NULL &&
       16:  905:                    (*WorkingBufferPtr)->BufferPtr != RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].BufferPtr)
        -:  906:            {
        -:  907:                /* In case the file contains a partial table load, get the active buffer contents first */
       12:  908:                memcpy((*WorkingBufferPtr)->BufferPtr,
       12:  909:                          RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].BufferPtr,
        6:  910:                          RegRecPtr->Size);
        -:  911:            }
        -:  912:        }
        -:  913:    }
        -:  914:
        -:  915:
       37:  916:    return Status;
        -:  917:
        -:  918:}   /* End of CFE_TBL_GetWorkingBuffer() */
        -:  919:
        -:  920:
        -:  921:/*******************************************************************
        -:  922:**
        -:  923:** CFE_TBL_LoadFromFile
        -:  924:**
        -:  925:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  926:********************************************************************/
        -:  927:
       22:  928:int32 CFE_TBL_LoadFromFile(CFE_TBL_LoadBuff_t *WorkingBufferPtr,
        -:  929:                           CFE_TBL_RegistryRec_t *RegRecPtr,
        -:  930:                           const char *Filename)
        -:  931:{
       22:  932:    int32                Status = CFE_SUCCESS;
        -:  933:    CFE_FS_Header_t      StdFileHeader;
        -:  934:    CFE_TBL_File_Hdr_t   TblFileHeader;
        -:  935:    int32                FileDescriptor;
       22:  936:    size_t               FilenameLen = strlen(Filename);
        -:  937:    uint32               NumBytes;
        -:  938:    uint8                ExtraByte;
        -:  939:
       22:  940:    if (FilenameLen > (OS_MAX_PATH_LEN-1))
        -:  941:    {
        1:  942:        Status = CFE_TBL_ERR_FILENAME_TOO_LONG;
        -:  943:    }
        -:  944:    else
        -:  945:    {
        -:  946:        /* Try to open the specified table file */
       21:  947:        FileDescriptor = OS_open(Filename, OS_READ_ONLY, 0);
        -:  948:
       21:  949:        if (FileDescriptor >= 0)
        -:  950:        {
       20:  951:            Status = CFE_TBL_ReadHeaders(FileDescriptor, &StdFileHeader, &TblFileHeader, Filename);
        -:  952:
       20:  953:            if (Status == CFE_SUCCESS)
        -:  954:            {
        -:  955:                /* Verify that the specified file has compatible data for specified table */
       19:  956:                if (strcmp(RegRecPtr->Name, TblFileHeader.TableName) == 0)
        -:  957:                {
       16:  958:                    if ((TblFileHeader.Offset + TblFileHeader.NumBytes) > RegRecPtr->Size)
        -:  959:                    {
        1:  960:                        Status = CFE_TBL_ERR_FILE_TOO_LARGE;
        -:  961:                    }
        -:  962:                    else
        -:  963:                    {
        -:  964:                        /* Any Table load that starts beyond the first byte is a "partial load" */
        -:  965:                        /* But a file that starts with the first byte and ends before filling   */
        -:  966:                        /* the whole table is just considered "short".                          */
       15:  967:                        if (TblFileHeader.Offset > 0)
        -:  968:                        {
        2:  969:                            Status = CFE_TBL_WARN_PARTIAL_LOAD;
        -:  970:                        }
       13:  971:                        else if (TblFileHeader.NumBytes < RegRecPtr->Size)
        -:  972:                        {
        1:  973:                            Status = CFE_TBL_WARN_SHORT_FILE;
        -:  974:                        }
        -:  975:
       30:  976:                        NumBytes = OS_read(FileDescriptor,
       15:  977:                                           &WorkingBufferPtr->BufferPtr[TblFileHeader.Offset],
        -:  978:                                           TblFileHeader.NumBytes);
        -:  979:
       15:  980:                        if (NumBytes != TblFileHeader.NumBytes)
        -:  981:                        {
        1:  982:                            Status = CFE_TBL_ERR_LOAD_INCOMPLETE;
        -:  983:                        }
        -:  984:                        
        -:  985:                        /* Check to see if the file is too large (ie - more data than header claims) */
       15:  986:                        NumBytes = OS_read(FileDescriptor, &ExtraByte, 1);
        -:  987:                        
        -:  988:                        /* If successfully read another byte, then file must have too much data */
       15:  989:                        if (NumBytes == 1)
        -:  990:                        {
        1:  991:                            Status = CFE_TBL_ERR_FILE_TOO_LARGE;
        -:  992:                        }
        -:  993:
       15:  994:                        memset(WorkingBufferPtr->DataSource, 0, OS_MAX_PATH_LEN);
       15:  995:                        strncpy(WorkingBufferPtr->DataSource, Filename, OS_MAX_PATH_LEN);
        -:  996:
        -:  997:                        /* Save file creation time for later storage into Registry */
       15:  998:                        WorkingBufferPtr->FileCreateTimeSecs = StdFileHeader.TimeSeconds;
       15:  999:                        WorkingBufferPtr->FileCreateTimeSubSecs = StdFileHeader.TimeSubSeconds;
        -: 1000:                        
        -: 1001:                        /* Compute the CRC on the specified table buffer */
       15: 1002:                        WorkingBufferPtr->Crc = CFE_ES_CalculateCRC(WorkingBufferPtr->BufferPtr,
        -: 1003:                                                                    RegRecPtr->Size,
        -: 1004:                                                                    0,
        -: 1005:                                                                    CFE_MISSION_ES_DEFAULT_CRC);
        -: 1006:                    }
        -: 1007:                }
        -: 1008:                else
        -: 1009:                {
        3: 1010:                    Status = CFE_TBL_ERR_FILE_FOR_WRONG_TABLE;
        -: 1011:                }
        -: 1012:            }
        -: 1013:
       20: 1014:            OS_close(FileDescriptor);
        -: 1015:        }
        -: 1016:        else
        -: 1017:        {
        -: 1018:            /* Return error code obtained from OS_open */
        1: 1019:            Status = FileDescriptor;
        -: 1020:        }
        -: 1021:    }
        -: 1022:
       22: 1023:    return Status;
        -: 1024:}
        -: 1025:
        -: 1026:
        -: 1027:/*******************************************************************
        -: 1028:**
        -: 1029:** CFE_TBL_UpdateInternal
        -: 1030:**
        -: 1031:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -: 1032:********************************************************************/
        -: 1033:
       14: 1034:int32 CFE_TBL_UpdateInternal( CFE_TBL_Handle_t TblHandle,
        -: 1035:                              CFE_TBL_RegistryRec_t *RegRecPtr,
        -: 1036:                              CFE_TBL_AccessDescriptor_t *AccessDescPtr )
        -: 1037:{
       14: 1038:    int32 Status = CFE_SUCCESS;
        -: 1039:    CFE_TBL_Handle_t AccessIterator;
       14: 1040:    boolean LockStatus = FALSE;
        -: 1041:    
       16: 1042:    if ((!RegRecPtr->LoadPending) || (RegRecPtr->LoadInProgress == CFE_TBL_NO_LOAD_IN_PROGRESS))
        -: 1043:    {
        -: 1044:        /* Question: Should calling CFE_TBL_Update on a table with no load pending */
        -: 1045:        /* be considered an error?  Currently assuming it is not an error.         */
        2: 1046:        Status = CFE_TBL_INFO_NO_UPDATE_PENDING;
        -: 1047:    }
        -: 1048:    else
        -: 1049:    {
       12: 1050:        if (RegRecPtr->DoubleBuffered)
        -: 1051:        {
        -: 1052:            /* To update a double buffered table only requires a pointer swap */
        5: 1053:            RegRecPtr->ActiveBufferIndex = (uint8)RegRecPtr->LoadInProgress;
        -: 1054:
        -: 1055:            /* Source description in buffer should already have been updated by either */
        -: 1056:            /* the LoadFromFile function or the Load function (when a memory load).    */
        -: 1057:            /* However, we need to copy it into active registry area */
        5: 1058:            strncpy(RegRecPtr->LastFileLoaded,
        5: 1059:                    RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].DataSource,
        -: 1060:                    OS_MAX_PATH_LEN);
        -: 1061:
        5: 1062:            CFE_TBL_NotifyTblUsersOfUpdate(RegRecPtr);
        -: 1063:            
        -: 1064:            /* If the table is a critical table, update the appropriate CDS with the new data */
        5: 1065:            if (RegRecPtr->CriticalTable == TRUE)
        -: 1066:            {
        4: 1067:                CFE_TBL_UpdateCriticalTblCDS(RegRecPtr);
        -: 1068:            }
        -: 1069:        }
        -: 1070:        else
        -: 1071:        {
        -: 1072:            /* Check to see if the Table is locked by anyone */
        7: 1073:            AccessIterator = RegRecPtr->HeadOfAccessList;
       24: 1074:            while (AccessIterator != CFE_TBL_END_OF_LIST)
        -: 1075:            {
       10: 1076:                LockStatus = (LockStatus || CFE_TBL_TaskData.Handles[AccessIterator].LockFlag);
        -: 1077:
       10: 1078:                AccessIterator = CFE_TBL_TaskData.Handles[AccessIterator].NextLink;
        -: 1079:            }
        -: 1080:
        7: 1081:            if (LockStatus)
        -: 1082:            {
        2: 1083:                Status = CFE_TBL_INFO_TABLE_LOCKED;
        -: 1084:
        2: 1085:                CFE_ES_WriteToSysLog("CFE_TBL:UpdateInternal-Unable to update locked table Handle=%d\n", TblHandle);
        -: 1086:            }
        -: 1087:            else
        -: 1088:            {
        -: 1089:                /* To update a single buffered table requires a memcpy from working buffer */
       10: 1090:                if (RegRecPtr->Buffers[0].BufferPtr !=
        5: 1091:                        CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].BufferPtr)
        -: 1092:                {
        1: 1093:                    memcpy(RegRecPtr->Buffers[0].BufferPtr,
        1: 1094:                              CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].BufferPtr,
        1: 1095:                              RegRecPtr->Size);
        -: 1096:                }
        -: 1097:
        -: 1098:                /* Save source description with active buffer */
        5: 1099:                strncpy(RegRecPtr->Buffers[0].DataSource,
        5: 1100:                        CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].DataSource,
        -: 1101:                        OS_MAX_PATH_LEN);
        5: 1102:                strncpy(RegRecPtr->LastFileLoaded,
        5: 1103:                        CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].DataSource,
        -: 1104:                        OS_MAX_PATH_LEN);
        -: 1105:                
        -: 1106:                /* Save the file creation time from the loaded file into the Table Registry */
        5: 1107:                RegRecPtr->Buffers[0].FileCreateTimeSecs = 
        5: 1108:                    CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].FileCreateTimeSecs;
        5: 1109:                RegRecPtr->Buffers[0].FileCreateTimeSubSecs = 
        5: 1110:                    CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].FileCreateTimeSubSecs;
        -: 1111:                
        -: 1112:                /* Save the previously computed CRC into the new buffer */
        5: 1113:                RegRecPtr->Buffers[0].Crc = CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].Crc;
        -: 1114:
        -: 1115:                /* Free the working buffer */
        5: 1116:                CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].Taken = FALSE;
        -: 1117:
        5: 1118:                CFE_TBL_NotifyTblUsersOfUpdate(RegRecPtr);
        -: 1119:            
        -: 1120:                /* If the table is a critical table, update the appropriate CDS with the new data */
        5: 1121:                if (RegRecPtr->CriticalTable == TRUE)
        -: 1122:                {
        1: 1123:                    CFE_TBL_UpdateCriticalTblCDS(RegRecPtr);
        -: 1124:                }
        -: 1125:            }
        -: 1126:        }
        -: 1127:    }
        -: 1128:
       14: 1129:    return Status;
        -: 1130:}   /* End of CFE_TBL_UpdateInternal() */
        -: 1131:
        -: 1132:
        -: 1133:/*******************************************************************
        -: 1134:**
        -: 1135:** CFE_TBL_NotifyTblUsersOfUpdate
        -: 1136:**
        -: 1137:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -: 1138:********************************************************************/
        -: 1139:
       16: 1140:void CFE_TBL_NotifyTblUsersOfUpdate(CFE_TBL_RegistryRec_t *RegRecPtr)
        -: 1141:{
        -: 1142:    CFE_TBL_Handle_t AccessIterator;
        -: 1143:    
        -: 1144:    /* Reset Load in Progress Values */
       16: 1145:    RegRecPtr->LoadInProgress = CFE_TBL_NO_LOAD_IN_PROGRESS;
       16: 1146:    RegRecPtr->TimeOfLastUpdate = CFE_TIME_GetTime();
        -: 1147:
        -: 1148:    /* Clear notification of pending load (as well as NO LOAD) and notify everyone of update */
       16: 1149:    RegRecPtr->LoadPending = FALSE;
       16: 1150:    RegRecPtr->TableLoadedOnce = TRUE;
       16: 1151:    AccessIterator = RegRecPtr->HeadOfAccessList;
       49: 1152:    while (AccessIterator != CFE_TBL_END_OF_LIST)
        -: 1153:    {
       17: 1154:        CFE_TBL_TaskData.Handles[AccessIterator].Updated = TRUE;
        -: 1155:
       17: 1156:        AccessIterator = CFE_TBL_TaskData.Handles[AccessIterator].NextLink;
        -: 1157:    }
       16: 1158:}
        -: 1159:
        -: 1160:/*******************************************************************
        -: 1161:**
        -: 1162:** CFE_TBL_ReadHeaders
        -: 1163:**
        -: 1164:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -: 1165:********************************************************************/
        -: 1166:
       36: 1167:int32 CFE_TBL_ReadHeaders( int32 FileDescriptor,
        -: 1168:                           CFE_FS_Header_t *StdFileHeaderPtr,
        -: 1169:                           CFE_TBL_File_Hdr_t *TblFileHeaderPtr,
        -: 1170:                           const char *LoadFilename )
        -: 1171:{
        -: 1172:    int32 Status;
       36: 1173:    int32 EndianCheck = 0x01020304;
        -: 1174:
        -: 1175:    #if (CFE_PLATFORM_TBL_VALID_SCID_COUNT > 0)
        -: 1176:    static uint32 ListSC[2] = { CFE_PLATFORM_TBL_VALID_SCID_1, CFE_PLATFORM_TBL_VALID_SCID_2};
        -: 1177:    uint32 IndexSC;
        -: 1178:    #endif
        -: 1179:    
        -: 1180:    #if (CFE_PLATFORM_TBL_VALID_PRID_COUNT > 0)
        -: 1181:    static uint32 ListPR[4] = { CFE_PLATFORM_TBL_VALID_PRID_1, CFE_PLATFORM_TBL_VALID_PRID_2,
        -: 1182:                                CFE_PLATFORM_TBL_VALID_PRID_3, CFE_PLATFORM_TBL_VALID_PRID_4};
        -: 1183:    uint32 IndexPR;
        -: 1184:    #endif
        -: 1185:    
        -: 1186:    /* Once the file is open, read the headers to determine the target Table */
       36: 1187:    Status = CFE_FS_ReadHeader(StdFileHeaderPtr, FileDescriptor);
        -: 1188:
        -: 1189:    /* Verify successful read of standard cFE File Header */
       36: 1190:    if (Status != sizeof(CFE_FS_Header_t))
        -: 1191:    {
        3: 1192:        CFE_EVS_SendEventWithAppID(CFE_TBL_FILE_STD_HDR_ERR_EID,
        -: 1193:                                   CFE_EVS_EventType_ERROR,
        -: 1194:                                   CFE_TBL_TaskData.TableTaskAppId,
        -: 1195:                                   "Unable to read std header for '%s', Status = 0x%08X",
        -: 1196:                                   LoadFilename, (unsigned int)Status);
        -: 1197:
        3: 1198:        Status = CFE_TBL_ERR_NO_STD_HEADER;
        -: 1199:    }
        -: 1200:    else
        -: 1201:    {
        -: 1202:        /* Verify the file type is a cFE compatible file */
       33: 1203:        if (StdFileHeaderPtr->ContentType != CFE_FS_FILE_CONTENT_ID)
        -: 1204:        {
        1: 1205:            CFE_EVS_SendEventWithAppID(CFE_TBL_FILE_TYPE_ERR_EID,
        -: 1206:                                       CFE_EVS_EventType_ERROR,
        -: 1207:                                       CFE_TBL_TaskData.TableTaskAppId,
        -: 1208:                                       "File '%s' is not a cFE file type, ContentType = 0x%08X",
        -: 1209:                                       LoadFilename, (unsigned int)StdFileHeaderPtr->ContentType);
        -: 1210:
        1: 1211:            Status = CFE_TBL_ERR_BAD_CONTENT_ID;
        -: 1212:        }
        -: 1213:        else
        -: 1214:        {
        -: 1215:            /* Verify the SubType to ensure that it is a Table Image File */
       32: 1216:            if (StdFileHeaderPtr->SubType != CFE_FS_SubType_TBL_IMG)
        -: 1217:            {
        1: 1218:                CFE_EVS_SendEventWithAppID(CFE_TBL_FILE_SUBTYPE_ERR_EID,
        -: 1219:                                           CFE_EVS_EventType_ERROR,
        -: 1220:                                           CFE_TBL_TaskData.TableTaskAppId,
        -: 1221:                                           "File subtype for '%s' is wrong. Subtype = 0x%08X",
        -: 1222:                                           LoadFilename, (unsigned int)StdFileHeaderPtr->SubType);
        -: 1223:
        1: 1224:                Status = CFE_TBL_ERR_BAD_SUBTYPE_ID;
        -: 1225:            }
        -: 1226:            else
        -: 1227:            {
       31: 1228:                Status = OS_read(FileDescriptor, TblFileHeaderPtr, sizeof(CFE_TBL_File_Hdr_t));
        -: 1229:
        -: 1230:                /* Verify successful read of cFE Table File Header */
       31: 1231:                if (Status != sizeof(CFE_TBL_File_Hdr_t))
        -: 1232:                {
        1: 1233:                    CFE_EVS_SendEventWithAppID(CFE_TBL_FILE_TBL_HDR_ERR_EID,
        -: 1234:                                               CFE_EVS_EventType_ERROR,
        -: 1235:                                               CFE_TBL_TaskData.TableTaskAppId,
        -: 1236:                                               "Unable to read tbl header for '%s', Status = 0x%08X",
        -: 1237:                                               LoadFilename, (unsigned int)Status);
        -: 1238:
        1: 1239:                    Status = CFE_TBL_ERR_NO_TBL_HEADER;
        -: 1240:                }
        -: 1241:                else
        -: 1242:                {
        -: 1243:                    /* All "required" checks have passed and we are pointing at the data */
       30: 1244:                    Status = CFE_SUCCESS;
        -: 1245:
       30: 1246:                    if ((*(char *)&EndianCheck) == 0x04)
        -: 1247:                    {
        -: 1248:                        /* If this is a little endian processor, then the standard cFE Table Header,   */
        -: 1249:                        /* which is in big endian format, must be swapped so that the data is readable */
       30: 1250:                        CFE_TBL_ByteSwapTblHeader(TblFileHeaderPtr);
        -: 1251:                    }
        -: 1252:
        -: 1253:                    /*
        -: 1254:                     * Ensure termination of all local strings. These were read from a file, so they
        -: 1255:                     * must be treated with appropriate care.  This could happen in case the file got
        -: 1256:                     * damaged in transit or simply was not written properly to begin with.
        -: 1257:                     *
        -: 1258:                     * Since the "TblFileHeaderPtr" is a local buffer, this can be done directly.
        -: 1259:                     */
       30: 1260:                    TblFileHeaderPtr->TableName[sizeof(TblFileHeaderPtr->TableName) - 1] = '\0';
        -: 1261:
        -: 1262:                    /* Verify Spacecraft ID contained in table file header [optional] */
        -: 1263:                    #if (CFE_PLATFORM_TBL_VALID_SCID_COUNT > 0)
        -: 1264:                    if (Status == CFE_SUCCESS)
        -: 1265:                    {
        -: 1266:                        Status = CFE_TBL_ERR_BAD_SPACECRAFT_ID;
        -: 1267:                        for (IndexSC = 0; IndexSC < CFE_PLATFORM_TBL_VALID_SCID_COUNT; IndexSC++)
        -: 1268:                        {
        -: 1269:                            if (StdFileHeaderPtr->SpacecraftID == ListSC[IndexSC])
        -: 1270:                            {
        -: 1271:                                Status = CFE_SUCCESS;
        -: 1272:                            }
        -: 1273:                        }
        -: 1274:
        -: 1275:                        if (Status == CFE_TBL_ERR_BAD_SPACECRAFT_ID)
        -: 1276:                        {
        -: 1277:                            CFE_EVS_SendEventWithAppID(CFE_TBL_SPACECRAFT_ID_ERR_EID,
        -: 1278:                                                       CFE_EVS_EventType_ERROR,
        -: 1279:                                                       CFE_TBL_TaskData.TableTaskAppId,
        -: 1280:                                                       "Unable to verify Spacecraft ID for '%s', ID = 0x%08X",
        -: 1281:                                                       LoadFilename, (unsigned int)StdFileHeaderPtr->SpacecraftID);
        -: 1282:                        }
        -: 1283:                    }
        -: 1284:                    #endif
        -: 1285:
        -: 1286:                    /* Verify Processor ID contained in table file header [optional] */
        -: 1287:                    #if (CFE_PLATFORM_TBL_VALID_PRID_COUNT > 0)
        -: 1288:                    if (Status == CFE_SUCCESS)
        -: 1289:                    {
        -: 1290:                        Status = CFE_TBL_ERR_BAD_PROCESSOR_ID;
        -: 1291:                        for (IndexPR = 0; IndexPR < CFE_PLATFORM_TBL_VALID_PRID_COUNT; IndexPR++)
        -: 1292:                        {
        -: 1293:                            if (StdFileHeaderPtr->ProcessorID == ListPR[IndexPR])
        -: 1294:                            {
        -: 1295:                                Status = CFE_SUCCESS;
        -: 1296:                            }
        -: 1297:                        }
        -: 1298:
        -: 1299:                        if (Status == CFE_TBL_ERR_BAD_PROCESSOR_ID)
        -: 1300:                        {
        -: 1301:                            CFE_EVS_SendEventWithAppID(CFE_TBL_PROCESSOR_ID_ERR_EID,
        -: 1302:                                                       CFE_EVS_EventType_ERROR,
        -: 1303:                                                       CFE_TBL_TaskData.TableTaskAppId,
        -: 1304:                                                       "Unable to verify Processor ID for '%s', ID = 0x%08X",
        -: 1305:                                                       LoadFilename, (unsigned int)StdFileHeaderPtr->ProcessorID);
        -: 1306:                        }
        -: 1307:                    }
        -: 1308:                    #endif
        -: 1309:                }
        -: 1310:            }
        -: 1311:        }
        -: 1312:    }
        -: 1313:
       36: 1314:    return Status;
        -: 1315:}   /* End of CFE_TBL_ReadHeaders() */
        -: 1316:
        -: 1317:
        -: 1318:/*******************************************************************
        -: 1319:**
        -: 1320:** CFE_TBL_ByteSwapTblHeader
        -: 1321:**
        -: 1322:** NOTE: For complete prolog information, see above
        -: 1323:********************************************************************/
        -: 1324:
       38: 1325:void CFE_TBL_ByteSwapTblHeader(CFE_TBL_File_Hdr_t *HdrPtr)
        -: 1326:{
       38: 1327:    CFE_TBL_ByteSwapUint32(&HdrPtr->Reserved);
       38: 1328:    CFE_TBL_ByteSwapUint32(&HdrPtr->Offset);
       38: 1329:    CFE_TBL_ByteSwapUint32(&HdrPtr->NumBytes);
       38: 1330:} /* End of CFE_TBL_ByteSwapTblHeader() */
        -: 1331:
        -: 1332:
        -: 1333:/*******************************************************************
        -: 1334:**
        -: 1335:** CFE_TBL_ByteSwapUint32
        -: 1336:**
        -: 1337:** NOTE: For complete prolog information, see above
        -: 1338:********************************************************************/
        -: 1339:
      174: 1340:void CFE_TBL_ByteSwapUint32(uint32 *Uint32ToSwapPtr)
        -: 1341:{
      174: 1342:    int32 Temp = *Uint32ToSwapPtr;
      174: 1343:    char *InPtr = (char *)&Temp;
      174: 1344:    char *OutPtr = (char *)Uint32ToSwapPtr;
        -: 1345:    
      174: 1346:    OutPtr[0] = InPtr[3];
      174: 1347:    OutPtr[1] = InPtr[2];
      174: 1348:    OutPtr[2] = InPtr[1];
      174: 1349:    OutPtr[3] = InPtr[0];    
      174: 1350:} /* End of CFE_TBL_ByteSwapUint32() */
        -: 1351:
        -: 1352:/*******************************************************************
        -: 1353:**
        -: 1354:** CFE_TBL_CleanUpApp
        -: 1355:**
        -: 1356:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -: 1357:********************************************************************/
        -: 1358:
        2: 1359:int32 CFE_TBL_CleanUpApp(uint32 AppId)
        -: 1360:{
        -: 1361:    uint32 i;
        2: 1362:    CFE_TBL_RegistryRec_t *RegRecPtr = NULL;
        2: 1363:    CFE_TBL_AccessDescriptor_t *AccessDescPtr = NULL;
        -: 1364:
        -: 1365:    /* Scan Dump Requests to determine if any of the tables that */
        -: 1366:    /* were to be dumped will be deleted */
       10: 1367:    for (i=0; i<CFE_PLATFORM_TBL_MAX_SIMULTANEOUS_LOADS; i++)
        -: 1368:    {
        -: 1369:        /* Check to see if the table to be dumped is owned by the App to be deleted */
       10: 1370:        if ((CFE_TBL_TaskData.DumpControlBlocks[i].State != CFE_TBL_DUMP_FREE) && 
        2: 1371:           (CFE_TBL_TaskData.DumpControlBlocks[i].RegRecPtr->OwnerAppId == AppId))
        -: 1372:        {
        -: 1373:            /* If so, then remove the dump request */
        1: 1374:            CFE_TBL_TaskData.DumpControlBlocks[i].State = CFE_TBL_DUMP_FREE;
        -: 1375:        }
        -: 1376:    }
        -: 1377:    
        -: 1378:    /* Scan Access Descriptors to determine if the Application had access to any tables */
      514: 1379:    for (i=0; i<CFE_PLATFORM_TBL_MAX_NUM_HANDLES; i++)
        -: 1380:    {
        -: 1381:        /* Check to see if the Handle belongs to the Application being deleted */
      512: 1382:        if (CFE_TBL_TaskData.Handles[i].AppId == AppId)
        -: 1383:        {
        -: 1384:            /* Delete the handle (and the table, if the App owned it) */
        -: 1385:            /* Get a pointer to the relevant Access Descriptor */
        3: 1386:            AccessDescPtr = &CFE_TBL_TaskData.Handles[i];
        -: 1387:
        -: 1388:            /* Get a pointer to the relevant entry in the registry */
        3: 1389:            RegRecPtr = &CFE_TBL_TaskData.Registry[AccessDescPtr->RegIndex];
        -: 1390:
        -: 1391:            /* Determine if the Application owned this particular table */
        3: 1392:            if (RegRecPtr->OwnerAppId == AppId)
        -: 1393:            {
        -: 1394:                /* Mark table as free, although, technically, it isn't free until the */
        -: 1395:                /* linked list of Access Descriptors has no links in it.              */
        -: 1396:                /* NOTE: Allocated memory is freed when all Access Links have been    */
        -: 1397:                /*       removed.  This allows Applications to continue to use the    */
        -: 1398:                /*       data until they acknowledge that the table has been removed. */
        2: 1399:                RegRecPtr->OwnerAppId = (uint32)CFE_TBL_NOT_OWNED;
        -: 1400:
        -: 1401:                /* Remove Table Name */
        2: 1402:                RegRecPtr->Name[0] = '\0';
        -: 1403:            }
        -: 1404:            
        -: 1405:            /* Remove the Access Descriptor Link from linked list */
        -: 1406:            /* NOTE: If this removes the last access link, then   */
        -: 1407:            /*       memory buffers are set free as well.         */
        3: 1408:            CFE_TBL_RemoveAccessLink(i);
        -: 1409:        }
        -: 1410:    }
        -: 1411:
        2: 1412:    return CFE_SUCCESS;
        -: 1413:}
        -: 1414:
        -: 1415:/*******************************************************************
        -: 1416:**
        -: 1417:** CFE_TBL_FindCriticalTblInfo
        -: 1418:**
        -: 1419:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -: 1420:********************************************************************/
        -: 1421:
       20: 1422:void CFE_TBL_FindCriticalTblInfo(CFE_TBL_CritRegRec_t **CritRegRecPtr, CFE_ES_CDSHandle_t CDSHandleToFind)
        -: 1423:{
        -: 1424:    uint32 i;
        -: 1425:    
        -: 1426:    /* Assume the record is never found */
       20: 1427:    *CritRegRecPtr = NULL;
        -: 1428:    
      120: 1429:    for (i=0; i<CFE_PLATFORM_TBL_MAX_CRITICAL_TABLES; i++)
        -: 1430:    {
      117: 1431:        if (CFE_TBL_TaskData.CritReg[i].CDSHandle == CDSHandleToFind)
        -: 1432:        {
       17: 1433:            *CritRegRecPtr = &CFE_TBL_TaskData.CritReg[i];
       17: 1434:            break;
        -: 1435:        }
        -: 1436:    }
       20: 1437:}
        -: 1438:
        -: 1439:
        -: 1440:/*******************************************************************
        -: 1441:**
        -: 1442:** CFE_TBL_UpdateCriticalTblCDS
        -: 1443:**
        -: 1444:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -: 1445:********************************************************************/
        -: 1446:
        9: 1447:void CFE_TBL_UpdateCriticalTblCDS(CFE_TBL_RegistryRec_t *RegRecPtr)
        -: 1448:{
        9: 1449:    CFE_TBL_CritRegRec_t *CritRegRecPtr = NULL;
        -: 1450:    
        9: 1451:    int32 Status = CFE_SUCCESS;
        -: 1452:    
        -: 1453:    /* Copy an image of the updated table to the CDS for safekeeping */
        9: 1454:    Status = CFE_ES_CopyToCDS(RegRecPtr->CDSHandle, RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].BufferPtr);
        -: 1455:    
        9: 1456:    if (Status != CFE_SUCCESS)
        -: 1457:    {
        1: 1458:        CFE_ES_WriteToSysLog("CFE_TBL:UpdateCritTbl-Unable to update Critical Table '%s' in CDS (Err=0x%08X)\n", 
        -: 1459:                             RegRecPtr->Name, (unsigned int)Status);
        -: 1460:    }
        -: 1461:    else
        -: 1462:    {
        -: 1463:        /* Locate entry in Critical Table Registry */   
        8: 1464:        CFE_TBL_FindCriticalTblInfo(&CritRegRecPtr, RegRecPtr->CDSHandle);
        8: 1465:        if (CritRegRecPtr != NULL)
        -: 1466:        {
        -: 1467:            /* Save information related to the source of the data stored in the table in Critical Table Registry */
        7: 1468:            CritRegRecPtr->FileCreateTimeSecs = RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].FileCreateTimeSecs;
        7: 1469:            CritRegRecPtr->FileCreateTimeSubSecs = RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].FileCreateTimeSubSecs;
        7: 1470:            strncpy(CritRegRecPtr->LastFileLoaded, RegRecPtr->LastFileLoaded, OS_MAX_PATH_LEN);
        7: 1471:            CritRegRecPtr->TimeOfLastUpdate = RegRecPtr->TimeOfLastUpdate;
        7: 1472:            CritRegRecPtr->TableLoadedOnce = RegRecPtr->TableLoadedOnce;
        -: 1473:            
        -: 1474:            /* Update copy of Critical Table Registry in the CDS */
        7: 1475:            Status = CFE_ES_CopyToCDS(CFE_TBL_TaskData.CritRegHandle, CFE_TBL_TaskData.CritReg);
        -: 1476:            
        7: 1477:            if (Status != CFE_SUCCESS)
        -: 1478:            {
        1: 1479:                CFE_ES_WriteToSysLog("CFE_TBL:UpdateCritTbl-Unable to update Critical Table Registry in CDS (Err=0x%08X)\n",
        -: 1480:                        (unsigned int)Status);
        -: 1481:            }
        -: 1482:        }
        -: 1483:        else
        -: 1484:        {
        1: 1485:            CFE_ES_WriteToSysLog("CFE_TBL:UpdateCritTbl-Error finding '%s' in Critical Table Registry\n", 
        -: 1486:                                 RegRecPtr->Name);
        -: 1487:        }
        -: 1488:    }
        -: 1489:    
        -: 1490:    /* Don't bother notifying the caller of the problem since the active table is still legitimate */
        9: 1491:}
        -: 1492:
        -: 1493:
        -: 1494:/*******************************************************************
        -: 1495:**
        -: 1496:** CFE_TBL_SendNotificationMsg
        -: 1497:**
        -: 1498:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -: 1499:********************************************************************/
        -: 1500:
        7: 1501:int32 CFE_TBL_SendNotificationMsg(CFE_TBL_RegistryRec_t *RegRecPtr)
        -: 1502:{
        7: 1503:    int32 Status = CFE_SUCCESS;
        -: 1504:    
        -: 1505:    /* First, determine if a message should be sent */
        7: 1506:    if (RegRecPtr->NotifyByMsg)
        -: 1507:    {
        -: 1508:        /*
        -: 1509:        ** Initialize notification message packet (clear user data area)...
        -: 1510:        */
        5: 1511:        CFE_SB_InitMsg(&CFE_TBL_TaskData.NotifyMsg,
        5: 1512:                        RegRecPtr->NotificationMsgId,
        -: 1513:                        sizeof(CFE_TBL_NotifyCmd_t), TRUE);
        -: 1514:        
        -: 1515:        /* Set the command code */
        5: 1516:        CFE_SB_SetCmdCode((CFE_SB_MsgPtr_t) &CFE_TBL_TaskData.NotifyMsg, RegRecPtr->NotificationCC);
        -: 1517:        
        -: 1518:        /* Set the command parameter */
        5: 1519:        CFE_TBL_TaskData.NotifyMsg.Payload.Parameter = RegRecPtr->NotificationParam;
        -: 1520:    
        5: 1521:        CFE_SB_TimeStampMsg((CFE_SB_Msg_t *) &CFE_TBL_TaskData.NotifyMsg);
        5: 1522:        Status = CFE_SB_SendMsg((CFE_SB_Msg_t *) &CFE_TBL_TaskData.NotifyMsg);
        -: 1523:    
        5: 1524:        if (Status != CFE_SUCCESS)
        -: 1525:        {
        3: 1526:            CFE_EVS_SendEvent(CFE_TBL_FAIL_NOTIFY_SEND_ERR_EID,
        -: 1527:                              CFE_EVS_EventType_ERROR,
        -: 1528:                              "Manage Notification Pkt Error(Status=0x%08X)",
        -: 1529:                              (unsigned int)Status);
        -: 1530:        }
        -: 1531:    }
        -: 1532:    
        7: 1533:    return Status;
        -: 1534:}
        -: 1535:
        -: 1536:/************************/
        -: 1537:/*  End of File Comment */
        -: 1538:/************************/
        -: 1539:
