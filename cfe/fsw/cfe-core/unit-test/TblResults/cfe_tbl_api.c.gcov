        -:    0:Source:/home/mdeschu/cfe-660-ut/cfe/fsw/cfe-core/src/tbl/cfe_tbl_api.c
        -:    0:Programs:4
        -:    1:/*
        -:    2:** $Id: cfe_tbl_api.c 1.21 2012/04/18 14:38:20GMT-05:00 lwalling Exp  $
        -:    3:**
        -:    4:**      Copyright (c) 2004-2012, United States government as represented by the 
        -:    5:**      administrator of the National Aeronautics Space Administration.  
        -:    6:**      All rights reserved. This software(cFE) was created at NASA's Goddard 
        -:    7:**      Space Flight Center pursuant to government contracts.
        -:    8:**
        -:    9:**      This is governed by the NASA Open Source Agreement and may be used, 
        -:   10:**      distributed and modified only pursuant to the terms of that agreement. 
        -:   11:**
        -:   12:** Purpose:  cFE Table Services (TBL) library API source file
        -:   13:**
        -:   14:** Author:   D. Kobe/the Hammers Company, Inc.
        -:   15:**
        -:   16:** Notes:
        -:   17:**
        -:   18:*/
        -:   19:
        -:   20:
        -:   21:/*
        -:   22:** Required header files...
        -:   23:*/
        -:   24:#include <string.h>
        -:   25:#include "private/cfe_private.h"
        -:   26:#include "cfe_es.h"
        -:   27:#include "cfe_tbl.h"
        -:   28:#include "cfe_error.h"
        -:   29:#include "cfe_tbl_internal.h"
        -:   30:#include "cfe_psp.h"
        -:   31:
        -:   32:/*
        -:   33:** Local Macros
        -:   34:*/
        -:   35:
        -:   36:/*******************************************************************
        -:   37:**
        -:   38:** CFE_TBL_Register() -- Register a table with cFE to obtain
        -:   39:**                       Table Management Services
        -:   40:**
        -:   41:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -:   42:********************************************************************/
      176:   43:int32 CFE_TBL_Register( CFE_TBL_Handle_t *TblHandlePtr,
        -:   44:                        const char *Name,
        -:   45:                        uint32  Size,
        -:   46:                        uint16  TblOptionFlags,
        -:   47:                        CFE_TBL_CallbackFuncPtr_t TblValidationFuncPtr )
        -:   48:{
      176:   49:    CFE_TBL_AccessDescriptor_t *AccessDescPtr = NULL;
      176:   50:    CFE_TBL_RegistryRec_t      *RegRecPtr = NULL;
        -:   51:    CFE_TBL_LoadBuff_t         *WorkingBufferPtr;
      176:   52:    CFE_TBL_CritRegRec_t       *CritRegRecPtr = NULL;
      176:   53:    int32                       Status = CFE_SUCCESS;
      176:   54:    size_t                      NameLen = 0;
      176:   55:    int16                       RegIndx = -1;
        -:   56:    uint32                      ThisAppId;
      176:   57:    char                        AppName[OS_MAX_API_NAME] = {"UNKNOWN"};
      176:   58:    char                        TblName[CFE_TBL_MAX_FULL_NAME_LEN] = {""};
        -:   59:    CFE_TBL_Handle_t            AccessIndex;
        -:   60:
        -:   61:    /* Check to make sure calling application is legit */
      176:   62:    Status = CFE_TBL_ValidateAppID(&ThisAppId);
        -:   63:
      176:   64:    if (Status == CFE_SUCCESS)
        -:   65:    {
        -:   66:        /* Assume we can't make a table and return a bad handle for now */
      174:   67:        *TblHandlePtr = CFE_TBL_BAD_TABLE_HANDLE;
        -:   68:
        -:   69:        /* Make sure specified table name is not too long or too short */
      174:   70:        NameLen = strlen(Name);
      176:   71:        if ((NameLen > CFE_MISSION_TBL_MAX_NAME_LENGTH) || (NameLen == 0))
        -:   72:        {
        2:   73:            Status = CFE_TBL_ERR_INVALID_NAME;
        -:   74:
        -:   75:            /* Perform a buffer overrun safe copy of name for debug log message */
        2:   76:            strncpy(TblName, Name, CFE_MISSION_TBL_MAX_NAME_LENGTH);
        2:   77:            TblName[CFE_MISSION_TBL_MAX_NAME_LENGTH-1] = '\0';
        2:   78:            CFE_ES_WriteToSysLog("CFE_TBL:Register-Table Name (%s) is bad length (%d)",TblName,(int)NameLen);
        -:   79:        }
        -:   80:        else
        -:   81:        {
        -:   82:            /* Modify specified name to be processor specific name */
        -:   83:            /* of the form "AppName.TableName"                     */
      172:   84:            CFE_TBL_FormTableName(TblName, Name, ThisAppId);
        -:   85:
        -:   86:           /* Make sure the specified size is acceptable */
        -:   87:            /* Single buffered tables are allowed to be up to CFE_PLATFORM_TBL_MAX_SNGL_TABLE_SIZE */
        -:   88:            /* Double buffered tables are allowed to be up to CFE_PLATFORM_TBL_MAX_DBL_TABLE_SIZE  */
      172:   89:            if (Size == 0)
        -:   90:            {
        1:   91:                Status = CFE_TBL_ERR_INVALID_SIZE;
        -:   92:
        1:   93:                CFE_ES_WriteToSysLog("CFE_TBL:Register-Table %s has size of zero\n", Name);
        -:   94:            }
      174:   95:            else if ((Size > CFE_PLATFORM_TBL_MAX_SNGL_TABLE_SIZE) &&
        2:   96:                     ((TblOptionFlags & CFE_TBL_OPT_BUFFER_MSK) == CFE_TBL_OPT_SNGL_BUFFER))
        -:   97:            {
        1:   98:                Status = CFE_TBL_ERR_INVALID_SIZE;
        -:   99:
        1:  100:                CFE_ES_WriteToSysLog("CFE_TBL:Register-Single Buffered Table '%s' has size %d > %d\n",
        -:  101:                                     Name, (int)Size, CFE_PLATFORM_TBL_MAX_SNGL_TABLE_SIZE);
        -:  102:            }
      171:  103:            else if ((Size > CFE_PLATFORM_TBL_MAX_DBL_TABLE_SIZE) &&
        1:  104:                     ((TblOptionFlags & CFE_TBL_OPT_BUFFER_MSK) == CFE_TBL_OPT_DBL_BUFFER))
        -:  105:            {
        1:  106:                Status = CFE_TBL_ERR_INVALID_SIZE;
        -:  107:
        1:  108:                CFE_ES_WriteToSysLog("CFE_TBL:Register-Dbl Buffered Table '%s' has size %d > %d\n",
        -:  109:                                     Name, (int)Size, CFE_PLATFORM_TBL_MAX_DBL_TABLE_SIZE);
        -:  110:            }
        -:  111:            
        -:  112:            /* Verify Table Option settings are legal */
        -:  113:            /* User defined table addresses are only legal for single buffered, dump-only, non-critical tables */
      172:  114:            if ((TblOptionFlags & CFE_TBL_OPT_USR_DEF_MSK) == (CFE_TBL_OPT_USR_DEF_ADDR & CFE_TBL_OPT_USR_DEF_MSK))
        -:  115:            {
       14:  116:                if (((TblOptionFlags & CFE_TBL_OPT_BUFFER_MSK) == CFE_TBL_OPT_DBL_BUFFER) ||
        5:  117:                    ((TblOptionFlags & CFE_TBL_OPT_LD_DMP_MSK) == CFE_TBL_OPT_LOAD_DUMP) ||
        3:  118:                    ((TblOptionFlags & CFE_TBL_OPT_CRITICAL_MSK) == CFE_TBL_OPT_CRITICAL))
        -:  119:                {
        4:  120:                    Status = CFE_TBL_ERR_INVALID_OPTIONS;
        -:  121:                    
        4:  122:                    CFE_ES_WriteToSysLog("CFE_TBL:Register-User Def tbl '%s' cannot be dbl buff, load/dump or critical\n",
        -:  123:                                         Name);
        -:  124:                }
        -:  125:            }
      166:  126:            else if ((TblOptionFlags & CFE_TBL_OPT_LD_DMP_MSK) == CFE_TBL_OPT_DUMP_ONLY)
        -:  127:            {
        -:  128:                /* Dump Only tables cannot be double buffered, nor critical */
        7:  129:                if (((TblOptionFlags & CFE_TBL_OPT_BUFFER_MSK) == CFE_TBL_OPT_DBL_BUFFER) ||
        3:  130:                    ((TblOptionFlags & CFE_TBL_OPT_CRITICAL_MSK) == CFE_TBL_OPT_CRITICAL))
        -:  131:                {
        2:  132:                    Status = CFE_TBL_ERR_INVALID_OPTIONS;
        -:  133:                    
        2:  134:                    CFE_ES_WriteToSysLog("CFE_TBL:Register-Dump Only tbl '%s' cannot be double buffered or critical\n",
        -:  135:                                         Name);
        -:  136:                }
        -:  137:            }
        -:  138:        }
        -:  139:    }
        -:  140:    else  /* Application ID was invalid */
        -:  141:    {
        2:  142:        CFE_ES_WriteToSysLog("CFE_TBL:Register-Bad AppId(%d)\n", (int)ThisAppId);
        -:  143:    }
        -:  144:
        -:  145:    /* If input parameters appear acceptable, register the table */
      176:  146:    if (Status == CFE_SUCCESS)
        -:  147:    {
        -:  148:        /* Lock Registry for update.  This prevents two applications from        */
        -:  149:        /* trying to register/share tables at the same location at the same time */
      163:  150:        CFE_TBL_LockRegistry();
        -:  151:
        -:  152:        /* Check for duplicate table name */
      163:  153:        RegIndx = CFE_TBL_FindTableInRegistry(TblName);
        -:  154:
        -:  155:        /* Check to see if table is already in the registry */
      163:  156:        if (RegIndx != CFE_TBL_NOT_FOUND)
        -:  157:        {
        -:  158:            /* Get pointer to Registry Record Entry to speed up processing */
        6:  159:            RegRecPtr = &CFE_TBL_TaskData.Registry[RegIndx];
        -:  160:
        -:  161:            /* If this app previously owned the table, then allow them to re-register */
        6:  162:            if (RegRecPtr->OwnerAppId == ThisAppId)
        -:  163:            {
        -:  164:                /* If the new table is the same size as the old, then no need to reallocate memory */
        5:  165:                if (Size != RegRecPtr->Size)
        -:  166:                {
        -:  167:                    /* If the new size is different, the old table must deleted      */
        -:  168:                    /* but this function can't do that because it is probably shared */
        -:  169:                    /* and is probably still being accessed.  Someone else will need */
        -:  170:                    /* to clean up this mess.                                        */
        1:  171:                    Status = CFE_TBL_ERR_DUPLICATE_DIFF_SIZE;
        -:  172:
        1:  173:                    CFE_ES_WriteToSysLog("CFE_TBL:Register-Attempt to register existing table ('%s') with different size(%d!=%d)\n",
        -:  174:                                         TblName, (int)Size, (int)RegRecPtr->Size);
        -:  175:                }
        -:  176:                else
        -:  177:                {
        -:  178:                    /* Warn calling application that this is a duplicate registration */
        4:  179:                    Status = CFE_TBL_WARN_DUPLICATE;
        -:  180:                    
        -:  181:                    /* Find the existing access descriptor for the table       */
        -:  182:                    /* and return the same handle that was returned previously */
        4:  183:                    AccessIndex = RegRecPtr->HeadOfAccessList;
       12:  184:                    while ((AccessIndex != CFE_TBL_END_OF_LIST) && (*TblHandlePtr == CFE_TBL_BAD_TABLE_HANDLE))
        -:  185:                    {
       10:  186:                        if ((CFE_TBL_TaskData.Handles[AccessIndex].UsedFlag == TRUE) &&
        3:  187:                            (CFE_TBL_TaskData.Handles[AccessIndex].AppId == ThisAppId) &&
        2:  188:                            (CFE_TBL_TaskData.Handles[AccessIndex].RegIndex == RegIndx))
        -:  189:                        {
        1:  190:                            *TblHandlePtr = AccessIndex;
        -:  191:                        }
        -:  192:                        else
        -:  193:                        {
        3:  194:                            AccessIndex = CFE_TBL_TaskData.Handles[AccessIndex].NextLink;
        -:  195:                        }
        -:  196:                    }
        -:  197:                }
        -:  198:            }
        -:  199:            else /* Duplicate named table owned by another Application */
        -:  200:            {
        1:  201:                Status = CFE_TBL_ERR_DUPLICATE_NOT_OWNED;
        -:  202:
        1:  203:                CFE_ES_WriteToSysLog("CFE_TBL:Register-App(%d) Registering Duplicate Table '%s' owned by App(%d)\n",
        -:  204:                                     (int)ThisAppId, TblName, (int)RegRecPtr->OwnerAppId);
        -:  205:            }
        -:  206:        }
        -:  207:        else  /* Table not already in registry */
        -:  208:        {
        -:  209:            /* Locate empty slot in table registry */
      157:  210:            RegIndx = CFE_TBL_FindFreeRegistryEntry();
        -:  211:        }
        -:  212:
        -:  213:        /* Check to make sure we found a free entry in registry */
      163:  214:        if (RegIndx == CFE_TBL_NOT_FOUND)
        -:  215:        {
        1:  216:            Status = CFE_TBL_ERR_REGISTRY_FULL;
        1:  217:            CFE_ES_WriteToSysLog("CFE_TBL:Register-Registry full\n");
        -:  218:        }
        -:  219:
        -:  220:        /* If this is a duplicate registration, no other work is required */
      163:  221:        if (Status != CFE_TBL_WARN_DUPLICATE)
        -:  222:        {
        -:  223:            /* Search Access Descriptor Array for free Descriptor */
      159:  224:            *TblHandlePtr = CFE_TBL_FindFreeHandle();
        -:  225:
        -:  226:            /* Check to make sure there was a handle available */
      159:  227:            if (*TblHandlePtr == CFE_TBL_END_OF_LIST)
        -:  228:            {
        1:  229:                Status = CFE_TBL_ERR_HANDLES_FULL;
        1:  230:                CFE_ES_WriteToSysLog("CFE_TBL:Register-No more free handles\n");
        -:  231:            }
        -:  232:
        -:  233:            /* If no errors, then initialize the table registry entry     */
        -:  234:            /* and return the registry index to the caller as the handle  */
      159:  235:            if ((Status & CFE_SEVERITY_BITMASK) != CFE_SEVERITY_ERROR)
        -:  236:            {
        -:  237:                /* Get pointer to Registry Record Entry to speed up processing */
      155:  238:                RegRecPtr = &CFE_TBL_TaskData.Registry[RegIndx];
        -:  239:            
        -:  240:                /* Initialize Registry Record to default settings */
      155:  241:                CFE_TBL_InitRegistryRecord(RegRecPtr);
        -:  242:
      155:  243:                if ((TblOptionFlags & CFE_TBL_OPT_USR_DEF_MSK) != (CFE_TBL_OPT_USR_DEF_ADDR & CFE_TBL_OPT_USR_DEF_MSK))
        -:  244:                {
      153:  245:                    RegRecPtr->UserDefAddr = FALSE;
        -:  246:                
        -:  247:                    /* Allocate the memory buffer(s) for the table and inactive table, if necessary */
      153:  248:                    Status = CFE_ES_GetPoolBuf((uint32 **)&RegRecPtr->Buffers[0].BufferPtr,
        -:  249:                                               CFE_TBL_TaskData.Buf.PoolHdl,                                           
        -:  250:                                               Size);
      153:  251:                    if(Status < 0)
        -:  252:                    {
        3:  253:                        CFE_ES_WriteToSysLog("CFE_TBL:Register-1st Buf Alloc GetPool fail Stat=0x%08X MemPoolHndl=0x%08lX\n",
        -:  254:                                (unsigned int)Status, (unsigned long)CFE_TBL_TaskData.Buf.PoolHdl);
        -:  255:                    }
        -:  256:                    else
        -:  257:                    {
        -:  258:                        /* Zero the memory buffer */
      150:  259:                        Status = CFE_SUCCESS;
      150:  260:                        memset(RegRecPtr->Buffers[0].BufferPtr, 0x0, Size);
        -:  261:                    }
        -:  262:                }
        -:  263:                else
        -:  264:                {
        -:  265:                    /* Set buffer pointer to NULL for user defined address tables */
        2:  266:                    RegRecPtr->Buffers[0].BufferPtr = NULL;
        2:  267:                    RegRecPtr->UserDefAddr = TRUE;
        -:  268:                }
        -:  269:
      168:  270:                if (((TblOptionFlags & CFE_TBL_OPT_DBL_BUFFER) == CFE_TBL_OPT_DBL_BUFFER) &&
        7:  271:                    ((Status & CFE_SEVERITY_BITMASK) != CFE_SEVERITY_ERROR))
        -:  272:                {
        -:  273:                    /* Allocate memory for the dedicated secondary buffer */
        6:  274:                    Status = CFE_ES_GetPoolBuf((uint32 **)&RegRecPtr->Buffers[1].BufferPtr,
        -:  275:                                               CFE_TBL_TaskData.Buf.PoolHdl,                                           
        -:  276:                                               Size);
        6:  277:                    if(Status < 0)
        -:  278:                    {
        1:  279:                        CFE_ES_WriteToSysLog("CFE_TBL:Register-2nd Buf Alloc GetPool fail Stat=0x%08X MemPoolHndl=0x%08lX\n",
        -:  280:                                (unsigned int)Status, (unsigned long)CFE_TBL_TaskData.Buf.PoolHdl);
        -:  281:                    }
        -:  282:                    else
        -:  283:                    {
        -:  284:                        /* Zero the dedicated secondary buffer */
        5:  285:                        Status = CFE_SUCCESS;
        5:  286:                        memset(RegRecPtr->Buffers[1].BufferPtr, 0x0, Size);
        -:  287:                    }
        -:  288:
        6:  289:                    RegRecPtr->ActiveBufferIndex = 0;
        6:  290:                    RegRecPtr->DoubleBuffered = TRUE;
        -:  291:                }
        -:  292:                else  /* Single Buffered Table */
        -:  293:                {
      149:  294:                    RegRecPtr->DoubleBuffered = FALSE;
      149:  295:                    RegRecPtr->ActiveBufferIndex = 0;
        -:  296:                }
        -:  297:            
      155:  298:                if ((Status & CFE_SEVERITY_BITMASK) != CFE_SEVERITY_ERROR)
        -:  299:                {
        -:  300:                    /* Save the size of the table */
      151:  301:                    RegRecPtr->Size = Size;
        -:  302:
        -:  303:                    /* Save the Callback function pointer */
      151:  304:                    RegRecPtr->ValidationFuncPtr = TblValidationFuncPtr;
        -:  305:
        -:  306:                    /* Save Table Name in Registry */
      151:  307:                    strncpy(RegRecPtr->Name, TblName, CFE_TBL_MAX_FULL_NAME_LEN);
        -:  308:
        -:  309:                    /* Set the "Dump Only" flag to value based upon selected option */
      151:  310:                    if ((TblOptionFlags & CFE_TBL_OPT_LD_DMP_MSK) == CFE_TBL_OPT_DUMP_ONLY)
        -:  311:                    {
        4:  312:                        RegRecPtr->DumpOnly = TRUE;
        -:  313:                    }
        -:  314:                    else
        -:  315:                    {
      147:  316:                        RegRecPtr->DumpOnly = FALSE;
        -:  317:                    }
        -:  318:
        -:  319:                    /* Initialize the Table Access Descriptor */
      151:  320:                    AccessDescPtr = &CFE_TBL_TaskData.Handles[*TblHandlePtr];
        -:  321:
      151:  322:                    AccessDescPtr->AppId = ThisAppId;
      151:  323:                    AccessDescPtr->LockFlag = FALSE;
      151:  324:                    AccessDescPtr->Updated = FALSE;
        -:  325:
      151:  326:                    if ((RegRecPtr->DumpOnly) && (!RegRecPtr->UserDefAddr))
        -:  327:                    {
        -:  328:                        /* Dump Only Tables are assumed to be loaded at all times    */
        -:  329:                        /* unless the address is specified by the application. In    */
        -:  330:                        /* that case, it isn't loaded until the address is specified */
        2:  331:                        RegRecPtr->TableLoadedOnce = TRUE;
        -:  332:                    }
        -:  333:
      151:  334:                    AccessDescPtr->RegIndex = RegIndx;
        -:  335:
      151:  336:                    AccessDescPtr->PrevLink = CFE_TBL_END_OF_LIST;         /* We are the head of the list */
      151:  337:                    AccessDescPtr->NextLink = CFE_TBL_END_OF_LIST;         /* We are the end of the list */
        -:  338:
      151:  339:                    AccessDescPtr->UsedFlag = TRUE;
        -:  340:
        -:  341:                    /* Make sure the Table Registry entry points to First Access Descriptor */
      151:  342:                    RegRecPtr->HeadOfAccessList = *TblHandlePtr;
        -:  343:
        -:  344:                    /* If the table is a critical table, allocate space for it in the Critical Data Store */
        -:  345:                    /* OR locate its previous incarnation there and extract its previous contents */
      151:  346:                    if ((TblOptionFlags & CFE_TBL_OPT_CRITICAL_MSK) == CFE_TBL_OPT_CRITICAL)
        -:  347:                    {
        -:  348:                        /* Register a CDS under the table name and determine if the table already exists there */
       11:  349:                        Status = CFE_ES_RegisterCDSEx(&RegRecPtr->CDSHandle, Size, TblName, TRUE);
        -:  350:                
       11:  351:                        if (Status == CFE_ES_CDS_ALREADY_EXISTS)
        -:  352:                        {
        4:  353:                            Status = CFE_TBL_GetWorkingBuffer(&WorkingBufferPtr, RegRecPtr, TRUE);
        -:  354:
        4:  355:                            if (Status != CFE_SUCCESS)
        -:  356:                            {
        -:  357:                                /* Unable to get a working buffer - this error is not really */
        -:  358:                                /* possible at this point during table registration.  But we */
        -:  359:                                /* do need to handle the error case because if the function */
        -:  360:                                /* call did fail, WorkingBufferPtr would be a NULL pointer. */
    #####:  361:                                CFE_ES_GetAppName(AppName, ThisAppId, OS_MAX_API_NAME);
    #####:  362:                                CFE_ES_WriteToSysLog("CFE_TBL:Register-Failed to get work buffer for '%s.%s' (ErrCode=0x%08X)\n",
        -:  363:                                                     AppName, Name, (unsigned int)Status);
        -:  364:                            }
        -:  365:                            else
        -:  366:                            {
        -:  367:                                /* CDS exists for this table - try to restore the data */
        4:  368:                                Status = CFE_ES_RestoreFromCDS(WorkingBufferPtr->BufferPtr, RegRecPtr->CDSHandle);
        -:  369:                        
        4:  370:                                if (Status != CFE_SUCCESS)
        -:  371:                                {
        1:  372:                                    CFE_ES_GetAppName(AppName, ThisAppId, OS_MAX_API_NAME);
        1:  373:                                    CFE_ES_WriteToSysLog("CFE_TBL:Register-Failed to recover '%s.%s' from CDS (ErrCode=0x%08X)\n",
        -:  374:                                                     AppName, Name, (unsigned int)Status);
        -:  375:                                }
        -:  376:                            }
        -:  377:
        4:  378:                            if (Status != CFE_SUCCESS)
        -:  379:                            {
        -:  380:                                /* Treat a restore from existing CDS error the same as */
        -:  381:                                /* after a power-on reset (CDS was created but is empty) */
        1:  382:                                Status = CFE_SUCCESS;     
        -:  383:                            }
        -:  384:                            else
        -:  385:                            {
        -:  386:                                /* Try to locate the associated information in the Critical Table Registry */
        3:  387:                                CFE_TBL_FindCriticalTblInfo(&CritRegRecPtr, RegRecPtr->CDSHandle);
        -:  388:                            
        4:  389:                                if ((CritRegRecPtr != NULL) && (CritRegRecPtr->TableLoadedOnce))
        -:  390:                                {
        1:  391:                                    strncpy(WorkingBufferPtr->DataSource, CritRegRecPtr->LastFileLoaded, OS_MAX_PATH_LEN);
        1:  392:                                    WorkingBufferPtr->FileCreateTimeSecs = CritRegRecPtr->FileCreateTimeSecs;
        1:  393:                                    WorkingBufferPtr->FileCreateTimeSubSecs = CritRegRecPtr->FileCreateTimeSubSecs;
        1:  394:                                    RegRecPtr->TimeOfLastUpdate.Seconds = CritRegRecPtr->TimeOfLastUpdate.Seconds;
        1:  395:                                    RegRecPtr->TimeOfLastUpdate.Subseconds = CritRegRecPtr->TimeOfLastUpdate.Subseconds;
        1:  396:                                    RegRecPtr->TableLoadedOnce = CritRegRecPtr->TableLoadedOnce;
        -:  397:                                    
        -:  398:                                    /* Compute the CRC on the specified table buffer */
        1:  399:                                    WorkingBufferPtr->Crc = CFE_ES_CalculateCRC(WorkingBufferPtr->BufferPtr,
        -:  400:                                                                                RegRecPtr->Size,
        -:  401:                                                                                0,
        -:  402:                                                                                CFE_MISSION_ES_DEFAULT_CRC);
        -:  403:                                
        -:  404:                                    /* Make sure everyone who sees the table knows that it has been updated */
        1:  405:                                    CFE_TBL_NotifyTblUsersOfUpdate(RegRecPtr);
        -:  406:                                
        -:  407:                                    /* Make sure the caller realizes the contents have been initialized */
        1:  408:                                    Status = CFE_TBL_INFO_RECOVERED_TBL;
        -:  409:                                }
        -:  410:                                else
        -:  411:                                {
        -:  412:                                    /* If an error occurred while trying to get the previous contents registry info, */
        -:  413:                                    /* Log the error in the System Log and pretend like we created a new CDS */
        2:  414:                                    CFE_ES_GetAppName(AppName, ThisAppId, OS_MAX_API_NAME);
        2:  415:                                    CFE_ES_WriteToSysLog("CFE_TBL:Register-Failed to recover '%s.%s' info from CDS TblReg\n",
        -:  416:                                                         AppName, Name);
        2:  417:                                    Status = CFE_SUCCESS;     
        -:  418:                                }
        -:  419:                            }
        -:  420:                        
        -:  421:                            /* Mark the table as critical for future reference */
        4:  422:                            RegRecPtr->CriticalTable = TRUE;
        -:  423:                        }
        -:  424:                        
       11:  425:                        if (Status == CFE_SUCCESS)
        -:  426:                        {
        -:  427:                            /* Find and initialize a free entry in the Critical Table Registry */
        9:  428:                            CFE_TBL_FindCriticalTblInfo(&CritRegRecPtr, CFE_ES_CDS_BAD_HANDLE);
        -:  429:                        
        9:  430:                            if (CritRegRecPtr != NULL)
        -:  431:                            {
        8:  432:                                CritRegRecPtr->CDSHandle = RegRecPtr->CDSHandle;
        8:  433:                                strncpy(CritRegRecPtr->Name, TblName, CFE_TBL_MAX_FULL_NAME_LEN);
        8:  434:                                CritRegRecPtr->FileCreateTimeSecs = 0;
        8:  435:                                CritRegRecPtr->FileCreateTimeSubSecs = 0;
        8:  436:                                CritRegRecPtr->LastFileLoaded[0] = '\0';
        8:  437:                                CritRegRecPtr->TimeOfLastUpdate.Seconds = 0;
        8:  438:                                CritRegRecPtr->TimeOfLastUpdate.Subseconds = 0;
        8:  439:                                CritRegRecPtr->TableLoadedOnce = FALSE;
        -:  440:                            
        8:  441:                                CFE_ES_CopyToCDS(CFE_TBL_TaskData.CritRegHandle, CFE_TBL_TaskData.CritReg);
        -:  442:                            }
        -:  443:                            else
        -:  444:                            {
        1:  445:                                CFE_ES_WriteToSysLog("CFE_TBL:Register-Failed to find a free Crit Tbl Reg Rec for '%s'\n", 
        -:  446:                                                     RegRecPtr->Name);
        -:  447:                            }     
        -:  448:                        
        -:  449:                            /* Mark the table as critical for future reference */
        9:  450:                            RegRecPtr->CriticalTable = TRUE;
        -:  451:                        }
        2:  452:                        else if (Status != CFE_TBL_INFO_RECOVERED_TBL)
        -:  453:                        {
        1:  454:                            CFE_ES_WriteToSysLog("CFE_TBL:Register-Failed to register '%s.%s' as a CDS (ErrCode=0x%08X)\n",
        -:  455:                                                 AppName, Name, (unsigned int)Status);
        -:  456:                                                 
        -:  457:                            /* Notify caller that although they asked for it to be critical, it isn't */
        1:  458:                            Status = CFE_TBL_WARN_NOT_CRITICAL;
        -:  459:                        }
        -:  460:                    }
        -:  461:
        -:  462:                    /* The last step of the registration process is claiming ownership.    */
        -:  463:                    /* By making it the last step, other APIs do not have to lock registry */
        -:  464:                    /* to share the table or get its address because registry entries that */
        -:  465:                    /* are unowned are not checked to see if they match names, etc.        */
      151:  466:                    RegRecPtr->OwnerAppId = ThisAppId;
        -:  467:                }
        -:  468:            }
        -:  469:        }
        -:  470:
        -:  471:        /* Unlock Registry for update */
      163:  472:        CFE_TBL_UnlockRegistry();
        -:  473:    }
        -:  474:
        -:  475:    /* On Error conditions, notify ground of screw up */
      176:  476:    if (Status < 0)
        -:  477:    {
        -:  478:        /* Make sure the returned handle is invalid when an error occurs */
       21:  479:        *TblHandlePtr = CFE_TBL_BAD_TABLE_HANDLE;
        -:  480:        
        -:  481:        /* Translate AppID of caller into App Name */
       21:  482:        CFE_ES_GetAppName(AppName, ThisAppId, OS_MAX_API_NAME);
        -:  483:
       21:  484:        CFE_EVS_SendEventWithAppID(CFE_TBL_REGISTER_ERR_EID,
        -:  485:                                   CFE_EVS_EventType_ERROR,
        -:  486:                                   CFE_TBL_TaskData.TableTaskAppId,
        -:  487:                                   "%s Failed to Register '%s', Status=0x%08X",
        -:  488:                                   AppName, TblName, (unsigned int)Status);
        -:  489:    }
        -:  490:
      176:  491:    return Status;
        -:  492:}   /* End of CFE_TBL_Register() */
        -:  493:
        -:  494:
        -:  495:/*******************************************************************
        -:  496:**
        -:  497:** CFE_TBL_Share() -- Obtain handle of table registered by another
        -:  498:**                    application
        -:  499:**
        -:  500:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -:  501:********************************************************************/
        -:  502:
      139:  503:int32 CFE_TBL_Share( CFE_TBL_Handle_t *TblHandlePtr,
        -:  504:                     const char *TblName )
        -:  505:{
      139:  506:    int32   Status = CFE_SUCCESS;
        -:  507:    uint32  ThisAppId;
      139:  508:    int16   RegIndx = CFE_TBL_NOT_FOUND;
      139:  509:    CFE_TBL_AccessDescriptor_t *AccessDescPtr = NULL;
      139:  510:    CFE_TBL_RegistryRec_t      *RegRecPtr = NULL;
      139:  511:    char    AppName[OS_MAX_API_NAME] = {"UNKNOWN"};
        -:  512:
        -:  513:    /* Get a valid Application ID for calling App */
      139:  514:    Status = CFE_TBL_ValidateAppID(&ThisAppId);
        -:  515:
      139:  516:    if (Status == CFE_SUCCESS)
        -:  517:    {
        -:  518:        /* Lock Registry for update.  This prevents two applications from        */
        -:  519:        /* trying to register/share tables at the same location at the same time */
      137:  520:        CFE_TBL_LockRegistry();
        -:  521:
      137:  522:        RegIndx = CFE_TBL_FindTableInRegistry(TblName);
        -:  523:
        -:  524:        /* If we found the table, then get a new Access Descriptor and initialize it */
      137:  525:        if (RegIndx != CFE_TBL_NOT_FOUND)
        -:  526:        {
        -:  527:            /* Get pointer to Registry Record Entry to speed up processing */
      136:  528:            RegRecPtr = &CFE_TBL_TaskData.Registry[RegIndx];
        -:  529:
        -:  530:            /* Search Access Descriptor Array for free Descriptor */
      136:  531:            *TblHandlePtr = CFE_TBL_FindFreeHandle();
        -:  532:
        -:  533:            /* Check to make sure there was a handle available */
      136:  534:            if (*TblHandlePtr == CFE_TBL_END_OF_LIST)
        -:  535:            {
        1:  536:                Status = CFE_TBL_ERR_HANDLES_FULL;
        1:  537:                CFE_ES_WriteToSysLog("CFE_TBL:Share-No more free handles\n");
        -:  538:            }
        -:  539:            else
        -:  540:            {
        -:  541:                /* Initialize the Table Access Descriptor */
      135:  542:                AccessDescPtr = &CFE_TBL_TaskData.Handles[*TblHandlePtr];
        -:  543:
      135:  544:                AccessDescPtr->AppId = ThisAppId;
      135:  545:                AccessDescPtr->LockFlag = FALSE;
      135:  546:                AccessDescPtr->Updated = FALSE;
        -:  547:
        -:  548:                /* Check current state of table in order to set Notification flags properly */
      135:  549:                if (RegRecPtr->TableLoadedOnce)
        -:  550:                {
        3:  551:                    AccessDescPtr->Updated = TRUE;
        -:  552:                }
        -:  553:
      135:  554:                AccessDescPtr->RegIndex = RegIndx;
      135:  555:                AccessDescPtr->UsedFlag = TRUE;
        -:  556:
      135:  557:                AccessDescPtr->PrevLink = CFE_TBL_END_OF_LIST;             /* We are the new head of the list */
      135:  558:                AccessDescPtr->NextLink = RegRecPtr->HeadOfAccessList;
        -:  559:
        -:  560:                /* Make sure the old head of the list now sees this as the head */
      135:  561:                CFE_TBL_TaskData.Handles[RegRecPtr->HeadOfAccessList].PrevLink = *TblHandlePtr;
        -:  562:
        -:  563:                /* Make sure the Registry Record see this as the head of the list */
      135:  564:                RegRecPtr->HeadOfAccessList = *TblHandlePtr;
        -:  565:            }
        -:  566:        }
        -:  567:        else  /* Table could not be found in registry */
        -:  568:        {
        1:  569:            Status = CFE_TBL_ERR_INVALID_NAME;
        -:  570:
        1:  571:            CFE_ES_WriteToSysLog("CFE_TBL:Share-Table '%s' not found in Registry\n", TblName);
        -:  572:        }
        -:  573:
      137:  574:        CFE_TBL_UnlockRegistry();
        -:  575:    }
        -:  576:    else  /* Application ID was invalid */
        -:  577:    {
        2:  578:        CFE_ES_WriteToSysLog("CFE_TBL:Share-Bad AppId(%d)\n", (int)ThisAppId);
        -:  579:    }
        -:  580:
        -:  581:    /* On Error conditions, notify ground of screw up */
      139:  582:    if (Status < 0)
        -:  583:    {
        -:  584:        /* Translate AppID of caller into App Name */
        4:  585:        CFE_ES_GetAppName(AppName, ThisAppId, OS_MAX_API_NAME);
        -:  586:
        4:  587:        CFE_EVS_SendEventWithAppID(CFE_TBL_SHARE_ERR_EID,
        -:  588:                                   CFE_EVS_EventType_ERROR,
        -:  589:                                   CFE_TBL_TaskData.TableTaskAppId,
        -:  590:                                   "%s Failed to Share '%s', Status=0x%08X",
        -:  591:                                   AppName, TblName, (unsigned int)Status);
        -:  592:    }
        -:  593:
      139:  594:    return Status;
        -:  595:}   /* End of CFE_TBL_Share() */
        -:  596:
        -:  597:
        -:  598:/*******************************************************************
        -:  599:**
        -:  600:** CFE_TBL_Unregister() -- Unregister a previously registered
        -:  601:**                         table and free associated resources
        -:  602:**
        -:  603:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -:  604:********************************************************************/
        -:  605:
       19:  606:int32 CFE_TBL_Unregister ( CFE_TBL_Handle_t TblHandle )
        -:  607:{
        -:  608:    int32   Status;
        -:  609:    uint32  ThisAppId;
       19:  610:    CFE_TBL_RegistryRec_t *RegRecPtr = NULL;
       19:  611:    CFE_TBL_AccessDescriptor_t *AccessDescPtr = NULL;
       19:  612:    char    AppName[OS_MAX_API_NAME] = {"UNKNOWN"};
        -:  613:
        -:  614:    /* Verify that this application has the right to perform operation */
       19:  615:    Status = CFE_TBL_ValidateAccess(TblHandle, &ThisAppId);
        -:  616:
       19:  617:    if (Status == CFE_SUCCESS)
        -:  618:    {
        -:  619:        /* Get a pointer to the relevant Access Descriptor */
       18:  620:        AccessDescPtr = &CFE_TBL_TaskData.Handles[TblHandle];
        -:  621:
        -:  622:        /* Get a pointer to the relevant entry in the registry */
       18:  623:        RegRecPtr = &CFE_TBL_TaskData.Registry[AccessDescPtr->RegIndex];
        -:  624:
        -:  625:        /* Verify that the application unregistering the table owns the table */
       18:  626:        if (RegRecPtr->OwnerAppId == ThisAppId)
        -:  627:        {
        -:  628:            /* Mark table as free, although, technically, it isn't free until the */
        -:  629:            /* linked list of Access Descriptors has no links in it.              */
        -:  630:            /* NOTE: Allocated memory is freed when all Access Links have been    */
        -:  631:            /*       removed.  This allows Applications to continue to use the    */
        -:  632:            /*       data until they acknowledge that the table has been removed. */
       14:  633:            RegRecPtr->OwnerAppId = (uint32)CFE_TBL_NOT_OWNED;
        -:  634:
        -:  635:            /* Remove Table Name */
       14:  636:            RegRecPtr->Name[0] = '\0';
        -:  637:        }
        -:  638:
        -:  639:        /* Remove the Access Descriptor Link from linked list */
        -:  640:        /* NOTE: If this removes the last access link, then   */
        -:  641:        /*       memory buffers are set free as well.         */
       18:  642:        CFE_TBL_RemoveAccessLink(TblHandle);
        -:  643:    }
        -:  644:    else
        -:  645:    {
        1:  646:        CFE_ES_WriteToSysLog("CFE_TBL:Unregister-App(%d) does not have access to Tbl Handle=%d\n",
        -:  647:                             (int)ThisAppId, (int)TblHandle);
        -:  648:    }
        -:  649:
        -:  650:    /* On Error conditions, notify ground of screw up */
       19:  651:    if (Status < 0)
        -:  652:    {
        -:  653:        /* Translate AppID of caller into App Name */
        1:  654:        CFE_ES_GetAppName(AppName, ThisAppId, OS_MAX_API_NAME);
        -:  655:
        1:  656:        CFE_EVS_SendEventWithAppID(CFE_TBL_UNREGISTER_ERR_EID,
        -:  657:                                   CFE_EVS_EventType_ERROR,
        -:  658:                                   CFE_TBL_TaskData.TableTaskAppId,
        -:  659:                                   "%s Failed to Unregister '?', Status=0x%08X",
        -:  660:                                   AppName, (unsigned int)Status);
        -:  661:    }
        -:  662:
       19:  663:    return Status;
        -:  664:}   /* End of CFE_TBL_Unregister() */
        -:  665:
        -:  666:
        -:  667:/*******************************************************************
        -:  668:**
        -:  669:** CFE_TBL_Load() -- Load a specified table with data from the
        -:  670:**                   specified source
        -:  671:**
        -:  672:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -:  673:********************************************************************/
        -:  674:
       26:  675:int32 CFE_TBL_Load( CFE_TBL_Handle_t TblHandle,
        -:  676:                    CFE_TBL_SrcEnum_t SrcType,
        -:  677:                    const void *SrcDataPtr )
        -:  678:{
        -:  679:    int32                       Status;
        -:  680:    uint32                      ThisAppId;
        -:  681:    CFE_TBL_LoadBuff_t         *WorkingBufferPtr;
       26:  682:    CFE_TBL_RegistryRec_t      *RegRecPtr = NULL;
        -:  683:    CFE_TBL_AccessDescriptor_t *AccessDescPtr;
       26:  684:    char                        AppName[OS_MAX_API_NAME]={"UNKNOWN"};
       26:  685:    uint16                      EventMsgType = CFE_EVS_EventType_INFORMATION;
       26:  686:    boolean                     FirstTime = FALSE;
        -:  687:
        -:  688:
        -:  689:    /* Initialize return pointer to NULL */
       26:  690:    WorkingBufferPtr = NULL;
        -:  691:
        -:  692:    /* Verify access rights and get a valid Application ID for calling App */
       26:  693:    Status = CFE_TBL_ValidateAccess(TblHandle, &ThisAppId);
        -:  694:
       26:  695:    if (Status == CFE_SUCCESS)
        -:  696:    {
        -:  697:        /* Get pointers to pertinent records in registry and handles */
       24:  698:        AccessDescPtr = &CFE_TBL_TaskData.Handles[TblHandle];
       24:  699:        RegRecPtr = &CFE_TBL_TaskData.Registry[AccessDescPtr->RegIndex];
        -:  700:
        -:  701:        /* Check to see if this is a dump only table */
       24:  702:        if (RegRecPtr->DumpOnly)
        -:  703:        {
        4:  704:            if ((RegRecPtr->UserDefAddr) && (!RegRecPtr->TableLoadedOnce))
        -:  705:            {
        -:  706:                /* The Application is allowed to call Load once when the address  */
        -:  707:                /* of the dump only table is being defined by the application.    */
        1:  708:                RegRecPtr->Buffers[0].BufferPtr = (void *)SrcDataPtr;
        1:  709:                RegRecPtr->TableLoadedOnce = TRUE;
        -:  710:                
        1:  711:                snprintf(RegRecPtr->Buffers[0].DataSource, sizeof(RegRecPtr->Buffers[0].DataSource), 
        -:  712:                     "Addr 0x%08lX", (unsigned long)SrcDataPtr);
        1:  713:                RegRecPtr->Buffers[0].FileCreateTimeSecs = 0;
        1:  714:                RegRecPtr->Buffers[0].FileCreateTimeSubSecs = 0;
        -:  715:
        1:  716:                CFE_EVS_SendEventWithAppID(CFE_TBL_LOAD_SUCCESS_INF_EID,
        -:  717:                                           CFE_EVS_EventType_DEBUG,
        -:  718:                                           CFE_TBL_TaskData.TableTaskAppId,
        -:  719:                                           "Successfully loaded '%s' from '%s'",
        -:  720:                                           RegRecPtr->Name,
        1:  721:                                           RegRecPtr->Buffers[0].DataSource);
        -:  722:            }
        -:  723:            else
        -:  724:            {
        2:  725:                Status = CFE_TBL_ERR_DUMP_ONLY;
        -:  726:
        2:  727:                CFE_ES_WriteToSysLog("CFE_TBL:Load-App(%d) attempted to load Dump Only Tbl '%s'\n",
        -:  728:                                     (int)ThisAppId, RegRecPtr->Name);
        -:  729:            }     
        -:  730:        }
        -:  731:        else
        -:  732:        {
        -:  733:            /* Loads by an Application are not allowed if a table load is already in progress */
       21:  734:            if (RegRecPtr->LoadInProgress != CFE_TBL_NO_LOAD_IN_PROGRESS)
        -:  735:            {
        1:  736:                Status = CFE_TBL_ERR_LOAD_IN_PROGRESS;
        -:  737:
        1:  738:                CFE_ES_WriteToSysLog("CFE_TBL:Load-Tbl Load already in progress for '%s'\n", RegRecPtr->Name);
        -:  739:            }
        -:  740:            else
        -:  741:            {
        -:  742:                /* Obtain a working buffer (either the table's dedicated buffer or one of the shared buffers) */
       20:  743:                Status = CFE_TBL_GetWorkingBuffer(&WorkingBufferPtr, RegRecPtr, TRUE);
        -:  744:
       20:  745:                if (Status == CFE_SUCCESS)
        -:  746:                {
        -:  747:                    /* Perform appropriate update to working buffer */
        -:  748:                    /* Determine whether the load is to occur from a file or from a block of memory */
       19:  749:                    if (SrcType == CFE_TBL_SRC_FILE)
        -:  750:                    {
        -:  751:                        /* Load the data from the file into the specified buffer */
       14:  752:                        Status = CFE_TBL_LoadFromFile(WorkingBufferPtr, RegRecPtr, (const char *)SrcDataPtr);
        -:  753:
       14:  754:                        if (Status < 0)
        -:  755:                        {
        2:  756:                            CFE_ES_WriteToSysLog("CFE_TBL:Load-App(%d) Fail to load Tbl '%s' from '%s' (Stat=0x%08X)\n",
        -:  757:                                                 (int)ThisAppId, RegRecPtr->Name, (const char *)SrcDataPtr, (unsigned int)Status);
        -:  758:                        }
       12:  759:                        else if ((Status == CFE_TBL_WARN_PARTIAL_LOAD) && (!RegRecPtr->TableLoadedOnce))
        -:  760:                        {
        -:  761:                            /* Uninitialized tables cannot be loaded with partial table loads */
        -:  762:                            /* Partial loads can only occur on previously loaded tables.      */
        1:  763:                            Status = CFE_TBL_ERR_PARTIAL_LOAD;
        -:  764:                        }
        -:  765:                    }
        5:  766:                    else if (SrcType == CFE_TBL_SRC_ADDRESS)
        -:  767:                    {
        -:  768:                        /* When the source is a block of memory, it is assumed to be a complete load */
        4:  769:                        memcpy(WorkingBufferPtr->BufferPtr,
        -:  770:                                  (uint8 *)SrcDataPtr,
        4:  771:                                  RegRecPtr->Size);
        -:  772:
        4:  773:                        snprintf(WorkingBufferPtr->DataSource, sizeof(WorkingBufferPtr->DataSource), "Addr 0x%08lX", (unsigned long)SrcDataPtr);
        4:  774:                        WorkingBufferPtr->FileCreateTimeSecs = 0;
        4:  775:                        WorkingBufferPtr->FileCreateTimeSubSecs = 0;
        -:  776:                        
        -:  777:                        /* Compute the CRC on the specified table buffer */
        4:  778:                        WorkingBufferPtr->Crc = CFE_ES_CalculateCRC(WorkingBufferPtr->BufferPtr,
        -:  779:                                                                    RegRecPtr->Size,
        -:  780:                                                                    0,
        -:  781:                                                                    CFE_MISSION_ES_DEFAULT_CRC);
        -:  782:                    }
        -:  783:                    else
        -:  784:                    {
        1:  785:                        Status = CFE_TBL_ERR_ILLEGAL_SRC_TYPE;
        1:  786:                        CFE_ES_WriteToSysLog("CFE_TBL:Load-App(%d) attempt to load from illegal source type=%d\n",
        -:  787:                                             (int)ThisAppId, (int)SrcType);
        -:  788:                    }
        -:  789:
        -:  790:                    /* If the data was successfully loaded, then validate its contents */
       19:  791:                    if ((Status >= CFE_SUCCESS) && (RegRecPtr->ValidationFuncPtr != NULL))
        -:  792:                    {
       12:  793:                        Status = (RegRecPtr->ValidationFuncPtr)(WorkingBufferPtr->BufferPtr);
        -:  794:
       12:  795:                        if (Status > CFE_SUCCESS)
        -:  796:                        {
        1:  797:                            CFE_ES_WriteToSysLog("CFE_TBL:Load-App(%d) Validation func return code invalid (Stat=0x%08X) for '%s'\n",
        -:  798:                                                 (int)ThisAppId, (unsigned int)Status, RegRecPtr->Name);
        1:  799:                            Status = -1;
        -:  800:                        }
        -:  801:                        
       12:  802:                        if (Status < 0)
        -:  803:                        {
        2:  804:                            CFE_ES_WriteToSysLog("CFE_TBL:Load-App(%d) reports load invalid (Stat=0x%08X) for '%s'\n",
        -:  805:                                                 (int)ThisAppId, (unsigned int)Status, RegRecPtr->Name);
        -:  806:                                            
        -:  807:                            /* Zero out the buffer to remove any bad data */
        2:  808:                            memset(WorkingBufferPtr->BufferPtr, 0, RegRecPtr->Size);     
        -:  809:                        }
        -:  810:                    }
        -:  811:
        -:  812:                    /* Perform the table update to complete the load */
       19:  813:                    if (Status >= CFE_SUCCESS)
        -:  814:                    {
       13:  815:                        FirstTime = !RegRecPtr->TableLoadedOnce;
        -:  816:                        
        -:  817:                        /* If this is not the first load, then the data must be moved from the inactive buffer      */
        -:  818:                        /* to the active buffer to complete the load.  First loads are done directly to the active. */
       13:  819:                        if (!FirstTime)
        -:  820:                        {
        -:  821:                            /* Force the table update */
        8:  822:                            RegRecPtr->LoadPending = TRUE;
        -:  823:
        8:  824:                            Status = CFE_TBL_UpdateInternal(TblHandle, RegRecPtr, AccessDescPtr);
        -:  825:                        }
        -:  826:                        else
        -:  827:                        {
        -:  828:                            /* On initial loads, make sure registry is given file/address of data source */
        5:  829:                            strncpy(RegRecPtr->LastFileLoaded,
        5:  830:                                    WorkingBufferPtr->DataSource,
        -:  831:                                    OS_MAX_PATH_LEN);
        -:  832:
        5:  833:                            CFE_TBL_NotifyTblUsersOfUpdate(RegRecPtr);
        -:  834:                                    
        -:  835:                            /* If the table is a critical table, update the appropriate CDS with the new data */
        5:  836:                            if (RegRecPtr->CriticalTable == TRUE)
        -:  837:                            {
        3:  838:                                CFE_TBL_UpdateCriticalTblCDS(RegRecPtr);
        -:  839:                            }
        -:  840:
        5:  841:                            Status = CFE_SUCCESS;
        -:  842:                        }
        -:  843:
       13:  844:                        if (Status != CFE_SUCCESS)
        -:  845:                        {
        1:  846:                            CFE_ES_WriteToSysLog("CFE_TBL:Load-App(%d) fail to update '%s' (Stat=0x%08X)\n",
        -:  847:                                                 (int)ThisAppId, RegRecPtr->Name, (unsigned int)Status);
        -:  848:                        }
        -:  849:                        else
        -:  850:                        {
        -:  851:                            /* The first time a table is loaded, the event message is DEBUG */
        -:  852:                            /* to help eliminate a flood of events during a startup         */
       12:  853:                            if (FirstTime)
        -:  854:                            {
        5:  855:                                EventMsgType = CFE_EVS_EventType_DEBUG;
        -:  856:                            }
        -:  857:
       12:  858:                            CFE_EVS_SendEventWithAppID(CFE_TBL_LOAD_SUCCESS_INF_EID,
        -:  859:                                                       EventMsgType,
        -:  860:                                                       CFE_TBL_TaskData.TableTaskAppId,
        -:  861:                                                       "Successfully loaded '%s' from '%s'",
        -:  862:                                                       RegRecPtr->Name,
        -:  863:                                                       RegRecPtr->LastFileLoaded);
        -:  864:                            
        -:  865:                            /* Save the index of the table for housekeeping telemetry */
       12:  866:                            CFE_TBL_TaskData.LastTblUpdated = AccessDescPtr->RegIndex;       
        -:  867:                        }
        -:  868:                    }
        -:  869:                    else
        -:  870:                    {
        -:  871:                        /* The load has had a problem, free the working buffer for another attempt */
        6:  872:                        if ((!RegRecPtr->DoubleBuffered) && (RegRecPtr->TableLoadedOnce == TRUE))
        -:  873:                        {
        -:  874:                            /* For single buffered tables, freeing entails resetting flag */
        4:  875:                            CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].Taken = FALSE;
        -:  876:                        }
        -:  877:
        -:  878:                        /* For double buffered tables, freeing buffer is simple */
        6:  879:                        RegRecPtr->LoadInProgress = CFE_TBL_NO_LOAD_IN_PROGRESS;
        -:  880:                    }
        -:  881:                }
        -:  882:                else
        -:  883:                {
        1:  884:                    CFE_ES_WriteToSysLog("CFE_TBL:Load-App(%d) Failed to get Working Buffer (Stat=0x%08X)\n",
        -:  885:                                         (int)ThisAppId, (unsigned int)Status);
        -:  886:                }
        -:  887:            }
        -:  888:        }
        -:  889:    }
        -:  890:    else
        -:  891:    {
        2:  892:        CFE_ES_WriteToSysLog("CFE_TBL:Load-App(%d) does not have access to Tbl Handle=%d\n",
        -:  893:                             (int)ThisAppId, (int)TblHandle);
        -:  894:    }
        -:  895:
        -:  896:    /* On Error conditions, notify ground of screw up */
       26:  897:    if (Status < 0)
        -:  898:    {
        -:  899:        /* Translate AppID of caller into App Name */
       12:  900:        CFE_ES_GetAppName(AppName, ThisAppId, OS_MAX_API_NAME);
        -:  901:
       12:  902:        if (RegRecPtr == NULL)
        -:  903:        {
        2:  904:            CFE_EVS_SendEventWithAppID(CFE_TBL_LOAD_ERR_EID,
        -:  905:                                       CFE_EVS_EventType_ERROR,
        -:  906:                                       CFE_TBL_TaskData.TableTaskAppId,
        -:  907:                                       "%s Failed to Load '?', Status=0x%08X",
        -:  908:                                       AppName, (unsigned int)Status);
        -:  909:        }
        -:  910:        else
        -:  911:        {
       10:  912:            if (SrcType == CFE_TBL_SRC_ADDRESS)
        -:  913:            {
        5:  914:                CFE_EVS_SendEventWithAppID(CFE_TBL_LOAD_ERR_EID,
        -:  915:                                           CFE_EVS_EventType_ERROR,
        -:  916:                                           CFE_TBL_TaskData.TableTaskAppId,
        -:  917:                                           "%s Failed to Load '%s' from Addr 0x%08lX, Status=0x%08X",
        -:  918:                                           AppName, RegRecPtr->Name, (unsigned long)SrcDataPtr, (unsigned int)Status);
        -:  919:            }
        5:  920:            else if (SrcType == CFE_TBL_SRC_FILE)
        -:  921:            {
        4:  922:                CFE_EVS_SendEventWithAppID(CFE_TBL_LOAD_ERR_EID,
        -:  923:                                           CFE_EVS_EventType_ERROR,
        -:  924:                                           CFE_TBL_TaskData.TableTaskAppId,
        -:  925:                                           "%s Failed to Load '%s' from '%s', Status=0x%08X",
        -:  926:                                           AppName, RegRecPtr->Name, (const char *)SrcDataPtr, (unsigned int)Status);
        -:  927:            }
        -:  928:            else
        -:  929:            {
        1:  930:                CFE_EVS_SendEventWithAppID(CFE_TBL_LOAD_TYPE_ERR_EID,
        -:  931:                                           CFE_EVS_EventType_ERROR,
        -:  932:                                           CFE_TBL_TaskData.TableTaskAppId,
        -:  933:                                           "%s Failed to Load '%s' (Invalid Source Type)",
        -:  934:                                           AppName, RegRecPtr->Name);
        -:  935:            }
        -:  936:        }
        -:  937:    }
        -:  938:
       26:  939:    return Status;
        -:  940:}   /* End of CFE_TBL_Load() */
        -:  941:
        -:  942:
        -:  943:/*******************************************************************
        -:  944:**
        -:  945:** CFE_TBL_Update() -- Update contents of table if an update
        -:  946:**                     is pending
        -:  947:**
        -:  948:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -:  949:********************************************************************/
        -:  950:
        5:  951:int32 CFE_TBL_Update( CFE_TBL_Handle_t TblHandle )
        -:  952:{
        -:  953:    int32                       Status;
        -:  954:    uint32                      ThisAppId;
        5:  955:    CFE_TBL_RegistryRec_t      *RegRecPtr=NULL;
        5:  956:    CFE_TBL_AccessDescriptor_t *AccessDescPtr=NULL;
        5:  957:    char                        AppName[OS_MAX_API_NAME]={"UNKNOWN"};
        -:  958:
        -:  959:    /* Verify access rights and get a valid Application ID for calling App */
        5:  960:    Status = CFE_TBL_ValidateAccess(TblHandle, &ThisAppId);
        -:  961:
        5:  962:    if (Status == CFE_SUCCESS)
        -:  963:    {
        -:  964:        /* Get pointers to pertinent records in registry and handles */
        3:  965:        AccessDescPtr = &CFE_TBL_TaskData.Handles[TblHandle];
        3:  966:        RegRecPtr = &CFE_TBL_TaskData.Registry[AccessDescPtr->RegIndex];
        -:  967:
        3:  968:        Status = CFE_TBL_UpdateInternal(TblHandle, RegRecPtr, AccessDescPtr);
        -:  969:
        3:  970:        if (Status != CFE_SUCCESS)
        -:  971:        {
        2:  972:            CFE_ES_WriteToSysLog("CFE_TBL:Update-App(%d) fail to update Tbl '%s' (Stat=0x%08X)\n",
        -:  973:                                 (int)ThisAppId, RegRecPtr->Name, (unsigned int)Status);
        -:  974:        }
        -:  975:    }
        -:  976:    else
        -:  977:    {
        2:  978:        CFE_ES_WriteToSysLog("CFE_TBL:Update-App(%d) does not have access to Tbl Handle=%d\n", (int)ThisAppId, (int)TblHandle);
        -:  979:    }
        -:  980:
        5:  981:    if (Status != CFE_TBL_ERR_BAD_APP_ID)
        -:  982:    {
        -:  983:        /* Translate AppID of caller into App Name */
        4:  984:        CFE_ES_GetAppName(AppName, ThisAppId, OS_MAX_API_NAME);
        -:  985:    }
        -:  986:    
        -:  987:    /* On Error conditions, notify ground of screw up */
        5:  988:    if (Status < 0)
        -:  989:    {
        2:  990:        if (RegRecPtr != NULL)
        -:  991:        {
    #####:  992:            CFE_EVS_SendEventWithAppID(CFE_TBL_UPDATE_ERR_EID,
        -:  993:                                       CFE_EVS_EventType_ERROR,
        -:  994:                                       CFE_TBL_TaskData.TableTaskAppId,
        -:  995:                                       "%s Failed to Update '%s', Status=0x%08X",
        -:  996:                                       AppName, RegRecPtr->Name, (unsigned int)Status);
        -:  997:        }
        -:  998:        else
        -:  999:        {
        2: 1000:            CFE_EVS_SendEventWithAppID(CFE_TBL_UPDATE_ERR_EID,
        -: 1001:                                       CFE_EVS_EventType_ERROR,
        -: 1002:                                       CFE_TBL_TaskData.TableTaskAppId,
        -: 1003:                                       "%s Failed to Update '?', Status=0x%08X",
        -: 1004:                                       AppName, (unsigned int)Status);
        -: 1005:        }
        -: 1006:    }
        -: 1007:    else
        -: 1008:    {
        -: 1009:        /* If there was a warning (ie - Table is currently locked), then do not issue a message */
        3: 1010:        if (Status == CFE_SUCCESS)
        -: 1011:        {
        1: 1012:            CFE_EVS_SendEventWithAppID(CFE_TBL_UPDATE_SUCCESS_INF_EID,
        -: 1013:                                       CFE_EVS_EventType_INFORMATION,
        -: 1014:                                       CFE_TBL_TaskData.TableTaskAppId,
        -: 1015:                                       "%s Successfully Updated '%s'",
        -: 1016:                                       AppName, RegRecPtr->Name);
        -: 1017:                            
        -: 1018:            /* Save the index of the table for housekeeping telemetry */
        1: 1019:            CFE_TBL_TaskData.LastTblUpdated = AccessDescPtr->RegIndex;
        -: 1020:        }       
        -: 1021:    }
        -: 1022:
        5: 1023:    return Status;
        -: 1024:}   /* End of CFE_TBL_Update() */
        -: 1025:
        -: 1026:
        -: 1027:/*******************************************************************
        -: 1028:**
        -: 1029:** CFE_TBL_GetAddress() -- Obtain the current address of the
        -: 1030:**                         contents of the specified table
        -: 1031:**
        -: 1032:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -: 1033:********************************************************************/
        -: 1034:
       11: 1035:int32 CFE_TBL_GetAddress( void **TblPtr,
        -: 1036:                          CFE_TBL_Handle_t TblHandle )
        -: 1037:{
       11: 1038:    int32   Status = CFE_SUCCESS;
        -: 1039:    uint32  ThisAppId;
        -: 1040:
        -: 1041:    /* Assume failure at returning the table address */
       11: 1042:    *TblPtr = NULL;
        -: 1043:
        -: 1044:    /* Validate the calling application's AppID */
       11: 1045:    Status = CFE_TBL_ValidateAppID(&ThisAppId);
        -: 1046:
       11: 1047:    if (Status == CFE_SUCCESS)
        -: 1048:    {
       10: 1049:        Status = CFE_TBL_GetAddressInternal(TblPtr, TblHandle, ThisAppId);
        -: 1050:
        -: 1051:        /* NOTE: GetAddressInternal calls GetNextNotification which may not */
        -: 1052:        /*       be equal to CFE_SUCCESS and still not be an error.         */
        -: 1053:        /*       Therefore, a write to the SysLog is unnecessary.           */
        -: 1054:    }
        -: 1055:    else
        -: 1056:    {
        1: 1057:        CFE_ES_WriteToSysLog("CFE_TBL:GetAddress-Bad AppId=%d\n", (int)ThisAppId);
        -: 1058:    }
        -: 1059:
       11: 1060:    return Status;
        -: 1061:}   /* End of CFE_TBL_GetAddress() */
        -: 1062:
        -: 1063:/*******************************************************************
        -: 1064:**
        -: 1065:** CFE_TBL_ReleaseAddress() -- Release previously obtained pointer
        -: 1066:**                          to the contents of the specified table
        -: 1067:**
        -: 1068:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -: 1069:********************************************************************/
        -: 1070:
        8: 1071:int32 CFE_TBL_ReleaseAddress( CFE_TBL_Handle_t TblHandle )
        -: 1072:{
        -: 1073:    int32   Status;
        -: 1074:    uint32  ThisAppId;
        -: 1075:
        -: 1076:    /* Verify that this application has the right to perform operation */
        8: 1077:    Status = CFE_TBL_ValidateAccess(TblHandle, &ThisAppId);
        -: 1078:
        8: 1079:    if (Status == CFE_SUCCESS)
        -: 1080:    {
        -: 1081:        /* Clear the lock flag */
        7: 1082:        CFE_TBL_TaskData.Handles[TblHandle].LockFlag = FALSE;
        -: 1083:
        -: 1084:        /* Return any pending warning or info status indicators */
        7: 1085:        Status = CFE_TBL_GetNextNotification(TblHandle);
        -: 1086:
        -: 1087:        /* NOTE: GetNextNotification may not return CFE_SUCCESS  */
        -: 1088:        /*       and still not be an error.                      */
        -: 1089:        /*       Therefore, a write to the SysLog is unnecessary.*/
        -: 1090:    }
        -: 1091:    else
        -: 1092:    {
        1: 1093:        CFE_ES_WriteToSysLog("CFE_TBL:ReleaseAddress-App(%d) does not have access to Tbl Handle=%d\n",
        -: 1094:                             (int)ThisAppId, (int)TblHandle);
        -: 1095:    }
        -: 1096:
        8: 1097:    return Status;
        -: 1098:}   /* End of CFE_TBL_ReleaseAddress() */
        -: 1099:
        -: 1100:/*******************************************************************
        -: 1101:**
        -: 1102:** CFE_TBL_GetAddresses() -- Obtain the current addresses of the contents of a collection of tables.
        -: 1103:**                           If an addsses.  Failure return codes
        -: 1104:**                           only apply to the first table that was unsuccessful.
        -: 1105:**
        -: 1106:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -: 1107:********************************************************************/
        -: 1108:
        2: 1109:int32 CFE_TBL_GetAddresses( void **TblPtrs[],
        -: 1110:                            uint16 NumTables,
        -: 1111:                            const CFE_TBL_Handle_t TblHandles[] )
        -: 1112:{
        -: 1113:    uint16  i;
        2: 1114:    int32   Status = CFE_SUCCESS;
        -: 1115:    uint32  ThisAppId;
        -: 1116:
        -: 1117:    /* Assume failure at returning the table addresses */
        6: 1118:    for (i=0; i<NumTables; i++)
        -: 1119:    {
        4: 1120:        *TblPtrs[i] = NULL;
        -: 1121:    }
        -: 1122:
        -: 1123:    /* Validate the calling application's AppID */
        2: 1124:    Status = CFE_TBL_ValidateAppID(&ThisAppId);
        -: 1125:
        2: 1126:    if (Status == CFE_SUCCESS)
        -: 1127:    {
        3: 1128:        for (i=0; i<NumTables; i++)
        -: 1129:        {
        -: 1130:            /* Continue to get the return status until one returns something other than CFE_SUCCESS */
        2: 1131:            if (Status == CFE_SUCCESS)
        -: 1132:            {
        1: 1133:                Status = CFE_TBL_GetAddressInternal(TblPtrs[i], TblHandles[i], ThisAppId);
        -: 1134:            }
        -: 1135:            else
        -: 1136:            {
        -: 1137:                /* Don't bother getting the status of other tables once one has returned */
        -: 1138:                /* a non CFE_SUCCESS value.                                              */
        1: 1139:                CFE_TBL_GetAddressInternal(TblPtrs[i], TblHandles[i], ThisAppId);
        -: 1140:            }
        -: 1141:        }
        -: 1142:    }
        -: 1143:    else
        -: 1144:    {
        1: 1145:        CFE_ES_WriteToSysLog("CFE_TBL:GetAddresses-Bad AppId=%d\n", (int)ThisAppId);
        -: 1146:    }
        -: 1147:
        2: 1148:    return Status;
        -: 1149:}   /* End of CFE_TBL_GetAddresses() */
        -: 1150:
        -: 1151:/*******************************************************************
        -: 1152:**
        -: 1153:** CFE_TBL_ReleaseAddresses() -- Release previously obtained
        -: 1154:**             pointers to the contents of the specified tables
        -: 1155:**
        -: 1156:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -: 1157:********************************************************************/
        -: 1158:
        1: 1159:int32 CFE_TBL_ReleaseAddresses( uint16 NumTables,
        -: 1160:                                const CFE_TBL_Handle_t TblHandles[] )
        -: 1161:{
        1: 1162:    int32   Status = CFE_SUCCESS;
        -: 1163:    uint16  i;
        -: 1164:
        3: 1165:    for (i=0; i<NumTables; i++)
        -: 1166:    {
        -: 1167:        /* Continue to get the return status until one returns something other than CFE_SUCCESS */
        2: 1168:        if (Status == CFE_SUCCESS)
        -: 1169:        {
        1: 1170:            Status = CFE_TBL_ReleaseAddress(TblHandles[i]);
        -: 1171:        }
        -: 1172:        else
        -: 1173:        {
        -: 1174:            /* Don't bother getting the status of other tables once one has returned */
        -: 1175:            /* a non CFE_SUCCESS value.                                              */
        1: 1176:            CFE_TBL_ReleaseAddress(TblHandles[i]);
        -: 1177:        }
        -: 1178:    }
        -: 1179:
        1: 1180:    return Status;
        -: 1181:}   /* End of CFE_TBL_ReleaseAddresses() */
        -: 1182:
        -: 1183:
        -: 1184:/*******************************************************************
        -: 1185:**
        -: 1186:** CFE_TBL_Validate() -- Validate a table image for the specified table
        -: 1187:**
        -: 1188:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -: 1189:********************************************************************/
        -: 1190:
       12: 1191:int32 CFE_TBL_Validate( CFE_TBL_Handle_t TblHandle )
        -: 1192:{
       12: 1193:    int32                       Status = CFE_SUCCESS;
        -: 1194:    uint32                      ThisAppId;
        -: 1195:    CFE_TBL_RegistryRec_t      *RegRecPtr;
        -: 1196:    CFE_TBL_AccessDescriptor_t *AccessDescPtr;
       12: 1197:    char                        AppName[OS_MAX_API_NAME]={"UNKNWON"};
        -: 1198:
        -: 1199:    /* Verify that this application has the right to perform operation */
       12: 1200:    Status = CFE_TBL_ValidateAccess(TblHandle, &ThisAppId);
        -: 1201:
       12: 1202:    if (Status == CFE_SUCCESS)
        -: 1203:    {
        -: 1204:        /* Get pointers to pertinent records in registry and handles */
       11: 1205:        AccessDescPtr = &CFE_TBL_TaskData.Handles[TblHandle];
       11: 1206:        RegRecPtr = &CFE_TBL_TaskData.Registry[AccessDescPtr->RegIndex];
        -: 1207:
       11: 1208:        CFE_ES_GetAppName(AppName, ThisAppId, OS_MAX_API_NAME);
        -: 1209:
        -: 1210:        /* Identify the image to be validated, starting with the Inactive Buffer */
       11: 1211:        if (RegRecPtr->ValidateInactiveIndex != CFE_TBL_NO_VALIDATION_PENDING)
        -: 1212:        {
        -: 1213:            /* Identify whether the Inactive Buffer is a shared buffer or a dedicated one */
        5: 1214:            if (RegRecPtr->DoubleBuffered)
        -: 1215:            {
        -: 1216:                /* Call the Application's Validation function for the Inactive Buffer */
        2: 1217:                Status = (RegRecPtr->ValidationFuncPtr)(RegRecPtr->Buffers[(1U-RegRecPtr->ActiveBufferIndex)].BufferPtr);
        -: 1218:                
        -: 1219:                /* Allow buffer to be activated after passing validation */
        2: 1220:                if (Status == CFE_SUCCESS)
        -: 1221:                {
        1: 1222:                    RegRecPtr->Buffers[(1U-RegRecPtr->ActiveBufferIndex)].Validated = TRUE;       
        -: 1223:                }
        -: 1224:            }
        -: 1225:            else
        -: 1226:            {
        -: 1227:                /* Call the Application's Validation function for the appropriate shared buffer */
        6: 1228:                Status = (RegRecPtr->ValidationFuncPtr)
        3: 1229:                          (CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].BufferPtr);
        -: 1230:                
        -: 1231:                /* Allow buffer to be activated after passing validation */
        3: 1232:                if (Status == CFE_SUCCESS)
        -: 1233:                {
        1: 1234:                    CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].Validated = TRUE;       
        -: 1235:                }
        -: 1236:            }
        -: 1237:
        5: 1238:            if (Status == CFE_SUCCESS)
        -: 1239:            {
        2: 1240:                CFE_EVS_SendEventWithAppID(CFE_TBL_VALIDATION_INF_EID,
        -: 1241:                                           CFE_EVS_EventType_INFORMATION,
        -: 1242:                                           CFE_TBL_TaskData.TableTaskAppId,
        -: 1243:                                           "%s validation successful for Inactive '%s'",
        -: 1244:                                           AppName, RegRecPtr->Name);
        -: 1245:            }
        -: 1246:            else
        -: 1247:            {
        3: 1248:                CFE_EVS_SendEventWithAppID(CFE_TBL_VALIDATION_ERR_EID,
        -: 1249:                                           CFE_EVS_EventType_ERROR,
        -: 1250:                                           CFE_TBL_TaskData.TableTaskAppId,
        -: 1251:                                           "%s validation failed for Inactive '%s', Status=0x%08X",
        -: 1252:                                           AppName, RegRecPtr->Name, (unsigned int)Status);
        -: 1253:                
        3: 1254:                if (Status > CFE_SUCCESS)
        -: 1255:                {
        1: 1256:                    CFE_ES_WriteToSysLog("CFE_TBL:Validate-App(%u) Validation func return code invalid (Stat=0x%08X) for '%s'\n",
        -: 1257:                            (unsigned int)CFE_TBL_TaskData.TableTaskAppId, (unsigned int)Status, RegRecPtr->Name);
        -: 1258:                }
        -: 1259:            }
        -: 1260:
        -: 1261:            /* Save the result of the Validation function for the Table Services Task */
        5: 1262:            CFE_TBL_TaskData.ValidationResults[RegRecPtr->ValidateInactiveIndex].Result = Status;
        -: 1263:
        -: 1264:            /* Once validation is complete, set flags to indicate response is ready */
        5: 1265:            CFE_TBL_TaskData.ValidationResults[RegRecPtr->ValidateInactiveIndex].State = CFE_TBL_VALIDATION_PERFORMED;
        5: 1266:            RegRecPtr->ValidateInactiveIndex = CFE_TBL_NO_VALIDATION_PENDING;
        -: 1267:
        -: 1268:            /* Since the validation was successfully performed (although maybe not a successful result) */
        -: 1269:            /* return a success status */
        5: 1270:            Status = CFE_SUCCESS;
        -: 1271:        }
        6: 1272:        else if (RegRecPtr->ValidateActiveIndex != CFE_TBL_NO_VALIDATION_PENDING)
        -: 1273:        {
        -: 1274:            /* Perform validation on the currently active table buffer */
        -: 1275:            /* Identify whether the Active Buffer is a shared buffer or a dedicated one */
        5: 1276:            if (RegRecPtr->DoubleBuffered)
        -: 1277:            {
        -: 1278:                /* Call the Application's Validation function for the Dedicated Active Buffer */
        2: 1279:                Status = (RegRecPtr->ValidationFuncPtr)(RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].BufferPtr);
        -: 1280:            }
        -: 1281:            else
        -: 1282:            {
        -: 1283:                /* Call the Application's Validation function for the static buffer */
        3: 1284:                Status = (RegRecPtr->ValidationFuncPtr)(RegRecPtr->Buffers[0].BufferPtr);
        -: 1285:            }
        -: 1286:
        5: 1287:            if (Status == CFE_SUCCESS)
        -: 1288:            {
        2: 1289:                CFE_EVS_SendEventWithAppID(CFE_TBL_VALIDATION_INF_EID,
        -: 1290:                                           CFE_EVS_EventType_INFORMATION,
        -: 1291:                                           CFE_TBL_TaskData.TableTaskAppId,
        -: 1292:                                           "%s validation successful for Active '%s'",
        -: 1293:                                           AppName, RegRecPtr->Name);
        -: 1294:            }
        -: 1295:            else
        -: 1296:            {
        3: 1297:                CFE_EVS_SendEventWithAppID(CFE_TBL_VALIDATION_ERR_EID,
        -: 1298:                                           CFE_EVS_EventType_ERROR,
        -: 1299:                                           CFE_TBL_TaskData.TableTaskAppId,
        -: 1300:                                           "%s validation failed for Active '%s', Status=0x%08X",
        -: 1301:                                           AppName, RegRecPtr->Name, (unsigned int)Status);
        -: 1302:                
        3: 1303:                if (Status > CFE_SUCCESS)
        -: 1304:                {
        1: 1305:                    CFE_ES_WriteToSysLog("CFE_TBL:Validate-App(%u) Validation func return code invalid (Stat=0x%08X) for '%s'\n",
        -: 1306:                            (unsigned int)CFE_TBL_TaskData.TableTaskAppId, (unsigned int)Status, RegRecPtr->Name);
        -: 1307:                }
        -: 1308:            }
        -: 1309:
        -: 1310:            /* Save the result of the Validation function for the Table Services Task */
        5: 1311:            CFE_TBL_TaskData.ValidationResults[RegRecPtr->ValidateActiveIndex].Result = Status;
        -: 1312:
        -: 1313:            /* Once validation is complete, reset the flags */
        5: 1314:            CFE_TBL_TaskData.ValidationResults[RegRecPtr->ValidateActiveIndex].State = CFE_TBL_VALIDATION_PERFORMED;
        5: 1315:            RegRecPtr->ValidateActiveIndex = CFE_TBL_NO_VALIDATION_PENDING;
        -: 1316:
        -: 1317:            /* Since the validation was successfully performed (although maybe not a successful result) */
        -: 1318:            /* return a success status */
        5: 1319:            Status = CFE_SUCCESS;
        -: 1320:        }
        -: 1321:        else
        -: 1322:        {
        1: 1323:            Status = CFE_TBL_INFO_NO_VALIDATION_PENDING;
        -: 1324:        }
        -: 1325:    }
        -: 1326:    else
        -: 1327:    {
        1: 1328:        CFE_ES_WriteToSysLog("CFE_TBL:Validate-App(%d) does not have access to Tbl Handle=%d\n",
        -: 1329:                             (int)ThisAppId, (int)TblHandle);
        -: 1330:    }
        -: 1331:
       12: 1332:    return Status;
        -: 1333:}   /* End of CFE_TBL_Validate() */
        -: 1334:
        -: 1335:
        -: 1336:/*******************************************************************
        -: 1337:**
        -: 1338:** CFE_TBL_Manage() -- Perform standard table maintenance on the
        -: 1339:**                     specified table
        -: 1340:**
        -: 1341:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -: 1342:********************************************************************/
        -: 1343:
       14: 1344:int32 CFE_TBL_Manage( CFE_TBL_Handle_t TblHandle )
        -: 1345:{
       14: 1346:    int32   Status = CFE_SUCCESS;
       14: 1347:    boolean FinishedManaging = FALSE;
        -: 1348:
       52: 1349:    while (!FinishedManaging)
        -: 1350:    {
        -: 1351:        /* Determine if the table has a validation or update that needs to be performed */
       24: 1352:        Status = CFE_TBL_GetStatus(TblHandle);
        -: 1353:
       24: 1354:        if (Status == CFE_TBL_INFO_VALIDATION_PENDING)
        -: 1355:        {
        -: 1356:            /* Validate the specified Table */
       10: 1357:            Status = CFE_TBL_Validate(TblHandle);
        -: 1358:
       10: 1359:            if (Status != CFE_SUCCESS)
        -: 1360:            {
        -: 1361:                /* If an error occurred during Validate, then do not perform any more managing */
    #####: 1362:                FinishedManaging = TRUE;
        -: 1363:            }
        -: 1364:        }
       14: 1365:        else if (Status == CFE_TBL_INFO_DUMP_PENDING)
        -: 1366:        {
        -: 1367:            /* Dump the specified Table */
        1: 1368:            Status = CFE_TBL_DumpToBuffer(TblHandle);
        -: 1369:            
        -: 1370:            /* After a Dump, always assume we are done (Dumps are on DumpOnly tables and cannot be "Updated") */
        1: 1371:            FinishedManaging = TRUE;
        -: 1372:        }
       13: 1373:        else if (Status == CFE_TBL_INFO_UPDATE_PENDING)
        -: 1374:        {
        -: 1375:            /* Update the specified Table */
        2: 1376:            Status = CFE_TBL_Update(TblHandle);
        -: 1377:
        -: 1378:            /* If the update performed nominally, let the caller know the table has changed */
        2: 1379:            if (Status == CFE_SUCCESS)
        -: 1380:            {
        1: 1381:                Status = CFE_TBL_INFO_UPDATED;
        -: 1382:            }
        -: 1383:            
        -: 1384:            /* After an Update, always assume we are done and return Update Status */
        2: 1385:            FinishedManaging = TRUE;
        -: 1386:        }
        -: 1387:        else
        -: 1388:        {
       11: 1389:            FinishedManaging = TRUE;
        -: 1390:        }
        -: 1391:    }
        -: 1392:
       14: 1393:    return Status;
        -: 1394:}   /* End of CFE_TBL_Manage() */
        -: 1395:
        -: 1396:
        -: 1397:/*******************************************************************
        -: 1398:**
        -: 1399:** CFE_TBL_GetStatus() -- Obtain pending action status for specified table
        -: 1400:**
        -: 1401:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -: 1402:********************************************************************/
        -: 1403:
       27: 1404:int32 CFE_TBL_GetStatus( CFE_TBL_Handle_t TblHandle )
        -: 1405:{
       27: 1406:    int32                       Status = CFE_SUCCESS;
        -: 1407:    uint32                      ThisAppId;
        -: 1408:    CFE_TBL_RegistryRec_t      *RegRecPtr;
        -: 1409:    CFE_TBL_AccessDescriptor_t *AccessDescPtr;
        -: 1410:
        -: 1411:    /* Verify that this application has the right to perform operation */
       27: 1412:    Status = CFE_TBL_ValidateAccess(TblHandle, &ThisAppId);
        -: 1413:
       27: 1414:    if (Status == CFE_SUCCESS)
        -: 1415:    {
        -: 1416:        /* Get pointers to pertinent records in registry and handles */
       25: 1417:        AccessDescPtr = &CFE_TBL_TaskData.Handles[TblHandle];
       25: 1418:        RegRecPtr = &CFE_TBL_TaskData.Registry[AccessDescPtr->RegIndex];
        -: 1419:
        -: 1420:        /* Perform validations prior to performing any updates */
       25: 1421:        if (RegRecPtr->LoadPending)
        -: 1422:        {
        2: 1423:            Status = CFE_TBL_INFO_UPDATE_PENDING;
        -: 1424:        }
       51: 1425:        else if ((RegRecPtr->ValidateActiveIndex != CFE_TBL_NO_VALIDATION_PENDING) ||
       18: 1426:                 (RegRecPtr->ValidateInactiveIndex != CFE_TBL_NO_VALIDATION_PENDING))
        -: 1427:        {
       10: 1428:            Status = CFE_TBL_INFO_VALIDATION_PENDING;
        -: 1429:        }
       13: 1430:        else if (RegRecPtr->DumpControlIndex != CFE_TBL_NO_DUMP_PENDING)
        -: 1431:        {
        2: 1432:            Status = CFE_TBL_INFO_DUMP_PENDING;
        -: 1433:        }
        -: 1434:    }
        -: 1435:    else
        -: 1436:    {
        2: 1437:        CFE_ES_WriteToSysLog("CFE_TBL:GetStatus-App(%d) does not have access to Tbl Handle=%d\n",
        -: 1438:                             (int)ThisAppId, (int)TblHandle);
        -: 1439:    }
        -: 1440:
       27: 1441:    return Status;
        -: 1442:}   /* End of CFE_TBL_GetStatus() */
        -: 1443:
        -: 1444:
        -: 1445:/*******************************************************************
        -: 1446:**
        -: 1447:** CFE_TBL_GetInfo() -- Obtain characteristics/information for specified table
        -: 1448:**
        -: 1449:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -: 1450:********************************************************************/
        -: 1451:
        4: 1452:int32 CFE_TBL_GetInfo( CFE_TBL_Info_t *TblInfoPtr, const char *TblName )
        -: 1453:{
        4: 1454:    int32                    Status = CFE_SUCCESS;
        -: 1455:    int16                    RegIndx;
        4: 1456:    int32                    NumAccessDescriptors = 0;
        -: 1457:    CFE_TBL_RegistryRec_t   *RegRecPtr;
        -: 1458:    CFE_TBL_Handle_t         HandleIterator;
        -: 1459:
        4: 1460:    RegIndx = CFE_TBL_FindTableInRegistry(TblName);
        -: 1461:
        -: 1462:    /* If we found the table, then extract the information from the Registry */
        4: 1463:    if (RegIndx != CFE_TBL_NOT_FOUND)
        -: 1464:    {
        -: 1465:        /* Get pointer to Registry Record Entry to speed up processing */
        3: 1466:        RegRecPtr = &CFE_TBL_TaskData.Registry[RegIndx];
        -: 1467:
        -: 1468:        /* Return table characteristics */        
        3: 1469:        TblInfoPtr->Size        = RegRecPtr->Size;
        3: 1470:        TblInfoPtr->DoubleBuffered = RegRecPtr->DoubleBuffered;
        3: 1471:        TblInfoPtr->DumpOnly    = RegRecPtr->DumpOnly;
        3: 1472:        TblInfoPtr->UserDefAddr = RegRecPtr->UserDefAddr;
        3: 1473:        TblInfoPtr->TableLoadedOnce = RegRecPtr->TableLoadedOnce;
        -: 1474:        
        -: 1475:        /* Return information on last load and update */
        3: 1476:        TblInfoPtr->TimeOfLastUpdate = RegRecPtr->TimeOfLastUpdate;
        3: 1477:        TblInfoPtr->FileCreateTimeSecs = RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].FileCreateTimeSecs;
        3: 1478:        TblInfoPtr->FileCreateTimeSubSecs = RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].FileCreateTimeSubSecs;
        3: 1479:        TblInfoPtr->Crc = RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].Crc;
        3: 1480:        strncpy(TblInfoPtr->LastFileLoaded, RegRecPtr->LastFileLoaded, OS_MAX_PATH_LEN);
        -: 1481:        
        -: 1482:        /* Count the number of Access Descriptors to determine the number of users */
        3: 1483:        HandleIterator = RegRecPtr->HeadOfAccessList;
       11: 1484:        while (HandleIterator != CFE_TBL_END_OF_LIST)
        -: 1485:        {
        5: 1486:            NumAccessDescriptors++;
        5: 1487:            HandleIterator = CFE_TBL_TaskData.Handles[HandleIterator].NextLink;
        -: 1488:        }
        -: 1489:
        3: 1490:        TblInfoPtr->NumUsers = NumAccessDescriptors;
        -: 1491:        
        3: 1492:        TblInfoPtr->Critical = RegRecPtr->CriticalTable;  
        -: 1493:    }
        -: 1494:    else
        -: 1495:    {
        1: 1496:        Status = CFE_TBL_ERR_INVALID_NAME;
        -: 1497:    }
        -: 1498:
        4: 1499:    return Status;
        -: 1500:}   /* End of CFE_TBL_GetInfo() */
        -: 1501:
        -: 1502:/*******************************************************************
        -: 1503:**
        -: 1504:** CFE_TBL_DumpToBuffer - Copy Dump Only table to buffer for later dump to file by table services
        -: 1505:**
        -: 1506:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -: 1507:********************************************************************/
        -: 1508:
        2: 1509:int32 CFE_TBL_DumpToBuffer( CFE_TBL_Handle_t TblHandle )
        -: 1510:{
        2: 1511:    int32                       Status = CFE_SUCCESS;
        2: 1512:    CFE_TBL_AccessDescriptor_t *AccessDescPtr = NULL;
        2: 1513:    CFE_TBL_RegistryRec_t      *RegRecPtr = NULL;
        2: 1514:    CFE_TBL_DumpControl_t      *DumpCtrlPtr = NULL;
        -: 1515:    CFE_TIME_SysTime_t          DumpTime;
        -: 1516:    
        -: 1517:    /* Make sure the table has been requested to be dumped */
        2: 1518:    Status = CFE_TBL_GetStatus(TblHandle);
        2: 1519:    if (Status == CFE_TBL_INFO_DUMP_PENDING)
        -: 1520:    {
        1: 1521:        AccessDescPtr = &CFE_TBL_TaskData.Handles[TblHandle];
        1: 1522:        RegRecPtr = &CFE_TBL_TaskData.Registry[AccessDescPtr->RegIndex];
        1: 1523:        DumpCtrlPtr = &CFE_TBL_TaskData.DumpControlBlocks[RegRecPtr->DumpControlIndex];
        -: 1524:        
        -: 1525:        /* Copy the contents of the active buffer to the assigned dump buffer */
        1: 1526:        memcpy(DumpCtrlPtr->DumpBufferPtr->BufferPtr, RegRecPtr->Buffers[0].BufferPtr, DumpCtrlPtr->Size);
        -: 1527:        
        -: 1528:        /* Save the current time so that the header in the dump file can have the correct time */
        1: 1529:        DumpTime = CFE_TIME_GetTime();
        1: 1530:        DumpCtrlPtr->DumpBufferPtr->FileCreateTimeSecs = DumpTime.Seconds;
        1: 1531:        DumpCtrlPtr->DumpBufferPtr->FileCreateTimeSubSecs = DumpTime.Subseconds;
        -: 1532:        
        -: 1533:        /* Disassociate the dump request from the table */
        1: 1534:        RegRecPtr->DumpControlIndex = CFE_TBL_NO_DUMP_PENDING;
        -: 1535:        
        -: 1536:        /* Notify the Table Services Application that the dump buffer is ready to be written to a file */
        1: 1537:        DumpCtrlPtr->State = CFE_TBL_DUMP_PERFORMED;
        -: 1538:        
        1: 1539:        Status = CFE_SUCCESS;
        -: 1540:    }
        -: 1541:    
        2: 1542:    return Status;
        -: 1543:}   /* End of CFE_TBL_DumpToBuffer() */
        -: 1544:
        -: 1545:
        -: 1546:/*******************************************************************
        -: 1547:**
        -: 1548:** CFE_TBL_Modified - Notify TBL Services that the contents of the table has been modified by the application
        -: 1549:**
        -: 1550:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -: 1551:********************************************************************/
        -: 1552:
        3: 1553:int32 CFE_TBL_Modified( CFE_TBL_Handle_t TblHandle )
        -: 1554:{
        3: 1555:    int32                       Status = CFE_SUCCESS;
        3: 1556:    CFE_TBL_AccessDescriptor_t *AccessDescPtr = NULL;
        3: 1557:    CFE_TBL_RegistryRec_t      *RegRecPtr = NULL;
        -: 1558:    CFE_TBL_Handle_t            AccessIterator;
        -: 1559:    uint32                      ThisAppId;
        3: 1560:    size_t                      FilenameLen = 0;
        -: 1561:
        -: 1562:    /* Verify that this application has the right to perform operation */
        3: 1563:    Status = CFE_TBL_ValidateAccess(TblHandle, &ThisAppId);
        -: 1564:
        3: 1565:    if (Status == CFE_SUCCESS)
        -: 1566:    {
        -: 1567:        /* Get pointers to pertinent records in registry and handles */
        2: 1568:        AccessDescPtr = &CFE_TBL_TaskData.Handles[TblHandle];
        2: 1569:        RegRecPtr = &CFE_TBL_TaskData.Registry[AccessDescPtr->RegIndex];
        -: 1570:        
        -: 1571:        /* If the table is a critical table, update the appropriate CDS with the new data */
        2: 1572:        if (RegRecPtr->CriticalTable == TRUE)
        -: 1573:        {
        1: 1574:            CFE_TBL_UpdateCriticalTblCDS(RegRecPtr);
        -: 1575:        }
        -: 1576:        
        -: 1577:        /* Keep a record of change for the ground operators reference */
        2: 1578:        RegRecPtr->TimeOfLastUpdate = CFE_TIME_GetTime();
        2: 1579:        RegRecPtr->LastFileLoaded[OS_MAX_PATH_LEN-1] = '\0';
        -: 1580:        
        -: 1581:        /* Update CRC on contents of table */
        4: 1582:        RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].Crc = 
        2: 1583:            CFE_ES_CalculateCRC(RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].BufferPtr,
        -: 1584:                                RegRecPtr->Size,
        -: 1585:                                0,
        -: 1586:                                CFE_MISSION_ES_DEFAULT_CRC);
        -: 1587:
        2: 1588:        FilenameLen = strlen(RegRecPtr->LastFileLoaded);
        2: 1589:        if (FilenameLen < (OS_MAX_PATH_LEN-4))
        -: 1590:        {
        1: 1591:            strncpy(&RegRecPtr->LastFileLoaded[FilenameLen], "(*)", 4);
        -: 1592:        }
        -: 1593:        else
        -: 1594:        {
        1: 1595:            strncpy(&RegRecPtr->LastFileLoaded[(OS_MAX_PATH_LEN-4)], "(*)", 4);
        -: 1596:        }
        -: 1597:
        2: 1598:        AccessIterator = RegRecPtr->HeadOfAccessList;
        7: 1599:        while (AccessIterator != CFE_TBL_END_OF_LIST)
        -: 1600:        {
        -: 1601:            /* Only notify *OTHER* applications that the contents have changed */
        3: 1602:            if (CFE_TBL_TaskData.Handles[AccessIterator].AppId != ThisAppId)
        -: 1603:            {
        1: 1604:                CFE_TBL_TaskData.Handles[AccessIterator].Updated = TRUE;
        -: 1605:            }
        -: 1606:
        3: 1607:            AccessIterator = CFE_TBL_TaskData.Handles[AccessIterator].NextLink;
        -: 1608:        }
        -: 1609:    }
        -: 1610:    else
        -: 1611:    {
        1: 1612:        CFE_ES_WriteToSysLog("CFE_TBL:Modified-App(%d) does not have access to Tbl Handle=%d\n",
        -: 1613:                             (int)ThisAppId, (int)TblHandle);
        -: 1614:    }
        -: 1615:
        -: 1616:    
        3: 1617:    return Status;
        -: 1618:}
        -: 1619:
        -: 1620:
        -: 1621:/*******************************************************************
        -: 1622:**
        -: 1623:** CFE_TBL_NotifyByMessage - Instruct TBL Services to notify calling
        -: 1624:**                           application whenever the specified table
        -: 1625:**                           requires management.
        -: 1626:**
        -: 1627:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -: 1628:********************************************************************/
        -: 1629:
        3: 1630:int32 CFE_TBL_NotifyByMessage(CFE_TBL_Handle_t TblHandle, CFE_SB_MsgId_t MsgId, uint16 CommandCode, uint32 Parameter)
        -: 1631:{
        3: 1632:    int32                       Status = CFE_SUCCESS;
        3: 1633:    CFE_TBL_AccessDescriptor_t *AccessDescPtr = NULL;
        3: 1634:    CFE_TBL_RegistryRec_t      *RegRecPtr = NULL;
        -: 1635:    uint32                      ThisAppId;
        -: 1636:
        -: 1637:    /* Verify that this application has the right to perform operation */
        3: 1638:    Status = CFE_TBL_ValidateAccess(TblHandle, &ThisAppId);
        -: 1639:
        3: 1640:    if (Status == CFE_SUCCESS)
        -: 1641:    {
        -: 1642:        /* Get pointers to pertinent records in registry and handles */
        2: 1643:        AccessDescPtr = &CFE_TBL_TaskData.Handles[TblHandle];
        2: 1644:        RegRecPtr = &CFE_TBL_TaskData.Registry[AccessDescPtr->RegIndex];
        -: 1645:        
        -: 1646:        /* Verify that the calling application is the table owner */
        2: 1647:        if (RegRecPtr->OwnerAppId == ThisAppId)
        -: 1648:        {
        1: 1649:            RegRecPtr->NotificationMsgId = MsgId;
        1: 1650:            RegRecPtr->NotificationCC = CommandCode;
        1: 1651:            RegRecPtr->NotificationParam = Parameter;
        1: 1652:            RegRecPtr->NotifyByMsg = TRUE;
        -: 1653:        }
        -: 1654:        else
        -: 1655:        {
        1: 1656:            Status = CFE_TBL_ERR_NO_ACCESS;
        1: 1657:            CFE_ES_WriteToSysLog("CFE_TBL:NotifyByMsg-App(%d) does not own Tbl Handle=%d\n",
        -: 1658:                                 (int)ThisAppId, (int)TblHandle);
        -: 1659:        }
        -: 1660:    }
        -: 1661:    
        3: 1662:    return Status;
        -: 1663:}
        -: 1664:
        -: 1665:/************************/
        -: 1666:/*  End of File Comment */
        -: 1667:/************************/
        -: 1668:
